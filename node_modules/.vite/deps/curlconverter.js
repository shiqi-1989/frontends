import {
  __commonJS,
  __esm,
  __export,
  __require,
  __toCommonJS,
  __toESM
} from "./chunk-ACCAMVX6.js";

// browser-external:path
var path_exports = {};
__export(path_exports, {
  default: () => path_default
});
var path_default;
var init_path = __esm({
  "browser-external:path"() {
    path_default = new Proxy({}, {
      get() {
        throw new Error('Module "path" has been externalized for browser compatibility and cannot be accessed in client code.');
      }
    });
  }
});

// browser-external:fs
var fs_exports = {};
__export(fs_exports, {
  default: () => fs_default
});
var fs_default;
var init_fs = __esm({
  "browser-external:fs"() {
    fs_default = new Proxy({}, {
      get() {
        throw new Error('Module "fs" has been externalized for browser compatibility and cannot be accessed in client code.');
      }
    });
  }
});

// node_modules/web-tree-sitter/tree-sitter.js
var require_tree_sitter = __commonJS({
  "node_modules/web-tree-sitter/tree-sitter.js"(exports, module) {
    var Module = Module !== void 0 ? Module : {};
    var TreeSitter = function() {
      var e, t = typeof window == "object" ? { currentScript: window.document.currentScript } : null;
      class Parser2 {
        constructor() {
          this.initialize();
        }
        initialize() {
          throw new Error("cannot construct a Parser before calling `init()`");
        }
        static init(r) {
          return e || (Module = Object.assign({}, Module, r), e = new Promise((e2) => {
            var r2, n = {};
            for (r2 in Module)
              Module.hasOwnProperty(r2) && (n[r2] = Module[r2]);
            var o, s, _ = [], a = "./this.program", i = function(e3, t2) {
              throw t2;
            }, u = false, l = false;
            u = typeof window == "object", l = typeof importScripts == "function", o = typeof process == "object" && typeof process.versions == "object" && typeof process.versions.node == "string", s = !u && !o && !l;
            var d, c, m, f, p, h = "";
            o ? (h = l ? (init_path(), __toCommonJS(path_exports)).dirname(h) + "/" : __dirname + "/", d = function(e3, t2) {
              return f || (f = (init_fs(), __toCommonJS(fs_exports))), p || (p = (init_path(), __toCommonJS(path_exports))), e3 = p.normalize(e3), f.readFileSync(e3, t2 ? null : "utf8");
            }, m = function(e3) {
              var t2 = d(e3, true);
              return t2.buffer || (t2 = new Uint8Array(t2)), k(t2.buffer), t2;
            }, process.argv.length > 1 && (a = process.argv[1].replace(/\\/g, "/")), _ = process.argv.slice(2), typeof module != "undefined" && (module.exports = Module), i = function(e3) {
              process.exit(e3);
            }, Module.inspect = function() {
              return "[Emscripten Module object]";
            }) : s ? (typeof read != "undefined" && (d = function(e3) {
              return read(e3);
            }), m = function(e3) {
              var t2;
              return typeof readbuffer == "function" ? new Uint8Array(readbuffer(e3)) : (k(typeof (t2 = read(e3, "binary")) == "object"), t2);
            }, typeof scriptArgs != "undefined" ? _ = scriptArgs : arguments !== void 0 && (_ = arguments), typeof quit == "function" && (i = function(e3) {
              quit(e3);
            }), typeof print != "undefined" && (typeof console == "undefined" && (console = {}), console.log = print, console.warn = console.error = typeof printErr != "undefined" ? printErr : print)) : (u || l) && (l ? h = self.location.href : t !== void 0 && t.currentScript && (h = t.currentScript.src), h = h.indexOf("blob:") !== 0 ? h.substr(0, h.lastIndexOf("/") + 1) : "", d = function(e3) {
              var t2 = new XMLHttpRequest();
              return t2.open("GET", e3, false), t2.send(null), t2.responseText;
            }, l && (m = function(e3) {
              var t2 = new XMLHttpRequest();
              return t2.open("GET", e3, false), t2.responseType = "arraybuffer", t2.send(null), new Uint8Array(t2.response);
            }), c = function(e3, t2, r3) {
              var n2 = new XMLHttpRequest();
              n2.open("GET", e3, true), n2.responseType = "arraybuffer", n2.onload = function() {
                n2.status == 200 || n2.status == 0 && n2.response ? t2(n2.response) : r3();
              }, n2.onerror = r3, n2.send(null);
            });
            Module.print || console.log.bind(console);
            var g = Module.printErr || console.warn.bind(console);
            for (r2 in n)
              n.hasOwnProperty(r2) && (Module[r2] = n[r2]);
            n = null, Module.arguments && (_ = Module.arguments), Module.thisProgram && (a = Module.thisProgram), Module.quit && (i = Module.quit);
            var w = 16;
            var M, y = [];
            function b(e3, t2) {
              if (!M) {
                M = /* @__PURE__ */ new WeakMap();
                for (var r3 = 0; r3 < K.length; r3++) {
                  var n2 = K.get(r3);
                  n2 && M.set(n2, r3);
                }
              }
              if (M.has(e3))
                return M.get(e3);
              var o2 = function() {
                if (y.length)
                  return y.pop();
                try {
                  K.grow(1);
                } catch (e4) {
                  if (!(e4 instanceof RangeError))
                    throw e4;
                  throw "Unable to grow wasm table. Set ALLOW_TABLE_GROWTH.";
                }
                return K.length - 1;
              }();
              try {
                K.set(o2, e3);
              } catch (r4) {
                if (!(r4 instanceof TypeError))
                  throw r4;
                var s2 = function(e4, t3) {
                  if (typeof WebAssembly.Function == "function") {
                    for (var r5 = { i: "i32", j: "i64", f: "f32", d: "f64" }, n3 = { parameters: [], results: t3[0] == "v" ? [] : [r5[t3[0]]] }, o3 = 1; o3 < t3.length; ++o3)
                      n3.parameters.push(r5[t3[o3]]);
                    return new WebAssembly.Function(n3, e4);
                  }
                  var s3 = [1, 0, 1, 96], _2 = t3.slice(0, 1), a2 = t3.slice(1), i2 = { i: 127, j: 126, f: 125, d: 124 };
                  for (s3.push(a2.length), o3 = 0; o3 < a2.length; ++o3)
                    s3.push(i2[a2[o3]]);
                  _2 == "v" ? s3.push(0) : s3 = s3.concat([1, i2[_2]]), s3[1] = s3.length - 2;
                  var u2 = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0].concat(s3, [2, 7, 1, 1, 101, 1, 102, 0, 0, 7, 5, 1, 1, 102, 0, 0])), l2 = new WebAssembly.Module(u2);
                  return new WebAssembly.Instance(l2, { e: { f: e4 } }).exports.f;
                }(e3, t2);
                K.set(o2, s2);
              }
              return M.set(e3, o2), o2;
            }
            var v, E = function(e3) {
              e3;
            }, S = Module.dynamicLibraries || [];
            Module.wasmBinary && (v = Module.wasmBinary);
            var I, A = Module.noExitRuntime || true;
            function x(e3, t2, r3, n2) {
              switch ((r3 = r3 || "i8").charAt(r3.length - 1) === "*" && (r3 = "i32"), r3) {
                case "i1":
                case "i8":
                  q[e3 >> 0] = t2;
                  break;
                case "i16":
                  R[e3 >> 1] = t2;
                  break;
                case "i32":
                  W[e3 >> 2] = t2;
                  break;
                case "i64":
                  ie = [t2 >>> 0, (ae = t2, +Math.abs(ae) >= 1 ? ae > 0 ? (0 | Math.min(+Math.floor(ae / 4294967296), 4294967295)) >>> 0 : ~~+Math.ceil((ae - +(~~ae >>> 0)) / 4294967296) >>> 0 : 0)], W[e3 >> 2] = ie[0], W[e3 + 4 >> 2] = ie[1];
                  break;
                case "float":
                  L[e3 >> 2] = t2;
                  break;
                case "double":
                  O[e3 >> 3] = t2;
                  break;
                default:
                  se("invalid type for setValue: " + r3);
              }
            }
            function N(e3, t2, r3) {
              switch ((t2 = t2 || "i8").charAt(t2.length - 1) === "*" && (t2 = "i32"), t2) {
                case "i1":
                case "i8":
                  return q[e3 >> 0];
                case "i16":
                  return R[e3 >> 1];
                case "i32":
                case "i64":
                  return W[e3 >> 2];
                case "float":
                  return L[e3 >> 2];
                case "double":
                  return O[e3 >> 3];
                default:
                  se("invalid type for getValue: " + t2);
              }
              return null;
            }
            typeof WebAssembly != "object" && se("no native wasm support detected");
            var P = false;
            function k(e3, t2) {
              e3 || se("Assertion failed: " + t2);
            }
            var F = 1;
            var C, q, T, R, W, L, O, j = typeof TextDecoder != "undefined" ? new TextDecoder("utf8") : void 0;
            function $(e3, t2, r3) {
              for (var n2 = t2 + r3, o2 = t2; e3[o2] && !(o2 >= n2); )
                ++o2;
              if (o2 - t2 > 16 && e3.subarray && j)
                return j.decode(e3.subarray(t2, o2));
              for (var s2 = ""; t2 < o2; ) {
                var _2 = e3[t2++];
                if (128 & _2) {
                  var a2 = 63 & e3[t2++];
                  if ((224 & _2) != 192) {
                    var i2 = 63 & e3[t2++];
                    if ((_2 = (240 & _2) == 224 ? (15 & _2) << 12 | a2 << 6 | i2 : (7 & _2) << 18 | a2 << 12 | i2 << 6 | 63 & e3[t2++]) < 65536)
                      s2 += String.fromCharCode(_2);
                    else {
                      var u2 = _2 - 65536;
                      s2 += String.fromCharCode(55296 | u2 >> 10, 56320 | 1023 & u2);
                    }
                  } else
                    s2 += String.fromCharCode((31 & _2) << 6 | a2);
                } else
                  s2 += String.fromCharCode(_2);
              }
              return s2;
            }
            function Z(e3, t2) {
              return e3 ? $(T, e3, t2) : "";
            }
            function D(e3, t2, r3, n2) {
              if (!(n2 > 0))
                return 0;
              for (var o2 = r3, s2 = r3 + n2 - 1, _2 = 0; _2 < e3.length; ++_2) {
                var a2 = e3.charCodeAt(_2);
                if (a2 >= 55296 && a2 <= 57343)
                  a2 = 65536 + ((1023 & a2) << 10) | 1023 & e3.charCodeAt(++_2);
                if (a2 <= 127) {
                  if (r3 >= s2)
                    break;
                  t2[r3++] = a2;
                } else if (a2 <= 2047) {
                  if (r3 + 1 >= s2)
                    break;
                  t2[r3++] = 192 | a2 >> 6, t2[r3++] = 128 | 63 & a2;
                } else if (a2 <= 65535) {
                  if (r3 + 2 >= s2)
                    break;
                  t2[r3++] = 224 | a2 >> 12, t2[r3++] = 128 | a2 >> 6 & 63, t2[r3++] = 128 | 63 & a2;
                } else {
                  if (r3 + 3 >= s2)
                    break;
                  t2[r3++] = 240 | a2 >> 18, t2[r3++] = 128 | a2 >> 12 & 63, t2[r3++] = 128 | a2 >> 6 & 63, t2[r3++] = 128 | 63 & a2;
                }
              }
              return t2[r3] = 0, r3 - o2;
            }
            function z(e3, t2, r3) {
              return D(e3, T, t2, r3);
            }
            function U(e3) {
              for (var t2 = 0, r3 = 0; r3 < e3.length; ++r3) {
                var n2 = e3.charCodeAt(r3);
                n2 >= 55296 && n2 <= 57343 && (n2 = 65536 + ((1023 & n2) << 10) | 1023 & e3.charCodeAt(++r3)), n2 <= 127 ? ++t2 : t2 += n2 <= 2047 ? 2 : n2 <= 65535 ? 3 : 4;
              }
              return t2;
            }
            function H(e3) {
              var t2 = U(e3) + 1, r3 = Be(t2);
              return D(e3, q, r3, t2), r3;
            }
            function G(e3) {
              C = e3, Module.HEAP8 = q = new Int8Array(e3), Module.HEAP16 = R = new Int16Array(e3), Module.HEAP32 = W = new Int32Array(e3), Module.HEAPU8 = T = new Uint8Array(e3), Module.HEAPU16 = new Uint16Array(e3), Module.HEAPU32 = new Uint32Array(e3), Module.HEAPF32 = L = new Float32Array(e3), Module.HEAPF64 = O = new Float64Array(e3);
            }
            var B = Module.INITIAL_MEMORY || 33554432;
            (I = Module.wasmMemory ? Module.wasmMemory : new WebAssembly.Memory({ initial: B / 65536, maximum: 32768 })) && (C = I.buffer), B = C.byteLength, G(C);
            var K = new WebAssembly.Table({ initial: 20, element: "anyfunc" }), V = [], X = [], Q = [], J = [], Y = false;
            var ee = 0, te = null, re = null;
            function ne(e3) {
              ee++, Module.monitorRunDependencies && Module.monitorRunDependencies(ee);
            }
            function oe(e3) {
              if (ee--, Module.monitorRunDependencies && Module.monitorRunDependencies(ee), ee == 0 && (te !== null && (clearInterval(te), te = null), re)) {
                var t2 = re;
                re = null, t2();
              }
            }
            function se(e3) {
              throw Module.onAbort && Module.onAbort(e3), g(e3 += ""), P = true, 1, e3 = "abort(" + e3 + "). Build with -s ASSERTIONS=1 for more info.", new WebAssembly.RuntimeError(e3);
            }
            Module.preloadedImages = {}, Module.preloadedAudios = {}, Module.preloadedWasm = {};
            var _e, ae, ie, ue = "data:application/octet-stream;base64,";
            function le(e3) {
              return e3.startsWith(ue);
            }
            function de(e3) {
              return e3.startsWith("file://");
            }
            function ce(e3) {
              try {
                if (e3 == _e && v)
                  return new Uint8Array(v);
                if (m)
                  return m(e3);
                throw "both async and sync fetching of the wasm failed";
              } catch (e4) {
                se(e4);
              }
            }
            le(_e = "tree-sitter.wasm") || (_e = function(e3) {
              return Module.locateFile ? Module.locateFile(e3, h) : h + e3;
            }(_e));
            var me = {}, fe = { get: function(e3, t2) {
              return me[t2] || (me[t2] = new WebAssembly.Global({ value: "i32", mutable: true })), me[t2];
            } };
            function pe(e3) {
              for (; e3.length > 0; ) {
                var t2 = e3.shift();
                if (typeof t2 != "function") {
                  var r3 = t2.func;
                  typeof r3 == "number" ? t2.arg === void 0 ? K.get(r3)() : K.get(r3)(t2.arg) : r3(t2.arg === void 0 ? null : t2.arg);
                } else
                  t2(Module);
              }
            }
            function he(e3) {
              var t2 = 0;
              function r3() {
                for (var r4 = 0, n3 = 1; ; ) {
                  var o3 = e3[t2++];
                  if (r4 += (127 & o3) * n3, n3 *= 128, !(128 & o3))
                    break;
                }
                return r4;
              }
              if (e3 instanceof WebAssembly.Module) {
                var n2 = WebAssembly.Module.customSections(e3, "dylink");
                k(n2.length != 0, "need dylink section"), e3 = new Int8Array(n2[0]);
              } else {
                k(new Uint32Array(new Uint8Array(e3.subarray(0, 24)).buffer)[0] == 1836278016, "need to see wasm magic number"), k(e3[8] === 0, "need the dylink section to be first"), t2 = 9, r3(), k(e3[t2] === 6), k(e3[++t2] === "d".charCodeAt(0)), k(e3[++t2] === "y".charCodeAt(0)), k(e3[++t2] === "l".charCodeAt(0)), k(e3[++t2] === "i".charCodeAt(0)), k(e3[++t2] === "n".charCodeAt(0)), k(e3[++t2] === "k".charCodeAt(0)), t2++;
              }
              var o2 = {};
              o2.memorySize = r3(), o2.memoryAlign = r3(), o2.tableSize = r3(), o2.tableAlign = r3();
              var s2 = r3();
              o2.neededDynlibs = [];
              for (var _2 = 0; _2 < s2; ++_2) {
                var a2 = r3(), i2 = e3.subarray(t2, t2 + a2);
                t2 += a2;
                var u2 = $(i2, 0);
                o2.neededDynlibs.push(u2);
              }
              return o2;
            }
            var ge = 0;
            function we() {
              return A || ge > 0;
            }
            function Me(e3) {
              return e3.indexOf("dynCall_") == 0 || ["stackAlloc", "stackSave", "stackRestore"].includes(e3) ? e3 : "_" + e3;
            }
            function ye(e3, t2) {
              for (var r3 in e3)
                if (e3.hasOwnProperty(r3)) {
                  De.hasOwnProperty(r3) || (De[r3] = e3[r3]);
                  var n2 = Me(r3);
                  Module.hasOwnProperty(n2) || (Module[n2] = e3[r3]);
                }
            }
            var be = { nextHandle: 1, loadedLibs: {}, loadedLibNames: {} };
            function ve(e3, t2, r3) {
              return e3.includes("j") ? function(e4, t3, r4) {
                var n2 = Module["dynCall_" + e4];
                return r4 && r4.length ? n2.apply(null, [t3].concat(r4)) : n2.call(null, t3);
              }(e3, t2, r3) : K.get(t2).apply(null, r3);
            }
            var Ee = 5251072;
            function Se(e3) {
              return ["__cpp_exception", "__wasm_apply_data_relocs", "__dso_handle", "__set_stack_limits"].includes(e3);
            }
            function Ie(e3, t2) {
              var r3 = {};
              for (var n2 in e3) {
                var o2 = e3[n2];
                typeof o2 == "object" && (o2 = o2.value), typeof o2 == "number" && (o2 += t2), r3[n2] = o2;
              }
              return function(e4) {
                for (var t3 in e4)
                  if (!Se(t3)) {
                    var r4 = false, n3 = e4[t3];
                    t3.startsWith("orig$") && (t3 = t3.split("$")[1], r4 = true), me[t3] || (me[t3] = new WebAssembly.Global({ value: "i32", mutable: true })), (r4 || me[t3].value == 0) && (typeof n3 == "function" ? me[t3].value = b(n3) : typeof n3 == "number" ? me[t3].value = n3 : g("unhandled export type for `" + t3 + "`: " + typeof n3));
                  }
              }(r3), r3;
            }
            function Ae(e3, t2) {
              var r3, n2;
              return t2 && (r3 = De["orig$" + e3]), r3 || (r3 = De[e3]), r3 || (r3 = Module[Me(e3)]), !r3 && e3.startsWith("invoke_") && (n2 = e3.split("_")[1], r3 = function() {
                var e4 = He();
                try {
                  return ve(n2, arguments[0], Array.prototype.slice.call(arguments, 1));
                } catch (t3) {
                  if (Ge(e4), t3 !== t3 + 0 && t3 !== "longjmp")
                    throw t3;
                  Ke(1, 0);
                }
              }), r3;
            }
            function xe(e3, t2) {
              var r3 = he(e3);
              function n2() {
                var n3 = Math.pow(2, r3.memoryAlign);
                n3 = Math.max(n3, w);
                var o2, s2, _2, a2 = (o2 = function(e4) {
                  if (Y)
                    return ze(e4);
                  var t3 = Ee, r4 = t3 + e4 + 15 & -16;
                  return Ee = r4, me.__heap_base.value = r4, t3;
                }(r3.memorySize + n3), (s2 = n3) || (s2 = w), Math.ceil(o2 / s2) * s2), i2 = K.length;
                K.grow(r3.tableSize);
                for (var u2 = a2; u2 < a2 + r3.memorySize; u2++)
                  q[u2] = 0;
                for (u2 = i2; u2 < i2 + r3.tableSize; u2++)
                  K.set(u2, null);
                var l2 = new Proxy({}, { get: function(e4, t3) {
                  switch (t3) {
                    case "__memory_base":
                      return a2;
                    case "__table_base":
                      return i2;
                  }
                  if (t3 in De)
                    return De[t3];
                  var r4;
                  t3 in e4 || (e4[t3] = function() {
                    return r4 || (r4 = function(e5) {
                      var t4 = Ae(e5, false);
                      return t4 || (t4 = _2[e5]), t4;
                    }(t3)), r4.apply(null, arguments);
                  });
                  return e4[t3];
                } }), d2 = { "GOT.mem": new Proxy({}, fe), "GOT.func": new Proxy({}, fe), env: l2, wasi_snapshot_preview1: l2 };
                function c2(e4) {
                  for (var n4 = 0; n4 < r3.tableSize; n4++) {
                    var o3 = K.get(i2 + n4);
                    o3 && M.set(o3, i2 + n4);
                  }
                  _2 = Ie(e4.exports, a2), t2.allowUndefined || Pe();
                  var s3 = _2.__wasm_call_ctors;
                  return s3 || (s3 = _2.__post_instantiate), s3 && (Y ? s3() : X.push(s3)), _2;
                }
                if (t2.loadAsync) {
                  if (e3 instanceof WebAssembly.Module) {
                    var m2 = new WebAssembly.Instance(e3, d2);
                    return Promise.resolve(c2(m2));
                  }
                  return WebAssembly.instantiate(e3, d2).then(function(e4) {
                    return c2(e4.instance);
                  });
                }
                var f2 = e3 instanceof WebAssembly.Module ? e3 : new WebAssembly.Module(e3);
                return c2(m2 = new WebAssembly.Instance(f2, d2));
              }
              return t2.loadAsync ? r3.neededDynlibs.reduce(function(e4, r4) {
                return e4.then(function() {
                  return Ne(r4, t2);
                });
              }, Promise.resolve()).then(function() {
                return n2();
              }) : (r3.neededDynlibs.forEach(function(e4) {
                Ne(e4, t2);
              }), n2());
            }
            function Ne(e3, t2) {
              e3 != "__main__" || be.loadedLibNames[e3] || (be.loadedLibs[-1] = { refcount: 1 / 0, name: "__main__", module: Module.asm, global: true }, be.loadedLibNames.__main__ = -1), t2 = t2 || { global: true, nodelete: true };
              var r3, n2 = be.loadedLibNames[e3];
              if (n2)
                return r3 = be.loadedLibs[n2], t2.global && !r3.global && (r3.global = true, r3.module !== "loading" && ye(r3.module)), t2.nodelete && r3.refcount !== 1 / 0 && (r3.refcount = 1 / 0), r3.refcount++, t2.loadAsync ? Promise.resolve(n2) : n2;
              function o2(e4) {
                if (t2.fs) {
                  var r4 = t2.fs.readFile(e4, { encoding: "binary" });
                  return r4 instanceof Uint8Array || (r4 = new Uint8Array(r4)), t2.loadAsync ? Promise.resolve(r4) : r4;
                }
                return t2.loadAsync ? (n3 = e4, fetch(n3, { credentials: "same-origin" }).then(function(e5) {
                  if (!e5.ok)
                    throw "failed to load binary file at '" + n3 + "'";
                  return e5.arrayBuffer();
                }).then(function(e5) {
                  return new Uint8Array(e5);
                })) : m(e4);
                var n3;
              }
              function s2() {
                if (Module.preloadedWasm !== void 0 && Module.preloadedWasm[e3] !== void 0) {
                  var r4 = Module.preloadedWasm[e3];
                  return t2.loadAsync ? Promise.resolve(r4) : r4;
                }
                return t2.loadAsync ? o2(e3).then(function(e4) {
                  return xe(e4, t2);
                }) : xe(o2(e3), t2);
              }
              function _2(e4) {
                r3.global && ye(e4), r3.module = e4;
              }
              return n2 = be.nextHandle++, r3 = { refcount: t2.nodelete ? 1 / 0 : 1, name: e3, module: "loading", global: t2.global }, be.loadedLibNames[e3] = n2, be.loadedLibs[n2] = r3, t2.loadAsync ? s2().then(function(e4) {
                return _2(e4), n2;
              }) : (_2(s2()), n2);
            }
            function Pe() {
              for (var e3 in me)
                if (me[e3].value == 0) {
                  var t2 = Ae(e3, true);
                  typeof t2 == "function" ? me[e3].value = b(t2, t2.sig) : typeof t2 == "number" ? me[e3].value = t2 : k(false, "bad export type for `" + e3 + "`: " + typeof t2);
                }
            }
            Module.___heap_base = Ee;
            var ke, Fe = new WebAssembly.Global({ value: "i32", mutable: true }, 5251072);
            function Ce() {
              se();
            }
            Module._abort = Ce, Ce.sig = "v", ke = o ? function() {
              var e3 = process.hrtime();
              return 1e3 * e3[0] + e3[1] / 1e6;
            } : typeof dateNow != "undefined" ? dateNow : function() {
              return performance.now();
            };
            var qe = true;
            function Te(e3, t2) {
              var r3, n2;
              if (e3 === 0)
                r3 = Date.now();
              else {
                if (e3 !== 1 && e3 !== 4 || !qe)
                  return n2 = 28, W[Ue() >> 2] = n2, -1;
                r3 = ke();
              }
              return W[t2 >> 2] = r3 / 1e3 | 0, W[t2 + 4 >> 2] = r3 % 1e3 * 1e3 * 1e3 | 0, 0;
            }
            function Re(e3) {
              try {
                return I.grow(e3 - C.byteLength + 65535 >>> 16), G(I.buffer), 1;
              } catch (e4) {
              }
            }
            function We(e3) {
              Je(e3);
            }
            Te.sig = "iii", We.sig = "vi";
            var Le = { mappings: {}, DEFAULT_POLLMASK: 5, umask: 511, calculateAt: function(e3, t2, r3) {
              if (t2[0] === "/")
                return t2;
              var n2;
              if (e3 === -100)
                n2 = FS.cwd();
              else {
                var o2 = FS.getStream(e3);
                if (!o2)
                  throw new FS.ErrnoError(8);
                n2 = o2.path;
              }
              if (t2.length == 0) {
                if (!r3)
                  throw new FS.ErrnoError(44);
                return n2;
              }
              return PATH.join2(n2, t2);
            }, doStat: function(e3, t2, r3) {
              try {
                var n2 = e3(t2);
              } catch (e4) {
                if (e4 && e4.node && PATH.normalize(t2) !== PATH.normalize(FS.getPath(e4.node)))
                  return -54;
                throw e4;
              }
              return W[r3 >> 2] = n2.dev, W[r3 + 4 >> 2] = 0, W[r3 + 8 >> 2] = n2.ino, W[r3 + 12 >> 2] = n2.mode, W[r3 + 16 >> 2] = n2.nlink, W[r3 + 20 >> 2] = n2.uid, W[r3 + 24 >> 2] = n2.gid, W[r3 + 28 >> 2] = n2.rdev, W[r3 + 32 >> 2] = 0, ie = [n2.size >>> 0, (ae = n2.size, +Math.abs(ae) >= 1 ? ae > 0 ? (0 | Math.min(+Math.floor(ae / 4294967296), 4294967295)) >>> 0 : ~~+Math.ceil((ae - +(~~ae >>> 0)) / 4294967296) >>> 0 : 0)], W[r3 + 40 >> 2] = ie[0], W[r3 + 44 >> 2] = ie[1], W[r3 + 48 >> 2] = 4096, W[r3 + 52 >> 2] = n2.blocks, W[r3 + 56 >> 2] = n2.atime.getTime() / 1e3 | 0, W[r3 + 60 >> 2] = 0, W[r3 + 64 >> 2] = n2.mtime.getTime() / 1e3 | 0, W[r3 + 68 >> 2] = 0, W[r3 + 72 >> 2] = n2.ctime.getTime() / 1e3 | 0, W[r3 + 76 >> 2] = 0, ie = [n2.ino >>> 0, (ae = n2.ino, +Math.abs(ae) >= 1 ? ae > 0 ? (0 | Math.min(+Math.floor(ae / 4294967296), 4294967295)) >>> 0 : ~~+Math.ceil((ae - +(~~ae >>> 0)) / 4294967296) >>> 0 : 0)], W[r3 + 80 >> 2] = ie[0], W[r3 + 84 >> 2] = ie[1], 0;
            }, doMsync: function(e3, t2, r3, n2, o2) {
              var s2 = T.slice(e3, e3 + r3);
              FS.msync(t2, s2, o2, r3, n2);
            }, doMkdir: function(e3, t2) {
              return (e3 = PATH.normalize(e3))[e3.length - 1] === "/" && (e3 = e3.substr(0, e3.length - 1)), FS.mkdir(e3, t2, 0), 0;
            }, doMknod: function(e3, t2, r3) {
              switch (61440 & t2) {
                case 32768:
                case 8192:
                case 24576:
                case 4096:
                case 49152:
                  break;
                default:
                  return -28;
              }
              return FS.mknod(e3, t2, r3), 0;
            }, doReadlink: function(e3, t2, r3) {
              if (r3 <= 0)
                return -28;
              var n2 = FS.readlink(e3), o2 = Math.min(r3, U(n2)), s2 = q[t2 + o2];
              return z(n2, t2, r3 + 1), q[t2 + o2] = s2, o2;
            }, doAccess: function(e3, t2) {
              if (-8 & t2)
                return -28;
              var r3;
              if (!(r3 = FS.lookupPath(e3, { follow: true }).node))
                return -44;
              var n2 = "";
              return 4 & t2 && (n2 += "r"), 2 & t2 && (n2 += "w"), 1 & t2 && (n2 += "x"), n2 && FS.nodePermissions(r3, n2) ? -2 : 0;
            }, doDup: function(e3, t2, r3) {
              var n2 = FS.getStream(r3);
              return n2 && FS.close(n2), FS.open(e3, t2, 0, r3, r3).fd;
            }, doReadv: function(e3, t2, r3, n2) {
              for (var o2 = 0, s2 = 0; s2 < r3; s2++) {
                var _2 = W[t2 + 8 * s2 >> 2], a2 = W[t2 + (8 * s2 + 4) >> 2], i2 = FS.read(e3, q, _2, a2, n2);
                if (i2 < 0)
                  return -1;
                if (o2 += i2, i2 < a2)
                  break;
              }
              return o2;
            }, doWritev: function(e3, t2, r3, n2) {
              for (var o2 = 0, s2 = 0; s2 < r3; s2++) {
                var _2 = W[t2 + 8 * s2 >> 2], a2 = W[t2 + (8 * s2 + 4) >> 2], i2 = FS.write(e3, q, _2, a2, n2);
                if (i2 < 0)
                  return -1;
                o2 += i2;
              }
              return o2;
            }, varargs: void 0, get: function() {
              return Le.varargs += 4, W[Le.varargs - 4 >> 2];
            }, getStr: function(e3) {
              return Z(e3);
            }, getStreamFromFD: function(e3) {
              var t2 = FS.getStream(e3);
              if (!t2)
                throw new FS.ErrnoError(8);
              return t2;
            }, get64: function(e3, t2) {
              return e3;
            } };
            function Oe(e3) {
              try {
                var t2 = Le.getStreamFromFD(e3);
                return FS.close(t2), 0;
              } catch (e4) {
                return typeof FS != "undefined" && e4 instanceof FS.ErrnoError || se(e4), e4.errno;
              }
            }
            function je(e3, t2, r3, n2) {
              try {
                var o2 = Le.getStreamFromFD(e3), s2 = Le.doWritev(o2, t2, r3);
                return W[n2 >> 2] = s2, 0;
              } catch (e4) {
                return typeof FS != "undefined" && e4 instanceof FS.ErrnoError || se(e4), e4.errno;
              }
            }
            function $e(e3) {
              E(e3);
            }
            Oe.sig = "ii", je.sig = "iiiii", $e.sig = "vi";
            var Ze, De = { __heap_base: Ee, __indirect_function_table: K, __memory_base: 1024, __stack_pointer: Fe, __table_base: 1, abort: Ce, clock_gettime: Te, emscripten_memcpy_big: function(e3, t2, r3) {
              T.copyWithin(e3, t2, t2 + r3);
            }, emscripten_resize_heap: function(e3) {
              var t2, r3, n2 = T.length;
              if ((e3 >>>= 0) > 2147483648)
                return false;
              for (var o2 = 1; o2 <= 4; o2 *= 2) {
                var s2 = n2 * (1 + 0.2 / o2);
                if (s2 = Math.min(s2, e3 + 100663296), Re(Math.min(2147483648, ((t2 = Math.max(e3, s2)) % (r3 = 65536) > 0 && (t2 += r3 - t2 % r3), t2))))
                  return true;
              }
              return false;
            }, exit: We, fd_close: Oe, fd_seek: function(e3, t2, r3, n2, o2) {
              try {
                var s2 = Le.getStreamFromFD(e3), _2 = 4294967296 * r3 + (t2 >>> 0);
                return _2 <= -9007199254740992 || _2 >= 9007199254740992 ? -61 : (FS.llseek(s2, _2, n2), ie = [s2.position >>> 0, (ae = s2.position, +Math.abs(ae) >= 1 ? ae > 0 ? (0 | Math.min(+Math.floor(ae / 4294967296), 4294967295)) >>> 0 : ~~+Math.ceil((ae - +(~~ae >>> 0)) / 4294967296) >>> 0 : 0)], W[o2 >> 2] = ie[0], W[o2 + 4 >> 2] = ie[1], s2.getdents && _2 === 0 && n2 === 0 && (s2.getdents = null), 0);
              } catch (e4) {
                return typeof FS != "undefined" && e4 instanceof FS.ErrnoError || se(e4), e4.errno;
              }
            }, fd_write: je, memory: I, setTempRet0: $e, tree_sitter_log_callback: function(e3, t2) {
              if (pt) {
                const r3 = Z(t2);
                pt(r3, e3 !== 0);
              }
            }, tree_sitter_parse_callback: function(e3, t2, r3, n2, o2) {
              var s2 = ft(t2, { row: r3, column: n2 });
              typeof s2 == "string" ? (x(o2, s2.length, "i32"), function(e4, t3, r4) {
                if (r4 === void 0 && (r4 = 2147483647), r4 < 2)
                  return 0;
                for (var n3 = (r4 -= 2) < 2 * e4.length ? r4 / 2 : e4.length, o3 = 0; o3 < n3; ++o3) {
                  var s3 = e4.charCodeAt(o3);
                  R[t3 >> 1] = s3, t3 += 2;
                }
                R[t3 >> 1] = 0;
              }(s2, e3, 10240)) : x(o2, 0, "i32");
            } }, ze = (function() {
              var e3 = { env: De, wasi_snapshot_preview1: De, "GOT.mem": new Proxy(De, fe), "GOT.func": new Proxy(De, fe) };
              function t2(e4, t3) {
                var r4 = e4.exports;
                r4 = Ie(r4, 1024), Module.asm = r4;
                var n3, o2 = he(t3);
                o2.neededDynlibs && (S = o2.neededDynlibs.concat(S)), ye(r4), n3 = Module.asm.__wasm_call_ctors, X.unshift(n3), oe();
              }
              function r3(e4) {
                t2(e4.instance, e4.module);
              }
              function n2(t3) {
                return function() {
                  if (!v && (u || l)) {
                    if (typeof fetch == "function" && !de(_e))
                      return fetch(_e, { credentials: "same-origin" }).then(function(e4) {
                        if (!e4.ok)
                          throw "failed to load wasm binary file at '" + _e + "'";
                        return e4.arrayBuffer();
                      }).catch(function() {
                        return ce(_e);
                      });
                    if (c)
                      return new Promise(function(e4, t4) {
                        c(_e, function(t5) {
                          e4(new Uint8Array(t5));
                        }, t4);
                      });
                  }
                  return Promise.resolve().then(function() {
                    return ce(_e);
                  });
                }().then(function(t4) {
                  return WebAssembly.instantiate(t4, e3);
                }).then(t3, function(e4) {
                  g("failed to asynchronously prepare wasm: " + e4), se(e4);
                });
              }
              if (ne(), Module.instantiateWasm)
                try {
                  return Module.instantiateWasm(e3, t2);
                } catch (e4) {
                  return g("Module.instantiateWasm callback failed with error: " + e4), false;
                }
              v || typeof WebAssembly.instantiateStreaming != "function" || le(_e) || de(_e) || typeof fetch != "function" ? n2(r3) : fetch(_e, { credentials: "same-origin" }).then(function(t3) {
                return WebAssembly.instantiateStreaming(t3, e3).then(r3, function(e4) {
                  return g("wasm streaming compile failed: " + e4), g("falling back to ArrayBuffer instantiation"), n2(r3);
                });
              });
            }(), Module.___wasm_call_ctors = function() {
              return (Module.___wasm_call_ctors = Module.asm.__wasm_call_ctors).apply(null, arguments);
            }, Module._malloc = function() {
              return (ze = Module._malloc = Module.asm.malloc).apply(null, arguments);
            }), Ue = (Module._calloc = function() {
              return (Module._calloc = Module.asm.calloc).apply(null, arguments);
            }, Module._realloc = function() {
              return (Module._realloc = Module.asm.realloc).apply(null, arguments);
            }, Module._free = function() {
              return (Module._free = Module.asm.free).apply(null, arguments);
            }, Module._ts_language_symbol_count = function() {
              return (Module._ts_language_symbol_count = Module.asm.ts_language_symbol_count).apply(null, arguments);
            }, Module._ts_language_version = function() {
              return (Module._ts_language_version = Module.asm.ts_language_version).apply(null, arguments);
            }, Module._ts_language_field_count = function() {
              return (Module._ts_language_field_count = Module.asm.ts_language_field_count).apply(null, arguments);
            }, Module._ts_language_symbol_name = function() {
              return (Module._ts_language_symbol_name = Module.asm.ts_language_symbol_name).apply(null, arguments);
            }, Module._ts_language_symbol_for_name = function() {
              return (Module._ts_language_symbol_for_name = Module.asm.ts_language_symbol_for_name).apply(null, arguments);
            }, Module._ts_language_symbol_type = function() {
              return (Module._ts_language_symbol_type = Module.asm.ts_language_symbol_type).apply(null, arguments);
            }, Module._ts_language_field_name_for_id = function() {
              return (Module._ts_language_field_name_for_id = Module.asm.ts_language_field_name_for_id).apply(null, arguments);
            }, Module._memcpy = function() {
              return (Module._memcpy = Module.asm.memcpy).apply(null, arguments);
            }, Module._ts_parser_delete = function() {
              return (Module._ts_parser_delete = Module.asm.ts_parser_delete).apply(null, arguments);
            }, Module._ts_parser_reset = function() {
              return (Module._ts_parser_reset = Module.asm.ts_parser_reset).apply(null, arguments);
            }, Module._ts_parser_set_language = function() {
              return (Module._ts_parser_set_language = Module.asm.ts_parser_set_language).apply(null, arguments);
            }, Module._ts_parser_timeout_micros = function() {
              return (Module._ts_parser_timeout_micros = Module.asm.ts_parser_timeout_micros).apply(null, arguments);
            }, Module._ts_parser_set_timeout_micros = function() {
              return (Module._ts_parser_set_timeout_micros = Module.asm.ts_parser_set_timeout_micros).apply(null, arguments);
            }, Module._memmove = function() {
              return (Module._memmove = Module.asm.memmove).apply(null, arguments);
            }, Module._memcmp = function() {
              return (Module._memcmp = Module.asm.memcmp).apply(null, arguments);
            }, Module._ts_query_new = function() {
              return (Module._ts_query_new = Module.asm.ts_query_new).apply(null, arguments);
            }, Module._ts_query_delete = function() {
              return (Module._ts_query_delete = Module.asm.ts_query_delete).apply(null, arguments);
            }, Module._iswspace = function() {
              return (Module._iswspace = Module.asm.iswspace).apply(null, arguments);
            }, Module._iswalnum = function() {
              return (Module._iswalnum = Module.asm.iswalnum).apply(null, arguments);
            }, Module._ts_query_pattern_count = function() {
              return (Module._ts_query_pattern_count = Module.asm.ts_query_pattern_count).apply(null, arguments);
            }, Module._ts_query_capture_count = function() {
              return (Module._ts_query_capture_count = Module.asm.ts_query_capture_count).apply(null, arguments);
            }, Module._ts_query_string_count = function() {
              return (Module._ts_query_string_count = Module.asm.ts_query_string_count).apply(null, arguments);
            }, Module._ts_query_capture_name_for_id = function() {
              return (Module._ts_query_capture_name_for_id = Module.asm.ts_query_capture_name_for_id).apply(null, arguments);
            }, Module._ts_query_string_value_for_id = function() {
              return (Module._ts_query_string_value_for_id = Module.asm.ts_query_string_value_for_id).apply(null, arguments);
            }, Module._ts_query_predicates_for_pattern = function() {
              return (Module._ts_query_predicates_for_pattern = Module.asm.ts_query_predicates_for_pattern).apply(null, arguments);
            }, Module._ts_tree_copy = function() {
              return (Module._ts_tree_copy = Module.asm.ts_tree_copy).apply(null, arguments);
            }, Module._ts_tree_delete = function() {
              return (Module._ts_tree_delete = Module.asm.ts_tree_delete).apply(null, arguments);
            }, Module._ts_init = function() {
              return (Module._ts_init = Module.asm.ts_init).apply(null, arguments);
            }, Module._ts_parser_new_wasm = function() {
              return (Module._ts_parser_new_wasm = Module.asm.ts_parser_new_wasm).apply(null, arguments);
            }, Module._ts_parser_enable_logger_wasm = function() {
              return (Module._ts_parser_enable_logger_wasm = Module.asm.ts_parser_enable_logger_wasm).apply(null, arguments);
            }, Module._ts_parser_parse_wasm = function() {
              return (Module._ts_parser_parse_wasm = Module.asm.ts_parser_parse_wasm).apply(null, arguments);
            }, Module._ts_language_type_is_named_wasm = function() {
              return (Module._ts_language_type_is_named_wasm = Module.asm.ts_language_type_is_named_wasm).apply(null, arguments);
            }, Module._ts_language_type_is_visible_wasm = function() {
              return (Module._ts_language_type_is_visible_wasm = Module.asm.ts_language_type_is_visible_wasm).apply(null, arguments);
            }, Module._ts_tree_root_node_wasm = function() {
              return (Module._ts_tree_root_node_wasm = Module.asm.ts_tree_root_node_wasm).apply(null, arguments);
            }, Module._ts_tree_edit_wasm = function() {
              return (Module._ts_tree_edit_wasm = Module.asm.ts_tree_edit_wasm).apply(null, arguments);
            }, Module._ts_tree_get_changed_ranges_wasm = function() {
              return (Module._ts_tree_get_changed_ranges_wasm = Module.asm.ts_tree_get_changed_ranges_wasm).apply(null, arguments);
            }, Module._ts_tree_cursor_new_wasm = function() {
              return (Module._ts_tree_cursor_new_wasm = Module.asm.ts_tree_cursor_new_wasm).apply(null, arguments);
            }, Module._ts_tree_cursor_delete_wasm = function() {
              return (Module._ts_tree_cursor_delete_wasm = Module.asm.ts_tree_cursor_delete_wasm).apply(null, arguments);
            }, Module._ts_tree_cursor_reset_wasm = function() {
              return (Module._ts_tree_cursor_reset_wasm = Module.asm.ts_tree_cursor_reset_wasm).apply(null, arguments);
            }, Module._ts_tree_cursor_goto_first_child_wasm = function() {
              return (Module._ts_tree_cursor_goto_first_child_wasm = Module.asm.ts_tree_cursor_goto_first_child_wasm).apply(null, arguments);
            }, Module._ts_tree_cursor_goto_next_sibling_wasm = function() {
              return (Module._ts_tree_cursor_goto_next_sibling_wasm = Module.asm.ts_tree_cursor_goto_next_sibling_wasm).apply(null, arguments);
            }, Module._ts_tree_cursor_goto_parent_wasm = function() {
              return (Module._ts_tree_cursor_goto_parent_wasm = Module.asm.ts_tree_cursor_goto_parent_wasm).apply(null, arguments);
            }, Module._ts_tree_cursor_current_node_type_id_wasm = function() {
              return (Module._ts_tree_cursor_current_node_type_id_wasm = Module.asm.ts_tree_cursor_current_node_type_id_wasm).apply(null, arguments);
            }, Module._ts_tree_cursor_current_node_is_named_wasm = function() {
              return (Module._ts_tree_cursor_current_node_is_named_wasm = Module.asm.ts_tree_cursor_current_node_is_named_wasm).apply(null, arguments);
            }, Module._ts_tree_cursor_current_node_is_missing_wasm = function() {
              return (Module._ts_tree_cursor_current_node_is_missing_wasm = Module.asm.ts_tree_cursor_current_node_is_missing_wasm).apply(null, arguments);
            }, Module._ts_tree_cursor_current_node_id_wasm = function() {
              return (Module._ts_tree_cursor_current_node_id_wasm = Module.asm.ts_tree_cursor_current_node_id_wasm).apply(null, arguments);
            }, Module._ts_tree_cursor_start_position_wasm = function() {
              return (Module._ts_tree_cursor_start_position_wasm = Module.asm.ts_tree_cursor_start_position_wasm).apply(null, arguments);
            }, Module._ts_tree_cursor_end_position_wasm = function() {
              return (Module._ts_tree_cursor_end_position_wasm = Module.asm.ts_tree_cursor_end_position_wasm).apply(null, arguments);
            }, Module._ts_tree_cursor_start_index_wasm = function() {
              return (Module._ts_tree_cursor_start_index_wasm = Module.asm.ts_tree_cursor_start_index_wasm).apply(null, arguments);
            }, Module._ts_tree_cursor_end_index_wasm = function() {
              return (Module._ts_tree_cursor_end_index_wasm = Module.asm.ts_tree_cursor_end_index_wasm).apply(null, arguments);
            }, Module._ts_tree_cursor_current_field_id_wasm = function() {
              return (Module._ts_tree_cursor_current_field_id_wasm = Module.asm.ts_tree_cursor_current_field_id_wasm).apply(null, arguments);
            }, Module._ts_tree_cursor_current_node_wasm = function() {
              return (Module._ts_tree_cursor_current_node_wasm = Module.asm.ts_tree_cursor_current_node_wasm).apply(null, arguments);
            }, Module._ts_node_symbol_wasm = function() {
              return (Module._ts_node_symbol_wasm = Module.asm.ts_node_symbol_wasm).apply(null, arguments);
            }, Module._ts_node_child_count_wasm = function() {
              return (Module._ts_node_child_count_wasm = Module.asm.ts_node_child_count_wasm).apply(null, arguments);
            }, Module._ts_node_named_child_count_wasm = function() {
              return (Module._ts_node_named_child_count_wasm = Module.asm.ts_node_named_child_count_wasm).apply(null, arguments);
            }, Module._ts_node_child_wasm = function() {
              return (Module._ts_node_child_wasm = Module.asm.ts_node_child_wasm).apply(null, arguments);
            }, Module._ts_node_named_child_wasm = function() {
              return (Module._ts_node_named_child_wasm = Module.asm.ts_node_named_child_wasm).apply(null, arguments);
            }, Module._ts_node_child_by_field_id_wasm = function() {
              return (Module._ts_node_child_by_field_id_wasm = Module.asm.ts_node_child_by_field_id_wasm).apply(null, arguments);
            }, Module._ts_node_next_sibling_wasm = function() {
              return (Module._ts_node_next_sibling_wasm = Module.asm.ts_node_next_sibling_wasm).apply(null, arguments);
            }, Module._ts_node_prev_sibling_wasm = function() {
              return (Module._ts_node_prev_sibling_wasm = Module.asm.ts_node_prev_sibling_wasm).apply(null, arguments);
            }, Module._ts_node_next_named_sibling_wasm = function() {
              return (Module._ts_node_next_named_sibling_wasm = Module.asm.ts_node_next_named_sibling_wasm).apply(null, arguments);
            }, Module._ts_node_prev_named_sibling_wasm = function() {
              return (Module._ts_node_prev_named_sibling_wasm = Module.asm.ts_node_prev_named_sibling_wasm).apply(null, arguments);
            }, Module._ts_node_parent_wasm = function() {
              return (Module._ts_node_parent_wasm = Module.asm.ts_node_parent_wasm).apply(null, arguments);
            }, Module._ts_node_descendant_for_index_wasm = function() {
              return (Module._ts_node_descendant_for_index_wasm = Module.asm.ts_node_descendant_for_index_wasm).apply(null, arguments);
            }, Module._ts_node_named_descendant_for_index_wasm = function() {
              return (Module._ts_node_named_descendant_for_index_wasm = Module.asm.ts_node_named_descendant_for_index_wasm).apply(null, arguments);
            }, Module._ts_node_descendant_for_position_wasm = function() {
              return (Module._ts_node_descendant_for_position_wasm = Module.asm.ts_node_descendant_for_position_wasm).apply(null, arguments);
            }, Module._ts_node_named_descendant_for_position_wasm = function() {
              return (Module._ts_node_named_descendant_for_position_wasm = Module.asm.ts_node_named_descendant_for_position_wasm).apply(null, arguments);
            }, Module._ts_node_start_point_wasm = function() {
              return (Module._ts_node_start_point_wasm = Module.asm.ts_node_start_point_wasm).apply(null, arguments);
            }, Module._ts_node_end_point_wasm = function() {
              return (Module._ts_node_end_point_wasm = Module.asm.ts_node_end_point_wasm).apply(null, arguments);
            }, Module._ts_node_start_index_wasm = function() {
              return (Module._ts_node_start_index_wasm = Module.asm.ts_node_start_index_wasm).apply(null, arguments);
            }, Module._ts_node_end_index_wasm = function() {
              return (Module._ts_node_end_index_wasm = Module.asm.ts_node_end_index_wasm).apply(null, arguments);
            }, Module._ts_node_to_string_wasm = function() {
              return (Module._ts_node_to_string_wasm = Module.asm.ts_node_to_string_wasm).apply(null, arguments);
            }, Module._ts_node_children_wasm = function() {
              return (Module._ts_node_children_wasm = Module.asm.ts_node_children_wasm).apply(null, arguments);
            }, Module._ts_node_named_children_wasm = function() {
              return (Module._ts_node_named_children_wasm = Module.asm.ts_node_named_children_wasm).apply(null, arguments);
            }, Module._ts_node_descendants_of_type_wasm = function() {
              return (Module._ts_node_descendants_of_type_wasm = Module.asm.ts_node_descendants_of_type_wasm).apply(null, arguments);
            }, Module._ts_node_is_named_wasm = function() {
              return (Module._ts_node_is_named_wasm = Module.asm.ts_node_is_named_wasm).apply(null, arguments);
            }, Module._ts_node_has_changes_wasm = function() {
              return (Module._ts_node_has_changes_wasm = Module.asm.ts_node_has_changes_wasm).apply(null, arguments);
            }, Module._ts_node_has_error_wasm = function() {
              return (Module._ts_node_has_error_wasm = Module.asm.ts_node_has_error_wasm).apply(null, arguments);
            }, Module._ts_node_is_missing_wasm = function() {
              return (Module._ts_node_is_missing_wasm = Module.asm.ts_node_is_missing_wasm).apply(null, arguments);
            }, Module._ts_query_matches_wasm = function() {
              return (Module._ts_query_matches_wasm = Module.asm.ts_query_matches_wasm).apply(null, arguments);
            }, Module._ts_query_captures_wasm = function() {
              return (Module._ts_query_captures_wasm = Module.asm.ts_query_captures_wasm).apply(null, arguments);
            }, Module._iswdigit = function() {
              return (Module._iswdigit = Module.asm.iswdigit).apply(null, arguments);
            }, Module._iswalpha = function() {
              return (Module._iswalpha = Module.asm.iswalpha).apply(null, arguments);
            }, Module._iswlower = function() {
              return (Module._iswlower = Module.asm.iswlower).apply(null, arguments);
            }, Module._towupper = function() {
              return (Module._towupper = Module.asm.towupper).apply(null, arguments);
            }, Module.___errno_location = function() {
              return (Ue = Module.___errno_location = Module.asm.__errno_location).apply(null, arguments);
            }), He = (Module._memchr = function() {
              return (Module._memchr = Module.asm.memchr).apply(null, arguments);
            }, Module._strlen = function() {
              return (Module._strlen = Module.asm.strlen).apply(null, arguments);
            }, Module.stackSave = function() {
              return (He = Module.stackSave = Module.asm.stackSave).apply(null, arguments);
            }), Ge = Module.stackRestore = function() {
              return (Ge = Module.stackRestore = Module.asm.stackRestore).apply(null, arguments);
            }, Be = Module.stackAlloc = function() {
              return (Be = Module.stackAlloc = Module.asm.stackAlloc).apply(null, arguments);
            }, Ke = Module._setThrew = function() {
              return (Ke = Module._setThrew = Module.asm.setThrew).apply(null, arguments);
            };
            Module.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEED2Ev = function() {
              return (Module.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEED2Ev = Module.asm._ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEED2Ev).apply(null, arguments);
            }, Module.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9__grow_byEmmmmmm = function() {
              return (Module.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9__grow_byEmmmmmm = Module.asm._ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9__grow_byEmmmmmm).apply(null, arguments);
            }, Module.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6__initEPKcm = function() {
              return (Module.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6__initEPKcm = Module.asm._ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6__initEPKcm).apply(null, arguments);
            }, Module.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE7reserveEm = function() {
              return (Module.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE7reserveEm = Module.asm._ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE7reserveEm).apply(null, arguments);
            }, Module.__ZNKSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE4copyEPcmm = function() {
              return (Module.__ZNKSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE4copyEPcmm = Module.asm._ZNKSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE4copyEPcmm).apply(null, arguments);
            }, Module.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9push_backEc = function() {
              return (Module.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9push_backEc = Module.asm._ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9push_backEc).apply(null, arguments);
            }, Module.__ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEED2Ev = function() {
              return (Module.__ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEED2Ev = Module.asm._ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEED2Ev).apply(null, arguments);
            }, Module.__ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE9push_backEw = function() {
              return (Module.__ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE9push_backEw = Module.asm._ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE9push_backEw).apply(null, arguments);
            }, Module.__Znwm = function() {
              return (Module.__Znwm = Module.asm._Znwm).apply(null, arguments);
            }, Module.__ZdlPv = function() {
              return (Module.__ZdlPv = Module.asm._ZdlPv).apply(null, arguments);
            }, Module.dynCall_jiji = function() {
              return (Module.dynCall_jiji = Module.asm.dynCall_jiji).apply(null, arguments);
            }, Module._orig$ts_parser_timeout_micros = function() {
              return (Module._orig$ts_parser_timeout_micros = Module.asm.orig$ts_parser_timeout_micros).apply(null, arguments);
            }, Module._orig$ts_parser_set_timeout_micros = function() {
              return (Module._orig$ts_parser_set_timeout_micros = Module.asm.orig$ts_parser_set_timeout_micros).apply(null, arguments);
            };
            function Ve(e3) {
              this.name = "ExitStatus", this.message = "Program terminated with exit(" + e3 + ")", this.status = e3;
            }
            Module.allocate = function(e3, t2) {
              var r3;
              return r3 = t2 == F ? Be(e3.length) : ze(e3.length), e3.subarray || e3.slice ? T.set(e3, r3) : T.set(new Uint8Array(e3), r3), r3;
            };
            re = function e3() {
              Ze || Qe(), Ze || (re = e3);
            };
            var Xe = false;
            function Qe(e3) {
              function t2() {
                Ze || (Ze = true, Module.calledRun = true, P || (Y = true, pe(X), pe(Q), Module.onRuntimeInitialized && Module.onRuntimeInitialized(), Ye && function(e4) {
                  var t3 = Module._main;
                  if (t3) {
                    var r3 = (e4 = e4 || []).length + 1, n2 = Be(4 * (r3 + 1));
                    W[n2 >> 2] = H(a);
                    for (var o2 = 1; o2 < r3; o2++)
                      W[(n2 >> 2) + o2] = H(e4[o2 - 1]);
                    W[(n2 >> 2) + r3] = 0;
                    try {
                      Je(t3(r3, n2), true);
                    } catch (e5) {
                      if (e5 instanceof Ve)
                        return;
                      if (e5 == "unwind")
                        return;
                      var s2 = e5;
                      e5 && typeof e5 == "object" && e5.stack && (s2 = [e5, e5.stack]), g("exception thrown: " + s2), i(1, e5);
                    } finally {
                    }
                  }
                }(e3), function() {
                  if (Module.postRun)
                    for (typeof Module.postRun == "function" && (Module.postRun = [Module.postRun]); Module.postRun.length; )
                      e4 = Module.postRun.shift(), J.unshift(e4);
                  var e4;
                  pe(J);
                }()));
              }
              e3 = e3 || _, ee > 0 || !Xe && (function() {
                if (S.length) {
                  if (!m)
                    return ne(), void S.reduce(function(e4, t3) {
                      return e4.then(function() {
                        return Ne(t3, { loadAsync: true, global: true, nodelete: true, allowUndefined: true });
                      });
                    }, Promise.resolve()).then(function() {
                      oe(), Pe();
                    });
                  S.forEach(function(e4) {
                    Ne(e4, { global: true, nodelete: true, allowUndefined: true });
                  }), Pe();
                } else
                  Pe();
              }(), Xe = true, ee > 0) || (!function() {
                if (Module.preRun)
                  for (typeof Module.preRun == "function" && (Module.preRun = [Module.preRun]); Module.preRun.length; )
                    e4 = Module.preRun.shift(), V.unshift(e4);
                var e4;
                pe(V);
              }(), ee > 0 || (Module.setStatus ? (Module.setStatus("Running..."), setTimeout(function() {
                setTimeout(function() {
                  Module.setStatus("");
                }, 1), t2();
              }, 1)) : t2()));
            }
            function Je(e3, t2) {
              e3, t2 && we() && e3 === 0 || (we() || (true, Module.onExit && Module.onExit(e3), P = true), i(e3, new Ve(e3)));
            }
            if (Module.run = Qe, Module.preInit)
              for (typeof Module.preInit == "function" && (Module.preInit = [Module.preInit]); Module.preInit.length > 0; )
                Module.preInit.pop()();
            var Ye = true;
            Module.noInitialRun && (Ye = false), Qe();
            const et = Module, tt = {}, rt = 4, nt = 5 * rt, ot = 2 * rt, st = 2 * rt + 2 * ot, _t = { row: 0, column: 0 }, at = /[\w-.]*/g, it = 1, ut = 2, lt = /^_?tree_sitter_\w+/;
            var dt, ct, mt, ft, pt;
            class ParserImpl {
              static init() {
                mt = et._ts_init(), dt = N(mt, "i32"), ct = N(mt + rt, "i32");
              }
              initialize() {
                et._ts_parser_new_wasm(), this[0] = N(mt, "i32"), this[1] = N(mt + rt, "i32");
              }
              delete() {
                et._ts_parser_delete(this[0]), et._free(this[1]), this[0] = 0, this[1] = 0;
              }
              setLanguage(e3) {
                let t2;
                if (e3) {
                  if (e3.constructor !== Language)
                    throw new Error("Argument must be a Language");
                  {
                    t2 = e3[0];
                    const r3 = et._ts_language_version(t2);
                    if (r3 < ct || dt < r3)
                      throw new Error(`Incompatible language version ${r3}. Compatibility range ${ct} through ${dt}.`);
                  }
                } else
                  t2 = 0, e3 = null;
                return this.language = e3, et._ts_parser_set_language(this[0], t2), this;
              }
              getLanguage() {
                return this.language;
              }
              parse(e3, t2, r3) {
                if (typeof e3 == "string")
                  ft = (t3, r4, n3) => e3.slice(t3, n3);
                else {
                  if (typeof e3 != "function")
                    throw new Error("Argument must be a string or a function");
                  ft = e3;
                }
                this.logCallback ? (pt = this.logCallback, et._ts_parser_enable_logger_wasm(this[0], 1)) : (pt = null, et._ts_parser_enable_logger_wasm(this[0], 0));
                let n2 = 0, o2 = 0;
                if (r3 && r3.includedRanges) {
                  n2 = r3.includedRanges.length;
                  let e4 = o2 = et._calloc(n2, st);
                  for (let t3 = 0; t3 < n2; t3++)
                    At(e4, r3.includedRanges[t3]), e4 += st;
                }
                const s2 = et._ts_parser_parse_wasm(this[0], this[1], t2 ? t2[0] : 0, o2, n2);
                if (!s2)
                  throw ft = null, pt = null, new Error("Parsing failed");
                const _2 = new Tree(tt, s2, this.language, ft);
                return ft = null, pt = null, _2;
              }
              reset() {
                et._ts_parser_reset(this[0]);
              }
              setTimeoutMicros(e3) {
                et._ts_parser_set_timeout_micros(this[0], e3);
              }
              getTimeoutMicros() {
                return et._ts_parser_timeout_micros(this[0]);
              }
              setLogger(e3) {
                if (e3) {
                  if (typeof e3 != "function")
                    throw new Error("Logger callback must be a function");
                } else
                  e3 = null;
                return this.logCallback = e3, this;
              }
              getLogger() {
                return this.logCallback;
              }
            }
            class Tree {
              constructor(e3, t2, r3, n2) {
                wt(e3), this[0] = t2, this.language = r3, this.textCallback = n2;
              }
              copy() {
                const e3 = et._ts_tree_copy(this[0]);
                return new Tree(tt, e3, this.language, this.textCallback);
              }
              delete() {
                et._ts_tree_delete(this[0]), this[0] = 0;
              }
              edit(e3) {
                !function(e4) {
                  let t2 = mt;
                  St(t2, e4.startPosition), St(t2 += ot, e4.oldEndPosition), St(t2 += ot, e4.newEndPosition), x(t2 += ot, e4.startIndex, "i32"), x(t2 += rt, e4.oldEndIndex, "i32"), x(t2 += rt, e4.newEndIndex, "i32"), t2 += rt;
                }(e3), et._ts_tree_edit_wasm(this[0]);
              }
              get rootNode() {
                return et._ts_tree_root_node_wasm(this[0]), bt(this);
              }
              getLanguage() {
                return this.language;
              }
              walk() {
                return this.rootNode.walk();
              }
              getChangedRanges(e3) {
                if (e3.constructor !== Tree)
                  throw new TypeError("Argument must be a Tree");
                et._ts_tree_get_changed_ranges_wasm(this[0], e3[0]);
                const t2 = N(mt, "i32"), r3 = N(mt + rt, "i32"), n2 = new Array(t2);
                if (t2 > 0) {
                  let e4 = r3;
                  for (let r4 = 0; r4 < t2; r4++)
                    n2[r4] = xt(e4), e4 += st;
                  et._free(r3);
                }
                return n2;
              }
            }
            class Node {
              constructor(e3, t2) {
                wt(e3), this.tree = t2;
              }
              get typeId() {
                return yt(this), et._ts_node_symbol_wasm(this.tree[0]);
              }
              get type() {
                return this.tree.language.types[this.typeId] || "ERROR";
              }
              get endPosition() {
                return yt(this), et._ts_node_end_point_wasm(this.tree[0]), It(mt);
              }
              get endIndex() {
                return yt(this), et._ts_node_end_index_wasm(this.tree[0]);
              }
              get text() {
                return ht(this.tree, this.startIndex, this.endIndex);
              }
              isNamed() {
                return yt(this), et._ts_node_is_named_wasm(this.tree[0]) === 1;
              }
              hasError() {
                return yt(this), et._ts_node_has_error_wasm(this.tree[0]) === 1;
              }
              hasChanges() {
                return yt(this), et._ts_node_has_changes_wasm(this.tree[0]) === 1;
              }
              isMissing() {
                return yt(this), et._ts_node_is_missing_wasm(this.tree[0]) === 1;
              }
              equals(e3) {
                return this.id === e3.id;
              }
              child(e3) {
                return yt(this), et._ts_node_child_wasm(this.tree[0], e3), bt(this.tree);
              }
              namedChild(e3) {
                return yt(this), et._ts_node_named_child_wasm(this.tree[0], e3), bt(this.tree);
              }
              childForFieldId(e3) {
                return yt(this), et._ts_node_child_by_field_id_wasm(this.tree[0], e3), bt(this.tree);
              }
              childForFieldName(e3) {
                const t2 = this.tree.language.fields.indexOf(e3);
                if (t2 !== -1)
                  return this.childForFieldId(t2);
              }
              get childCount() {
                return yt(this), et._ts_node_child_count_wasm(this.tree[0]);
              }
              get namedChildCount() {
                return yt(this), et._ts_node_named_child_count_wasm(this.tree[0]);
              }
              get firstChild() {
                return this.child(0);
              }
              get firstNamedChild() {
                return this.namedChild(0);
              }
              get lastChild() {
                return this.child(this.childCount - 1);
              }
              get lastNamedChild() {
                return this.namedChild(this.namedChildCount - 1);
              }
              get children() {
                if (!this._children) {
                  yt(this), et._ts_node_children_wasm(this.tree[0]);
                  const e3 = N(mt, "i32"), t2 = N(mt + rt, "i32");
                  if (this._children = new Array(e3), e3 > 0) {
                    let r3 = t2;
                    for (let t3 = 0; t3 < e3; t3++)
                      this._children[t3] = bt(this.tree, r3), r3 += nt;
                    et._free(t2);
                  }
                }
                return this._children;
              }
              get namedChildren() {
                if (!this._namedChildren) {
                  yt(this), et._ts_node_named_children_wasm(this.tree[0]);
                  const e3 = N(mt, "i32"), t2 = N(mt + rt, "i32");
                  if (this._namedChildren = new Array(e3), e3 > 0) {
                    let r3 = t2;
                    for (let t3 = 0; t3 < e3; t3++)
                      this._namedChildren[t3] = bt(this.tree, r3), r3 += nt;
                    et._free(t2);
                  }
                }
                return this._namedChildren;
              }
              descendantsOfType(e3, t2, r3) {
                Array.isArray(e3) || (e3 = [e3]), t2 || (t2 = _t), r3 || (r3 = _t);
                const n2 = [], o2 = this.tree.language.types;
                for (let t3 = 0, r4 = o2.length; t3 < r4; t3++)
                  e3.includes(o2[t3]) && n2.push(t3);
                const s2 = et._malloc(rt * n2.length);
                for (let e4 = 0, t3 = n2.length; e4 < t3; e4++)
                  x(s2 + e4 * rt, n2[e4], "i32");
                yt(this), et._ts_node_descendants_of_type_wasm(this.tree[0], s2, n2.length, t2.row, t2.column, r3.row, r3.column);
                const _2 = N(mt, "i32"), a2 = N(mt + rt, "i32"), i2 = new Array(_2);
                if (_2 > 0) {
                  let e4 = a2;
                  for (let t3 = 0; t3 < _2; t3++)
                    i2[t3] = bt(this.tree, e4), e4 += nt;
                }
                return et._free(a2), et._free(s2), i2;
              }
              get nextSibling() {
                return yt(this), et._ts_node_next_sibling_wasm(this.tree[0]), bt(this.tree);
              }
              get previousSibling() {
                return yt(this), et._ts_node_prev_sibling_wasm(this.tree[0]), bt(this.tree);
              }
              get nextNamedSibling() {
                return yt(this), et._ts_node_next_named_sibling_wasm(this.tree[0]), bt(this.tree);
              }
              get previousNamedSibling() {
                return yt(this), et._ts_node_prev_named_sibling_wasm(this.tree[0]), bt(this.tree);
              }
              get parent() {
                return yt(this), et._ts_node_parent_wasm(this.tree[0]), bt(this.tree);
              }
              descendantForIndex(e3, t2 = e3) {
                if (typeof e3 != "number" || typeof t2 != "number")
                  throw new Error("Arguments must be numbers");
                yt(this);
                let r3 = mt + nt;
                return x(r3, e3, "i32"), x(r3 + rt, t2, "i32"), et._ts_node_descendant_for_index_wasm(this.tree[0]), bt(this.tree);
              }
              namedDescendantForIndex(e3, t2 = e3) {
                if (typeof e3 != "number" || typeof t2 != "number")
                  throw new Error("Arguments must be numbers");
                yt(this);
                let r3 = mt + nt;
                return x(r3, e3, "i32"), x(r3 + rt, t2, "i32"), et._ts_node_named_descendant_for_index_wasm(this.tree[0]), bt(this.tree);
              }
              descendantForPosition(e3, t2 = e3) {
                if (!Mt(e3) || !Mt(t2))
                  throw new Error("Arguments must be {row, column} objects");
                yt(this);
                let r3 = mt + nt;
                return St(r3, e3), St(r3 + ot, t2), et._ts_node_descendant_for_position_wasm(this.tree[0]), bt(this.tree);
              }
              namedDescendantForPosition(e3, t2 = e3) {
                if (!Mt(e3) || !Mt(t2))
                  throw new Error("Arguments must be {row, column} objects");
                yt(this);
                let r3 = mt + nt;
                return St(r3, e3), St(r3 + ot, t2), et._ts_node_named_descendant_for_position_wasm(this.tree[0]), bt(this.tree);
              }
              walk() {
                return yt(this), et._ts_tree_cursor_new_wasm(this.tree[0]), new TreeCursor(tt, this.tree);
              }
              toString() {
                yt(this);
                const e3 = et._ts_node_to_string_wasm(this.tree[0]), t2 = function(e4) {
                  for (var t3 = ""; ; ) {
                    var r3 = T[e4++ >> 0];
                    if (!r3)
                      return t3;
                    t3 += String.fromCharCode(r3);
                  }
                }(e3);
                return et._free(e3), t2;
              }
            }
            class TreeCursor {
              constructor(e3, t2) {
                wt(e3), this.tree = t2, Et(this);
              }
              delete() {
                vt(this), et._ts_tree_cursor_delete_wasm(this.tree[0]), this[0] = this[1] = this[2] = 0;
              }
              reset(e3) {
                yt(e3), vt(this, mt + nt), et._ts_tree_cursor_reset_wasm(this.tree[0]), Et(this);
              }
              get nodeType() {
                return this.tree.language.types[this.nodeTypeId] || "ERROR";
              }
              get nodeTypeId() {
                return vt(this), et._ts_tree_cursor_current_node_type_id_wasm(this.tree[0]);
              }
              get nodeId() {
                return vt(this), et._ts_tree_cursor_current_node_id_wasm(this.tree[0]);
              }
              get nodeIsNamed() {
                return vt(this), et._ts_tree_cursor_current_node_is_named_wasm(this.tree[0]) === 1;
              }
              get nodeIsMissing() {
                return vt(this), et._ts_tree_cursor_current_node_is_missing_wasm(this.tree[0]) === 1;
              }
              get nodeText() {
                vt(this);
                const e3 = et._ts_tree_cursor_start_index_wasm(this.tree[0]), t2 = et._ts_tree_cursor_end_index_wasm(this.tree[0]);
                return ht(this.tree, e3, t2);
              }
              get startPosition() {
                return vt(this), et._ts_tree_cursor_start_position_wasm(this.tree[0]), It(mt);
              }
              get endPosition() {
                return vt(this), et._ts_tree_cursor_end_position_wasm(this.tree[0]), It(mt);
              }
              get startIndex() {
                return vt(this), et._ts_tree_cursor_start_index_wasm(this.tree[0]);
              }
              get endIndex() {
                return vt(this), et._ts_tree_cursor_end_index_wasm(this.tree[0]);
              }
              currentNode() {
                return vt(this), et._ts_tree_cursor_current_node_wasm(this.tree[0]), bt(this.tree);
              }
              currentFieldId() {
                return vt(this), et._ts_tree_cursor_current_field_id_wasm(this.tree[0]);
              }
              currentFieldName() {
                return this.tree.language.fields[this.currentFieldId()];
              }
              gotoFirstChild() {
                vt(this);
                const e3 = et._ts_tree_cursor_goto_first_child_wasm(this.tree[0]);
                return Et(this), e3 === 1;
              }
              gotoNextSibling() {
                vt(this);
                const e3 = et._ts_tree_cursor_goto_next_sibling_wasm(this.tree[0]);
                return Et(this), e3 === 1;
              }
              gotoParent() {
                vt(this);
                const e3 = et._ts_tree_cursor_goto_parent_wasm(this.tree[0]);
                return Et(this), e3 === 1;
              }
            }
            class Language {
              constructor(e3, t2) {
                wt(e3), this[0] = t2, this.types = new Array(et._ts_language_symbol_count(this[0]));
                for (let e4 = 0, t3 = this.types.length; e4 < t3; e4++)
                  et._ts_language_symbol_type(this[0], e4) < 2 && (this.types[e4] = Z(et._ts_language_symbol_name(this[0], e4)));
                this.fields = new Array(et._ts_language_field_count(this[0]) + 1);
                for (let e4 = 0, t3 = this.fields.length; e4 < t3; e4++) {
                  const t4 = et._ts_language_field_name_for_id(this[0], e4);
                  this.fields[e4] = t4 !== 0 ? Z(t4) : null;
                }
              }
              get version() {
                return et._ts_language_version(this[0]);
              }
              get fieldCount() {
                return this.fields.length - 1;
              }
              fieldIdForName(e3) {
                const t2 = this.fields.indexOf(e3);
                return t2 !== -1 ? t2 : null;
              }
              fieldNameForId(e3) {
                return this.fields[e3] || null;
              }
              idForNodeType(e3, t2) {
                const r3 = U(e3), n2 = et._malloc(r3 + 1);
                z(e3, n2, r3 + 1);
                const o2 = et._ts_language_symbol_for_name(this[0], n2, r3, t2);
                return et._free(n2), o2 || null;
              }
              get nodeTypeCount() {
                return et._ts_language_symbol_count(this[0]);
              }
              nodeTypeForId(e3) {
                const t2 = et._ts_language_symbol_name(this[0], e3);
                return t2 ? Z(t2) : null;
              }
              nodeTypeIsNamed(e3) {
                return !!et._ts_language_type_is_named_wasm(this[0], e3);
              }
              nodeTypeIsVisible(e3) {
                return !!et._ts_language_type_is_visible_wasm(this[0], e3);
              }
              query(e3) {
                const t2 = U(e3), r3 = et._malloc(t2 + 1);
                z(e3, r3, t2 + 1);
                const n2 = et._ts_query_new(this[0], r3, t2, mt, mt + rt);
                if (!n2) {
                  const t3 = N(mt + rt, "i32"), n3 = Z(r3, N(mt, "i32")).length, o3 = e3.substr(n3, 100).split("\n")[0];
                  let s3, _3 = o3.match(at)[0];
                  switch (t3) {
                    case 2:
                      s3 = new RangeError(`Bad node name '${_3}'`);
                      break;
                    case 3:
                      s3 = new RangeError(`Bad field name '${_3}'`);
                      break;
                    case 4:
                      s3 = new RangeError(`Bad capture name @${_3}`);
                      break;
                    case 5:
                      s3 = new TypeError(`Bad pattern structure at offset ${n3}: '${o3}'...`), _3 = "";
                      break;
                    default:
                      s3 = new SyntaxError(`Bad syntax at offset ${n3}: '${o3}'...`), _3 = "";
                  }
                  throw s3.index = n3, s3.length = _3.length, et._free(r3), s3;
                }
                const o2 = et._ts_query_string_count(n2), s2 = et._ts_query_capture_count(n2), _2 = et._ts_query_pattern_count(n2), a2 = new Array(s2), i2 = new Array(o2);
                for (let e4 = 0; e4 < s2; e4++) {
                  const t3 = et._ts_query_capture_name_for_id(n2, e4, mt), r4 = N(mt, "i32");
                  a2[e4] = Z(t3, r4);
                }
                for (let e4 = 0; e4 < o2; e4++) {
                  const t3 = et._ts_query_string_value_for_id(n2, e4, mt), r4 = N(mt, "i32");
                  i2[e4] = Z(t3, r4);
                }
                const u2 = new Array(_2), l2 = new Array(_2), d2 = new Array(_2), c2 = new Array(_2), m2 = new Array(_2);
                for (let e4 = 0; e4 < _2; e4++) {
                  const t3 = et._ts_query_predicates_for_pattern(n2, e4, mt), r4 = N(mt, "i32");
                  c2[e4] = [], m2[e4] = [];
                  const o3 = [];
                  let s3 = t3;
                  for (let t4 = 0; t4 < r4; t4++) {
                    const t5 = N(s3, "i32"), r5 = N(s3 += rt, "i32");
                    if (s3 += rt, t5 === it)
                      o3.push({ type: "capture", name: a2[r5] });
                    else if (t5 === ut)
                      o3.push({ type: "string", value: i2[r5] });
                    else if (o3.length > 0) {
                      if (o3[0].type !== "string")
                        throw new Error("Predicates must begin with a literal value");
                      const t6 = o3[0].value;
                      let r6 = true;
                      switch (t6) {
                        case "not-eq?":
                          r6 = false;
                        case "eq?":
                          if (o3.length !== 3)
                            throw new Error(`Wrong number of arguments to \`#eq?\` predicate. Expected 2, got ${o3.length - 1}`);
                          if (o3[1].type !== "capture")
                            throw new Error(`First argument of \`#eq?\` predicate must be a capture. Got "${o3[1].value}"`);
                          if (o3[2].type === "capture") {
                            const t7 = o3[1].name, n4 = o3[2].name;
                            m2[e4].push(function(e5) {
                              let o4, s5;
                              for (const r7 of e5)
                                r7.name === t7 && (o4 = r7.node), r7.name === n4 && (s5 = r7.node);
                              return o4 === void 0 || s5 === void 0 || o4.text === s5.text === r6;
                            });
                          } else {
                            const t7 = o3[1].name, n4 = o3[2].value;
                            m2[e4].push(function(e5) {
                              for (const o4 of e5)
                                if (o4.name === t7)
                                  return o4.node.text === n4 === r6;
                              return true;
                            });
                          }
                          break;
                        case "not-match?":
                          r6 = false;
                        case "match?":
                          if (o3.length !== 3)
                            throw new Error(`Wrong number of arguments to \`#match?\` predicate. Expected 2, got ${o3.length - 1}.`);
                          if (o3[1].type !== "capture")
                            throw new Error(`First argument of \`#match?\` predicate must be a capture. Got "${o3[1].value}".`);
                          if (o3[2].type !== "string")
                            throw new Error(`Second argument of \`#match?\` predicate must be a string. Got @${o3[2].value}.`);
                          const n3 = o3[1].name, s4 = new RegExp(o3[2].value);
                          m2[e4].push(function(e5) {
                            for (const t7 of e5)
                              if (t7.name === n3)
                                return s4.test(t7.node.text) === r6;
                            return true;
                          });
                          break;
                        case "set!":
                          if (o3.length < 2 || o3.length > 3)
                            throw new Error(`Wrong number of arguments to \`#set!\` predicate. Expected 1 or 2. Got ${o3.length - 1}.`);
                          if (o3.some((e5) => e5.type !== "string"))
                            throw new Error('Arguments to `#set!` predicate must be a strings.".');
                          u2[e4] || (u2[e4] = {}), u2[e4][o3[1].value] = o3[2] ? o3[2].value : null;
                          break;
                        case "is?":
                        case "is-not?":
                          if (o3.length < 2 || o3.length > 3)
                            throw new Error(`Wrong number of arguments to \`#${t6}\` predicate. Expected 1 or 2. Got ${o3.length - 1}.`);
                          if (o3.some((e5) => e5.type !== "string"))
                            throw new Error(`Arguments to \`#${t6}\` predicate must be a strings.".`);
                          const _3 = t6 === "is?" ? l2 : d2;
                          _3[e4] || (_3[e4] = {}), _3[e4][o3[1].value] = o3[2] ? o3[2].value : null;
                          break;
                        default:
                          c2[e4].push({ operator: t6, operands: o3.slice(1) });
                      }
                      o3.length = 0;
                    }
                  }
                  Object.freeze(u2[e4]), Object.freeze(l2[e4]), Object.freeze(d2[e4]);
                }
                return et._free(r3), new Query(tt, n2, a2, m2, c2, Object.freeze(u2), Object.freeze(l2), Object.freeze(d2));
              }
              static load(e3) {
                let t2;
                if (e3 instanceof Uint8Array)
                  t2 = Promise.resolve(e3);
                else {
                  const r4 = e3;
                  if (typeof process != "undefined" && process.versions && process.versions.node) {
                    const e4 = (init_fs(), __toCommonJS(fs_exports));
                    t2 = Promise.resolve(e4.readFileSync(r4));
                  } else
                    t2 = fetch(r4).then((e4) => e4.arrayBuffer().then((t3) => {
                      if (e4.ok)
                        return new Uint8Array(t3);
                      {
                        const r5 = new TextDecoder("utf-8").decode(t3);
                        throw new Error(`Language.load failed with status ${e4.status}.

${r5}`);
                      }
                    }));
                }
                const r3 = typeof loadSideModule == "function" ? loadSideModule : xe;
                return t2.then((e4) => r3(e4, { loadAsync: true })).then((e4) => {
                  const t3 = Object.keys(e4), r4 = t3.find((e5) => lt.test(e5) && !e5.includes("external_scanner_"));
                  r4 || console.log(`Couldn't find language function in WASM file. Symbols:
${JSON.stringify(t3, null, 2)}`);
                  const n2 = e4[r4]();
                  return new Language(tt, n2);
                });
              }
            }
            class Query {
              constructor(e3, t2, r3, n2, o2, s2, _2, a2) {
                wt(e3), this[0] = t2, this.captureNames = r3, this.textPredicates = n2, this.predicates = o2, this.setProperties = s2, this.assertedProperties = _2, this.refutedProperties = a2, this.exceededMatchLimit = false;
              }
              delete() {
                et._ts_query_delete(this[0]), this[0] = 0;
              }
              matches(e3, t2, r3, n2) {
                t2 || (t2 = _t), r3 || (r3 = _t), n2 || (n2 = {});
                let o2 = n2.matchLimit;
                if (o2 === void 0)
                  o2 = 0;
                else if (typeof o2 != "number")
                  throw new Error("Arguments must be numbers");
                yt(e3), et._ts_query_matches_wasm(this[0], e3.tree[0], t2.row, t2.column, r3.row, r3.column, o2);
                const s2 = N(mt, "i32"), _2 = N(mt + rt, "i32"), a2 = N(mt + 2 * rt, "i32"), i2 = new Array(s2);
                this.exceededMatchLimit = !!a2;
                let u2 = 0, l2 = _2;
                for (let t3 = 0; t3 < s2; t3++) {
                  const r4 = N(l2, "i32"), n3 = N(l2 += rt, "i32");
                  l2 += rt;
                  const o3 = new Array(n3);
                  if (l2 = gt(this, e3.tree, l2, o3), this.textPredicates[r4].every((e4) => e4(o3))) {
                    i2[u2++] = { pattern: r4, captures: o3 };
                    const e4 = this.setProperties[r4];
                    e4 && (i2[t3].setProperties = e4);
                    const n4 = this.assertedProperties[r4];
                    n4 && (i2[t3].assertedProperties = n4);
                    const s3 = this.refutedProperties[r4];
                    s3 && (i2[t3].refutedProperties = s3);
                  }
                }
                return i2.length = u2, et._free(_2), i2;
              }
              captures(e3, t2, r3, n2) {
                t2 || (t2 = _t), r3 || (r3 = _t), n2 || (n2 = {});
                let o2 = n2.matchLimit;
                if (o2 === void 0)
                  o2 = 0;
                else if (typeof o2 != "number")
                  throw new Error("Arguments must be numbers");
                yt(e3), et._ts_query_captures_wasm(this[0], e3.tree[0], t2.row, t2.column, r3.row, r3.column, o2);
                const s2 = N(mt, "i32"), _2 = N(mt + rt, "i32"), a2 = N(mt + 2 * rt, "i32"), i2 = [];
                this.exceededMatchLimit = !!a2;
                const u2 = [];
                let l2 = _2;
                for (let t3 = 0; t3 < s2; t3++) {
                  const t4 = N(l2, "i32"), r4 = N(l2 += rt, "i32"), n3 = N(l2 += rt, "i32");
                  if (l2 += rt, u2.length = r4, l2 = gt(this, e3.tree, l2, u2), this.textPredicates[t4].every((e4) => e4(u2))) {
                    const e4 = u2[n3], r5 = this.setProperties[t4];
                    r5 && (e4.setProperties = r5);
                    const o3 = this.assertedProperties[t4];
                    o3 && (e4.assertedProperties = o3);
                    const s3 = this.refutedProperties[t4];
                    s3 && (e4.refutedProperties = s3), i2.push(e4);
                  }
                }
                return et._free(_2), i2;
              }
              predicatesForPattern(e3) {
                return this.predicates[e3];
              }
              didExceedMatchLimit() {
                return this.exceededMatchLimit;
              }
            }
            function ht(e3, t2, r3) {
              const n2 = r3 - t2;
              let o2 = e3.textCallback(t2, null, r3);
              for (t2 += o2.length; t2 < r3; ) {
                const n3 = e3.textCallback(t2, null, r3);
                if (!(n3 && n3.length > 0))
                  break;
                t2 += n3.length, o2 += n3;
              }
              return t2 > r3 && (o2 = o2.slice(0, n2)), o2;
            }
            function gt(e3, t2, r3, n2) {
              for (let o2 = 0, s2 = n2.length; o2 < s2; o2++) {
                const s3 = N(r3, "i32"), _2 = bt(t2, r3 += rt);
                r3 += nt, n2[o2] = { name: e3.captureNames[s3], node: _2 };
              }
              return r3;
            }
            function wt(e3) {
              if (e3 !== tt)
                throw new Error("Illegal constructor");
            }
            function Mt(e3) {
              return e3 && typeof e3.row == "number" && typeof e3.column == "number";
            }
            function yt(e3) {
              let t2 = mt;
              x(t2, e3.id, "i32"), x(t2 += rt, e3.startIndex, "i32"), x(t2 += rt, e3.startPosition.row, "i32"), x(t2 += rt, e3.startPosition.column, "i32"), x(t2 += rt, e3[0], "i32");
            }
            function bt(e3, t2 = mt) {
              const r3 = N(t2, "i32");
              if (r3 === 0)
                return null;
              const n2 = N(t2 += rt, "i32"), o2 = N(t2 += rt, "i32"), s2 = N(t2 += rt, "i32"), _2 = N(t2 += rt, "i32"), a2 = new Node(tt, e3);
              return a2.id = r3, a2.startIndex = n2, a2.startPosition = { row: o2, column: s2 }, a2[0] = _2, a2;
            }
            function vt(e3, t2 = mt) {
              x(t2 + 0 * rt, e3[0], "i32"), x(t2 + 1 * rt, e3[1], "i32"), x(t2 + 2 * rt, e3[2], "i32");
            }
            function Et(e3) {
              e3[0] = N(mt + 0 * rt, "i32"), e3[1] = N(mt + 1 * rt, "i32"), e3[2] = N(mt + 2 * rt, "i32");
            }
            function St(e3, t2) {
              x(e3, t2.row, "i32"), x(e3 + rt, t2.column, "i32");
            }
            function It(e3) {
              return { row: N(e3, "i32"), column: N(e3 + rt, "i32") };
            }
            function At(e3, t2) {
              St(e3, t2.startPosition), St(e3 += ot, t2.endPosition), x(e3 += ot, t2.startIndex, "i32"), x(e3 += rt, t2.endIndex, "i32"), e3 += rt;
            }
            function xt(e3) {
              const t2 = {};
              return t2.startPosition = It(e3), e3 += ot, t2.endPosition = It(e3), e3 += ot, t2.startIndex = N(e3, "i32"), e3 += rt, t2.endIndex = N(e3, "i32"), t2;
            }
            for (const e3 of Object.getOwnPropertyNames(ParserImpl.prototype))
              Object.defineProperty(Parser2.prototype, e3, { value: ParserImpl.prototype[e3], enumerable: false, writable: false });
            Parser2.Language = Language, Module.onRuntimeInitialized = () => {
              ParserImpl.init(), e2();
            };
          }));
        }
      }
      return Parser2;
    }();
    typeof exports == "object" && (module.exports = TreeSitter);
  }
});

// node_modules/yamljs/lib/Pattern.js
var require_Pattern = __commonJS({
  "node_modules/yamljs/lib/Pattern.js"(exports, module) {
    var Pattern;
    Pattern = function() {
      Pattern2.prototype.regex = null;
      Pattern2.prototype.rawRegex = null;
      Pattern2.prototype.cleanedRegex = null;
      Pattern2.prototype.mapping = null;
      function Pattern2(rawRegex, modifiers) {
        var _char, capturingBracketNumber, cleanedRegex, i, len, mapping, name, part, subChar;
        if (modifiers == null) {
          modifiers = "";
        }
        cleanedRegex = "";
        len = rawRegex.length;
        mapping = null;
        capturingBracketNumber = 0;
        i = 0;
        while (i < len) {
          _char = rawRegex.charAt(i);
          if (_char === "\\") {
            cleanedRegex += rawRegex.slice(i, +(i + 1) + 1 || 9e9);
            i++;
          } else if (_char === "(") {
            if (i < len - 2) {
              part = rawRegex.slice(i, +(i + 2) + 1 || 9e9);
              if (part === "(?:") {
                i += 2;
                cleanedRegex += part;
              } else if (part === "(?<") {
                capturingBracketNumber++;
                i += 2;
                name = "";
                while (i + 1 < len) {
                  subChar = rawRegex.charAt(i + 1);
                  if (subChar === ">") {
                    cleanedRegex += "(";
                    i++;
                    if (name.length > 0) {
                      if (mapping == null) {
                        mapping = {};
                      }
                      mapping[name] = capturingBracketNumber;
                    }
                    break;
                  } else {
                    name += subChar;
                  }
                  i++;
                }
              } else {
                cleanedRegex += _char;
                capturingBracketNumber++;
              }
            } else {
              cleanedRegex += _char;
            }
          } else {
            cleanedRegex += _char;
          }
          i++;
        }
        this.rawRegex = rawRegex;
        this.cleanedRegex = cleanedRegex;
        this.regex = new RegExp(this.cleanedRegex, "g" + modifiers.replace("g", ""));
        this.mapping = mapping;
      }
      Pattern2.prototype.exec = function(str) {
        var index, matches, name, ref;
        this.regex.lastIndex = 0;
        matches = this.regex.exec(str);
        if (matches == null) {
          return null;
        }
        if (this.mapping != null) {
          ref = this.mapping;
          for (name in ref) {
            index = ref[name];
            matches[name] = matches[index];
          }
        }
        return matches;
      };
      Pattern2.prototype.test = function(str) {
        this.regex.lastIndex = 0;
        return this.regex.test(str);
      };
      Pattern2.prototype.replace = function(str, replacement) {
        this.regex.lastIndex = 0;
        return str.replace(this.regex, replacement);
      };
      Pattern2.prototype.replaceAll = function(str, replacement, limit) {
        var count;
        if (limit == null) {
          limit = 0;
        }
        this.regex.lastIndex = 0;
        count = 0;
        while (this.regex.test(str) && (limit === 0 || count < limit)) {
          this.regex.lastIndex = 0;
          str = str.replace(this.regex, replacement);
          count++;
        }
        return [str, count];
      };
      return Pattern2;
    }();
    module.exports = Pattern;
  }
});

// node_modules/yamljs/lib/Utils.js
var require_Utils = __commonJS({
  "node_modules/yamljs/lib/Utils.js"(exports, module) {
    var Pattern;
    var Utils;
    var hasProp = {}.hasOwnProperty;
    Pattern = require_Pattern();
    Utils = function() {
      function Utils2() {
      }
      Utils2.REGEX_LEFT_TRIM_BY_CHAR = {};
      Utils2.REGEX_RIGHT_TRIM_BY_CHAR = {};
      Utils2.REGEX_SPACES = /\s+/g;
      Utils2.REGEX_DIGITS = /^\d+$/;
      Utils2.REGEX_OCTAL = /[^0-7]/gi;
      Utils2.REGEX_HEXADECIMAL = /[^a-f0-9]/gi;
      Utils2.PATTERN_DATE = new Pattern("^(?<year>[0-9][0-9][0-9][0-9])-(?<month>[0-9][0-9]?)-(?<day>[0-9][0-9]?)(?:(?:[Tt]|[ 	]+)(?<hour>[0-9][0-9]?):(?<minute>[0-9][0-9]):(?<second>[0-9][0-9])(?:.(?<fraction>[0-9]*))?(?:[ 	]*(?<tz>Z|(?<tz_sign>[-+])(?<tz_hour>[0-9][0-9]?)(?::(?<tz_minute>[0-9][0-9]))?))?)?$", "i");
      Utils2.LOCAL_TIMEZONE_OFFSET = new Date().getTimezoneOffset() * 60 * 1e3;
      Utils2.trim = function(str, _char) {
        var regexLeft, regexRight;
        if (_char == null) {
          _char = "\\s";
        }
        regexLeft = this.REGEX_LEFT_TRIM_BY_CHAR[_char];
        if (regexLeft == null) {
          this.REGEX_LEFT_TRIM_BY_CHAR[_char] = regexLeft = new RegExp("^" + _char + _char + "*");
        }
        regexLeft.lastIndex = 0;
        regexRight = this.REGEX_RIGHT_TRIM_BY_CHAR[_char];
        if (regexRight == null) {
          this.REGEX_RIGHT_TRIM_BY_CHAR[_char] = regexRight = new RegExp(_char + "" + _char + "*$");
        }
        regexRight.lastIndex = 0;
        return str.replace(regexLeft, "").replace(regexRight, "");
      };
      Utils2.ltrim = function(str, _char) {
        var regexLeft;
        if (_char == null) {
          _char = "\\s";
        }
        regexLeft = this.REGEX_LEFT_TRIM_BY_CHAR[_char];
        if (regexLeft == null) {
          this.REGEX_LEFT_TRIM_BY_CHAR[_char] = regexLeft = new RegExp("^" + _char + _char + "*");
        }
        regexLeft.lastIndex = 0;
        return str.replace(regexLeft, "");
      };
      Utils2.rtrim = function(str, _char) {
        var regexRight;
        if (_char == null) {
          _char = "\\s";
        }
        regexRight = this.REGEX_RIGHT_TRIM_BY_CHAR[_char];
        if (regexRight == null) {
          this.REGEX_RIGHT_TRIM_BY_CHAR[_char] = regexRight = new RegExp(_char + "" + _char + "*$");
        }
        regexRight.lastIndex = 0;
        return str.replace(regexRight, "");
      };
      Utils2.isEmpty = function(value) {
        return !value || value === "" || value === "0" || value instanceof Array && value.length === 0 || this.isEmptyObject(value);
      };
      Utils2.isEmptyObject = function(value) {
        var k;
        return value instanceof Object && function() {
          var results;
          results = [];
          for (k in value) {
            if (!hasProp.call(value, k))
              continue;
            results.push(k);
          }
          return results;
        }().length === 0;
      };
      Utils2.subStrCount = function(string, subString, start, length) {
        var c, i, j, len, ref, sublen;
        c = 0;
        string = "" + string;
        subString = "" + subString;
        if (start != null) {
          string = string.slice(start);
        }
        if (length != null) {
          string = string.slice(0, length);
        }
        len = string.length;
        sublen = subString.length;
        for (i = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
          if (subString === string.slice(i, sublen)) {
            c++;
            i += sublen - 1;
          }
        }
        return c;
      };
      Utils2.isDigits = function(input) {
        this.REGEX_DIGITS.lastIndex = 0;
        return this.REGEX_DIGITS.test(input);
      };
      Utils2.octDec = function(input) {
        this.REGEX_OCTAL.lastIndex = 0;
        return parseInt((input + "").replace(this.REGEX_OCTAL, ""), 8);
      };
      Utils2.hexDec = function(input) {
        this.REGEX_HEXADECIMAL.lastIndex = 0;
        input = this.trim(input);
        if ((input + "").slice(0, 2) === "0x") {
          input = (input + "").slice(2);
        }
        return parseInt((input + "").replace(this.REGEX_HEXADECIMAL, ""), 16);
      };
      Utils2.utf8chr = function(c) {
        var ch;
        ch = String.fromCharCode;
        if (128 > (c %= 2097152)) {
          return ch(c);
        }
        if (2048 > c) {
          return ch(192 | c >> 6) + ch(128 | c & 63);
        }
        if (65536 > c) {
          return ch(224 | c >> 12) + ch(128 | c >> 6 & 63) + ch(128 | c & 63);
        }
        return ch(240 | c >> 18) + ch(128 | c >> 12 & 63) + ch(128 | c >> 6 & 63) + ch(128 | c & 63);
      };
      Utils2.parseBoolean = function(input, strict) {
        var lowerInput;
        if (strict == null) {
          strict = true;
        }
        if (typeof input === "string") {
          lowerInput = input.toLowerCase();
          if (!strict) {
            if (lowerInput === "no") {
              return false;
            }
          }
          if (lowerInput === "0") {
            return false;
          }
          if (lowerInput === "false") {
            return false;
          }
          if (lowerInput === "") {
            return false;
          }
          return true;
        }
        return !!input;
      };
      Utils2.isNumeric = function(input) {
        this.REGEX_SPACES.lastIndex = 0;
        return typeof input === "number" || typeof input === "string" && !isNaN(input) && input.replace(this.REGEX_SPACES, "") !== "";
      };
      Utils2.stringToDate = function(str) {
        var date, day, fraction, hour, info, minute, month, second, tz_hour, tz_minute, tz_offset, year;
        if (!(str != null ? str.length : void 0)) {
          return null;
        }
        info = this.PATTERN_DATE.exec(str);
        if (!info) {
          return null;
        }
        year = parseInt(info.year, 10);
        month = parseInt(info.month, 10) - 1;
        day = parseInt(info.day, 10);
        if (info.hour == null) {
          date = new Date(Date.UTC(year, month, day));
          return date;
        }
        hour = parseInt(info.hour, 10);
        minute = parseInt(info.minute, 10);
        second = parseInt(info.second, 10);
        if (info.fraction != null) {
          fraction = info.fraction.slice(0, 3);
          while (fraction.length < 3) {
            fraction += "0";
          }
          fraction = parseInt(fraction, 10);
        } else {
          fraction = 0;
        }
        if (info.tz != null) {
          tz_hour = parseInt(info.tz_hour, 10);
          if (info.tz_minute != null) {
            tz_minute = parseInt(info.tz_minute, 10);
          } else {
            tz_minute = 0;
          }
          tz_offset = (tz_hour * 60 + tz_minute) * 6e4;
          if (info.tz_sign === "-") {
            tz_offset *= -1;
          }
        }
        date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
        if (tz_offset) {
          date.setTime(date.getTime() - tz_offset);
        }
        return date;
      };
      Utils2.strRepeat = function(str, number) {
        var i, res;
        res = "";
        i = 0;
        while (i < number) {
          res += str;
          i++;
        }
        return res;
      };
      Utils2.getStringFromFile = function(path, callback) {
        var data, fs, j, len1, name, ref, req, xhr;
        if (callback == null) {
          callback = null;
        }
        xhr = null;
        if (typeof window !== "undefined" && window !== null) {
          if (window.XMLHttpRequest) {
            xhr = new XMLHttpRequest();
          } else if (window.ActiveXObject) {
            ref = ["Msxml2.XMLHTTP.6.0", "Msxml2.XMLHTTP.3.0", "Msxml2.XMLHTTP", "Microsoft.XMLHTTP"];
            for (j = 0, len1 = ref.length; j < len1; j++) {
              name = ref[j];
              try {
                xhr = new ActiveXObject(name);
              } catch (error) {
              }
            }
          }
        }
        if (xhr != null) {
          if (callback != null) {
            xhr.onreadystatechange = function() {
              if (xhr.readyState === 4) {
                if (xhr.status === 200 || xhr.status === 0) {
                  return callback(xhr.responseText);
                } else {
                  return callback(null);
                }
              }
            };
            xhr.open("GET", path, true);
            return xhr.send(null);
          } else {
            xhr.open("GET", path, false);
            xhr.send(null);
            if (xhr.status === 200 || xhr.status === 0) {
              return xhr.responseText;
            }
            return null;
          }
        } else {
          req = __require;
          fs = req("fs");
          if (callback != null) {
            return fs.readFile(path, function(err, data2) {
              if (err) {
                return callback(null);
              } else {
                return callback(String(data2));
              }
            });
          } else {
            data = fs.readFileSync(path);
            if (data != null) {
              return String(data);
            }
            return null;
          }
        }
      };
      return Utils2;
    }();
    module.exports = Utils;
  }
});

// node_modules/yamljs/lib/Unescaper.js
var require_Unescaper = __commonJS({
  "node_modules/yamljs/lib/Unescaper.js"(exports, module) {
    var Pattern;
    var Unescaper;
    var Utils;
    Utils = require_Utils();
    Pattern = require_Pattern();
    Unescaper = function() {
      function Unescaper2() {
      }
      Unescaper2.PATTERN_ESCAPED_CHARACTER = new Pattern('\\\\([0abt	nvfre "\\/\\\\N_LP]|x[0-9a-fA-F]{2}|u[0-9a-fA-F]{4}|U[0-9a-fA-F]{8})');
      Unescaper2.unescapeSingleQuotedString = function(value) {
        return value.replace(/\'\'/g, "'");
      };
      Unescaper2.unescapeDoubleQuotedString = function(value) {
        if (this._unescapeCallback == null) {
          this._unescapeCallback = function(_this) {
            return function(str) {
              return _this.unescapeCharacter(str);
            };
          }(this);
        }
        return this.PATTERN_ESCAPED_CHARACTER.replace(value, this._unescapeCallback);
      };
      Unescaper2.unescapeCharacter = function(value) {
        var ch;
        ch = String.fromCharCode;
        switch (value.charAt(1)) {
          case "0":
            return ch(0);
          case "a":
            return ch(7);
          case "b":
            return ch(8);
          case "t":
            return "	";
          case "	":
            return "	";
          case "n":
            return "\n";
          case "v":
            return ch(11);
          case "f":
            return ch(12);
          case "r":
            return ch(13);
          case "e":
            return ch(27);
          case " ":
            return " ";
          case '"':
            return '"';
          case "/":
            return "/";
          case "\\":
            return "\\";
          case "N":
            return ch(133);
          case "_":
            return ch(160);
          case "L":
            return ch(8232);
          case "P":
            return ch(8233);
          case "x":
            return Utils.utf8chr(Utils.hexDec(value.substr(2, 2)));
          case "u":
            return Utils.utf8chr(Utils.hexDec(value.substr(2, 4)));
          case "U":
            return Utils.utf8chr(Utils.hexDec(value.substr(2, 8)));
          default:
            return "";
        }
      };
      return Unescaper2;
    }();
    module.exports = Unescaper;
  }
});

// node_modules/yamljs/lib/Escaper.js
var require_Escaper = __commonJS({
  "node_modules/yamljs/lib/Escaper.js"(exports, module) {
    var Escaper;
    var Pattern;
    Pattern = require_Pattern();
    Escaper = function() {
      var ch;
      function Escaper2() {
      }
      Escaper2.LIST_ESCAPEES = ["\\", "\\\\", '\\"', '"', "\0", "", "", "", "", "", "", "\x07", "\b", "	", "\n", "\v", "\f", "\r", "", "", "", "", "", "", "", "", "", "", "", "", "", "\x1B", "", "", "", "", (ch = String.fromCharCode)(133), ch(160), ch(8232), ch(8233)];
      Escaper2.LIST_ESCAPED = ["\\\\", '\\"', '\\"', '\\"', "\\0", "\\x01", "\\x02", "\\x03", "\\x04", "\\x05", "\\x06", "\\a", "\\b", "\\t", "\\n", "\\v", "\\f", "\\r", "\\x0e", "\\x0f", "\\x10", "\\x11", "\\x12", "\\x13", "\\x14", "\\x15", "\\x16", "\\x17", "\\x18", "\\x19", "\\x1a", "\\e", "\\x1c", "\\x1d", "\\x1e", "\\x1f", "\\N", "\\_", "\\L", "\\P"];
      Escaper2.MAPPING_ESCAPEES_TO_ESCAPED = function() {
        var i, j, mapping, ref;
        mapping = {};
        for (i = j = 0, ref = Escaper2.LIST_ESCAPEES.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
          mapping[Escaper2.LIST_ESCAPEES[i]] = Escaper2.LIST_ESCAPED[i];
        }
        return mapping;
      }();
      Escaper2.PATTERN_CHARACTERS_TO_ESCAPE = new Pattern("[\\x00-\\x1f]|\xC2\x85|\xC2\xA0|\xE2\x80\xA8|\xE2\x80\xA9");
      Escaper2.PATTERN_MAPPING_ESCAPEES = new Pattern(Escaper2.LIST_ESCAPEES.join("|").split("\\").join("\\\\"));
      Escaper2.PATTERN_SINGLE_QUOTING = new Pattern("[\\s'\":{}[\\],&*#?]|^[-?|<>=!%@`]");
      Escaper2.requiresDoubleQuoting = function(value) {
        return this.PATTERN_CHARACTERS_TO_ESCAPE.test(value);
      };
      Escaper2.escapeWithDoubleQuotes = function(value) {
        var result;
        result = this.PATTERN_MAPPING_ESCAPEES.replace(value, function(_this) {
          return function(str) {
            return _this.MAPPING_ESCAPEES_TO_ESCAPED[str];
          };
        }(this));
        return '"' + result + '"';
      };
      Escaper2.requiresSingleQuoting = function(value) {
        return this.PATTERN_SINGLE_QUOTING.test(value);
      };
      Escaper2.escapeWithSingleQuotes = function(value) {
        return "'" + value.replace(/'/g, "''") + "'";
      };
      return Escaper2;
    }();
    module.exports = Escaper;
  }
});

// node_modules/yamljs/lib/Exception/ParseException.js
var require_ParseException = __commonJS({
  "node_modules/yamljs/lib/Exception/ParseException.js"(exports, module) {
    var ParseException;
    var extend = function(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key))
          child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
      child.__super__ = parent.prototype;
      return child;
    };
    var hasProp = {}.hasOwnProperty;
    ParseException = function(superClass) {
      extend(ParseException2, superClass);
      function ParseException2(message, parsedLine, snippet) {
        this.message = message;
        this.parsedLine = parsedLine;
        this.snippet = snippet;
      }
      ParseException2.prototype.toString = function() {
        if (this.parsedLine != null && this.snippet != null) {
          return "<ParseException> " + this.message + " (line " + this.parsedLine + ": '" + this.snippet + "')";
        } else {
          return "<ParseException> " + this.message;
        }
      };
      return ParseException2;
    }(Error);
    module.exports = ParseException;
  }
});

// node_modules/yamljs/lib/Exception/ParseMore.js
var require_ParseMore = __commonJS({
  "node_modules/yamljs/lib/Exception/ParseMore.js"(exports, module) {
    var ParseMore;
    var extend = function(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key))
          child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
      child.__super__ = parent.prototype;
      return child;
    };
    var hasProp = {}.hasOwnProperty;
    ParseMore = function(superClass) {
      extend(ParseMore2, superClass);
      function ParseMore2(message, parsedLine, snippet) {
        this.message = message;
        this.parsedLine = parsedLine;
        this.snippet = snippet;
      }
      ParseMore2.prototype.toString = function() {
        if (this.parsedLine != null && this.snippet != null) {
          return "<ParseMore> " + this.message + " (line " + this.parsedLine + ": '" + this.snippet + "')";
        } else {
          return "<ParseMore> " + this.message;
        }
      };
      return ParseMore2;
    }(Error);
    module.exports = ParseMore;
  }
});

// node_modules/yamljs/lib/Exception/DumpException.js
var require_DumpException = __commonJS({
  "node_modules/yamljs/lib/Exception/DumpException.js"(exports, module) {
    var DumpException;
    var extend = function(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key))
          child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
      child.__super__ = parent.prototype;
      return child;
    };
    var hasProp = {}.hasOwnProperty;
    DumpException = function(superClass) {
      extend(DumpException2, superClass);
      function DumpException2(message, parsedLine, snippet) {
        this.message = message;
        this.parsedLine = parsedLine;
        this.snippet = snippet;
      }
      DumpException2.prototype.toString = function() {
        if (this.parsedLine != null && this.snippet != null) {
          return "<DumpException> " + this.message + " (line " + this.parsedLine + ": '" + this.snippet + "')";
        } else {
          return "<DumpException> " + this.message;
        }
      };
      return DumpException2;
    }(Error);
    module.exports = DumpException;
  }
});

// node_modules/yamljs/lib/Inline.js
var require_Inline = __commonJS({
  "node_modules/yamljs/lib/Inline.js"(exports, module) {
    var DumpException;
    var Escaper;
    var Inline;
    var ParseException;
    var ParseMore;
    var Pattern;
    var Unescaper;
    var Utils;
    var indexOf = [].indexOf || function(item) {
      for (var i = 0, l = this.length; i < l; i++) {
        if (i in this && this[i] === item)
          return i;
      }
      return -1;
    };
    Pattern = require_Pattern();
    Unescaper = require_Unescaper();
    Escaper = require_Escaper();
    Utils = require_Utils();
    ParseException = require_ParseException();
    ParseMore = require_ParseMore();
    DumpException = require_DumpException();
    Inline = function() {
      function Inline2() {
      }
      Inline2.REGEX_QUOTED_STRING = `(?:"(?:[^"\\\\]*(?:\\\\.[^"\\\\]*)*)"|'(?:[^']*(?:''[^']*)*)')`;
      Inline2.PATTERN_TRAILING_COMMENTS = new Pattern("^\\s*#.*$");
      Inline2.PATTERN_QUOTED_SCALAR = new Pattern("^" + Inline2.REGEX_QUOTED_STRING);
      Inline2.PATTERN_THOUSAND_NUMERIC_SCALAR = new Pattern("^(-|\\+)?[0-9,]+(\\.[0-9]+)?$");
      Inline2.PATTERN_SCALAR_BY_DELIMITERS = {};
      Inline2.settings = {};
      Inline2.configure = function(exceptionOnInvalidType, objectDecoder) {
        if (exceptionOnInvalidType == null) {
          exceptionOnInvalidType = null;
        }
        if (objectDecoder == null) {
          objectDecoder = null;
        }
        this.settings.exceptionOnInvalidType = exceptionOnInvalidType;
        this.settings.objectDecoder = objectDecoder;
      };
      Inline2.parse = function(value, exceptionOnInvalidType, objectDecoder) {
        var context, result;
        if (exceptionOnInvalidType == null) {
          exceptionOnInvalidType = false;
        }
        if (objectDecoder == null) {
          objectDecoder = null;
        }
        this.settings.exceptionOnInvalidType = exceptionOnInvalidType;
        this.settings.objectDecoder = objectDecoder;
        if (value == null) {
          return "";
        }
        value = Utils.trim(value);
        if (value.length === 0) {
          return "";
        }
        context = {
          exceptionOnInvalidType,
          objectDecoder,
          i: 0
        };
        switch (value.charAt(0)) {
          case "[":
            result = this.parseSequence(value, context);
            ++context.i;
            break;
          case "{":
            result = this.parseMapping(value, context);
            ++context.i;
            break;
          default:
            result = this.parseScalar(value, null, ['"', "'"], context);
        }
        if (this.PATTERN_TRAILING_COMMENTS.replace(value.slice(context.i), "") !== "") {
          throw new ParseException('Unexpected characters near "' + value.slice(context.i) + '".');
        }
        return result;
      };
      Inline2.dump = function(value, exceptionOnInvalidType, objectEncoder) {
        var ref, result, type;
        if (exceptionOnInvalidType == null) {
          exceptionOnInvalidType = false;
        }
        if (objectEncoder == null) {
          objectEncoder = null;
        }
        if (value == null) {
          return "null";
        }
        type = typeof value;
        if (type === "object") {
          if (value instanceof Date) {
            return value.toISOString();
          } else if (objectEncoder != null) {
            result = objectEncoder(value);
            if (typeof result === "string" || result != null) {
              return result;
            }
          }
          return this.dumpObject(value);
        }
        if (type === "boolean") {
          return value ? "true" : "false";
        }
        if (Utils.isDigits(value)) {
          return type === "string" ? "'" + value + "'" : String(parseInt(value));
        }
        if (Utils.isNumeric(value)) {
          return type === "string" ? "'" + value + "'" : String(parseFloat(value));
        }
        if (type === "number") {
          return value === Infinity ? ".Inf" : value === -Infinity ? "-.Inf" : isNaN(value) ? ".NaN" : value;
        }
        if (Escaper.requiresDoubleQuoting(value)) {
          return Escaper.escapeWithDoubleQuotes(value);
        }
        if (Escaper.requiresSingleQuoting(value)) {
          return Escaper.escapeWithSingleQuotes(value);
        }
        if (value === "") {
          return '""';
        }
        if (Utils.PATTERN_DATE.test(value)) {
          return "'" + value + "'";
        }
        if ((ref = value.toLowerCase()) === "null" || ref === "~" || ref === "true" || ref === "false") {
          return "'" + value + "'";
        }
        return value;
      };
      Inline2.dumpObject = function(value, exceptionOnInvalidType, objectSupport) {
        var j, key, len1, output, val;
        if (objectSupport == null) {
          objectSupport = null;
        }
        if (value instanceof Array) {
          output = [];
          for (j = 0, len1 = value.length; j < len1; j++) {
            val = value[j];
            output.push(this.dump(val));
          }
          return "[" + output.join(", ") + "]";
        } else {
          output = [];
          for (key in value) {
            val = value[key];
            output.push(this.dump(key) + ": " + this.dump(val));
          }
          return "{" + output.join(", ") + "}";
        }
      };
      Inline2.parseScalar = function(scalar, delimiters, stringDelimiters, context, evaluate) {
        var i, joinedDelimiters, match, output, pattern, ref, ref1, strpos, tmp;
        if (delimiters == null) {
          delimiters = null;
        }
        if (stringDelimiters == null) {
          stringDelimiters = ['"', "'"];
        }
        if (context == null) {
          context = null;
        }
        if (evaluate == null) {
          evaluate = true;
        }
        if (context == null) {
          context = {
            exceptionOnInvalidType: this.settings.exceptionOnInvalidType,
            objectDecoder: this.settings.objectDecoder,
            i: 0
          };
        }
        i = context.i;
        if (ref = scalar.charAt(i), indexOf.call(stringDelimiters, ref) >= 0) {
          output = this.parseQuotedScalar(scalar, context);
          i = context.i;
          if (delimiters != null) {
            tmp = Utils.ltrim(scalar.slice(i), " ");
            if (!(ref1 = tmp.charAt(0), indexOf.call(delimiters, ref1) >= 0)) {
              throw new ParseException("Unexpected characters (" + scalar.slice(i) + ").");
            }
          }
        } else {
          if (!delimiters) {
            output = scalar.slice(i);
            i += output.length;
            strpos = output.indexOf(" #");
            if (strpos !== -1) {
              output = Utils.rtrim(output.slice(0, strpos));
            }
          } else {
            joinedDelimiters = delimiters.join("|");
            pattern = this.PATTERN_SCALAR_BY_DELIMITERS[joinedDelimiters];
            if (pattern == null) {
              pattern = new Pattern("^(.+?)(" + joinedDelimiters + ")");
              this.PATTERN_SCALAR_BY_DELIMITERS[joinedDelimiters] = pattern;
            }
            if (match = pattern.exec(scalar.slice(i))) {
              output = match[1];
              i += output.length;
            } else {
              throw new ParseException("Malformed inline YAML string (" + scalar + ").");
            }
          }
          if (evaluate) {
            output = this.evaluateScalar(output, context);
          }
        }
        context.i = i;
        return output;
      };
      Inline2.parseQuotedScalar = function(scalar, context) {
        var i, match, output;
        i = context.i;
        if (!(match = this.PATTERN_QUOTED_SCALAR.exec(scalar.slice(i)))) {
          throw new ParseMore("Malformed inline YAML string (" + scalar.slice(i) + ").");
        }
        output = match[0].substr(1, match[0].length - 2);
        if (scalar.charAt(i) === '"') {
          output = Unescaper.unescapeDoubleQuotedString(output);
        } else {
          output = Unescaper.unescapeSingleQuotedString(output);
        }
        i += match[0].length;
        context.i = i;
        return output;
      };
      Inline2.parseSequence = function(sequence, context) {
        var e, i, isQuoted, len, output, ref, value;
        output = [];
        len = sequence.length;
        i = context.i;
        i += 1;
        while (i < len) {
          context.i = i;
          switch (sequence.charAt(i)) {
            case "[":
              output.push(this.parseSequence(sequence, context));
              i = context.i;
              break;
            case "{":
              output.push(this.parseMapping(sequence, context));
              i = context.i;
              break;
            case "]":
              return output;
            case ",":
            case " ":
            case "\n":
              break;
            default:
              isQuoted = (ref = sequence.charAt(i)) === '"' || ref === "'";
              value = this.parseScalar(sequence, [",", "]"], ['"', "'"], context);
              i = context.i;
              if (!isQuoted && typeof value === "string" && (value.indexOf(": ") !== -1 || value.indexOf(":\n") !== -1)) {
                try {
                  value = this.parseMapping("{" + value + "}");
                } catch (error) {
                  e = error;
                }
              }
              output.push(value);
              --i;
          }
          ++i;
        }
        throw new ParseMore("Malformed inline YAML string " + sequence);
      };
      Inline2.parseMapping = function(mapping, context) {
        var done, i, key, len, output, shouldContinueWhileLoop, value;
        output = {};
        len = mapping.length;
        i = context.i;
        i += 1;
        shouldContinueWhileLoop = false;
        while (i < len) {
          context.i = i;
          switch (mapping.charAt(i)) {
            case " ":
            case ",":
            case "\n":
              ++i;
              context.i = i;
              shouldContinueWhileLoop = true;
              break;
            case "}":
              return output;
          }
          if (shouldContinueWhileLoop) {
            shouldContinueWhileLoop = false;
            continue;
          }
          key = this.parseScalar(mapping, [":", " ", "\n"], ['"', "'"], context, false);
          i = context.i;
          done = false;
          while (i < len) {
            context.i = i;
            switch (mapping.charAt(i)) {
              case "[":
                value = this.parseSequence(mapping, context);
                i = context.i;
                if (output[key] === void 0) {
                  output[key] = value;
                }
                done = true;
                break;
              case "{":
                value = this.parseMapping(mapping, context);
                i = context.i;
                if (output[key] === void 0) {
                  output[key] = value;
                }
                done = true;
                break;
              case ":":
              case " ":
              case "\n":
                break;
              default:
                value = this.parseScalar(mapping, [",", "}"], ['"', "'"], context);
                i = context.i;
                if (output[key] === void 0) {
                  output[key] = value;
                }
                done = true;
                --i;
            }
            ++i;
            if (done) {
              break;
            }
          }
        }
        throw new ParseMore("Malformed inline YAML string " + mapping);
      };
      Inline2.evaluateScalar = function(scalar, context) {
        var cast, date, exceptionOnInvalidType, firstChar, firstSpace, firstWord, objectDecoder, raw, scalarLower, subValue, trimmedScalar;
        scalar = Utils.trim(scalar);
        scalarLower = scalar.toLowerCase();
        switch (scalarLower) {
          case "null":
          case "":
          case "~":
            return null;
          case "true":
            return true;
          case "false":
            return false;
          case ".inf":
            return Infinity;
          case ".nan":
            return 0 / 0;
          case "-.inf":
            return Infinity;
          default:
            firstChar = scalarLower.charAt(0);
            switch (firstChar) {
              case "!":
                firstSpace = scalar.indexOf(" ");
                if (firstSpace === -1) {
                  firstWord = scalarLower;
                } else {
                  firstWord = scalarLower.slice(0, firstSpace);
                }
                switch (firstWord) {
                  case "!":
                    if (firstSpace !== -1) {
                      return parseInt(this.parseScalar(scalar.slice(2)));
                    }
                    return null;
                  case "!str":
                    return Utils.ltrim(scalar.slice(4));
                  case "!!str":
                    return Utils.ltrim(scalar.slice(5));
                  case "!!int":
                    return parseInt(this.parseScalar(scalar.slice(5)));
                  case "!!bool":
                    return Utils.parseBoolean(this.parseScalar(scalar.slice(6)), false);
                  case "!!float":
                    return parseFloat(this.parseScalar(scalar.slice(7)));
                  case "!!timestamp":
                    return Utils.stringToDate(Utils.ltrim(scalar.slice(11)));
                  default:
                    if (context == null) {
                      context = {
                        exceptionOnInvalidType: this.settings.exceptionOnInvalidType,
                        objectDecoder: this.settings.objectDecoder,
                        i: 0
                      };
                    }
                    objectDecoder = context.objectDecoder, exceptionOnInvalidType = context.exceptionOnInvalidType;
                    if (objectDecoder) {
                      trimmedScalar = Utils.rtrim(scalar);
                      firstSpace = trimmedScalar.indexOf(" ");
                      if (firstSpace === -1) {
                        return objectDecoder(trimmedScalar, null);
                      } else {
                        subValue = Utils.ltrim(trimmedScalar.slice(firstSpace + 1));
                        if (!(subValue.length > 0)) {
                          subValue = null;
                        }
                        return objectDecoder(trimmedScalar.slice(0, firstSpace), subValue);
                      }
                    }
                    if (exceptionOnInvalidType) {
                      throw new ParseException("Custom object support when parsing a YAML file has been disabled.");
                    }
                    return null;
                }
                break;
              case "0":
                if (scalar.slice(0, 2) === "0x") {
                  return Utils.hexDec(scalar);
                } else if (Utils.isDigits(scalar)) {
                  return Utils.octDec(scalar);
                } else if (Utils.isNumeric(scalar)) {
                  return parseFloat(scalar);
                } else {
                  return scalar;
                }
                break;
              case "+":
                if (Utils.isDigits(scalar)) {
                  raw = scalar;
                  cast = parseInt(raw);
                  if (raw === String(cast)) {
                    return cast;
                  } else {
                    return raw;
                  }
                } else if (Utils.isNumeric(scalar)) {
                  return parseFloat(scalar);
                } else if (this.PATTERN_THOUSAND_NUMERIC_SCALAR.test(scalar)) {
                  return parseFloat(scalar.replace(",", ""));
                }
                return scalar;
              case "-":
                if (Utils.isDigits(scalar.slice(1))) {
                  if (scalar.charAt(1) === "0") {
                    return -Utils.octDec(scalar.slice(1));
                  } else {
                    raw = scalar.slice(1);
                    cast = parseInt(raw);
                    if (raw === String(cast)) {
                      return -cast;
                    } else {
                      return -raw;
                    }
                  }
                } else if (Utils.isNumeric(scalar)) {
                  return parseFloat(scalar);
                } else if (this.PATTERN_THOUSAND_NUMERIC_SCALAR.test(scalar)) {
                  return parseFloat(scalar.replace(",", ""));
                }
                return scalar;
              default:
                if (date = Utils.stringToDate(scalar)) {
                  return date;
                } else if (Utils.isNumeric(scalar)) {
                  return parseFloat(scalar);
                } else if (this.PATTERN_THOUSAND_NUMERIC_SCALAR.test(scalar)) {
                  return parseFloat(scalar.replace(",", ""));
                }
                return scalar;
            }
        }
      };
      return Inline2;
    }();
    module.exports = Inline;
  }
});

// node_modules/yamljs/lib/Parser.js
var require_Parser = __commonJS({
  "node_modules/yamljs/lib/Parser.js"(exports, module) {
    var Inline;
    var ParseException;
    var ParseMore;
    var Parser2;
    var Pattern;
    var Utils;
    Inline = require_Inline();
    Pattern = require_Pattern();
    Utils = require_Utils();
    ParseException = require_ParseException();
    ParseMore = require_ParseMore();
    Parser2 = function() {
      Parser3.prototype.PATTERN_FOLDED_SCALAR_ALL = new Pattern("^(?:(?<type>![^\\|>]*)\\s+)?(?<separator>\\||>)(?<modifiers>\\+|\\-|\\d+|\\+\\d+|\\-\\d+|\\d+\\+|\\d+\\-)?(?<comments> +#.*)?$");
      Parser3.prototype.PATTERN_FOLDED_SCALAR_END = new Pattern("(?<separator>\\||>)(?<modifiers>\\+|\\-|\\d+|\\+\\d+|\\-\\d+|\\d+\\+|\\d+\\-)?(?<comments> +#.*)?$");
      Parser3.prototype.PATTERN_SEQUENCE_ITEM = new Pattern("^\\-((?<leadspaces>\\s+)(?<value>.+?))?\\s*$");
      Parser3.prototype.PATTERN_ANCHOR_VALUE = new Pattern("^&(?<ref>[^ ]+) *(?<value>.*)");
      Parser3.prototype.PATTERN_COMPACT_NOTATION = new Pattern("^(?<key>" + Inline.REGEX_QUOTED_STRING + `|[^ '"\\{\\[].*?) *\\:(\\s+(?<value>.+?))?\\s*$`);
      Parser3.prototype.PATTERN_MAPPING_ITEM = new Pattern("^(?<key>" + Inline.REGEX_QUOTED_STRING + `|[^ '"\\[\\{].*?) *\\:(\\s+(?<value>.+?))?\\s*$`);
      Parser3.prototype.PATTERN_DECIMAL = new Pattern("\\d+");
      Parser3.prototype.PATTERN_INDENT_SPACES = new Pattern("^ +");
      Parser3.prototype.PATTERN_TRAILING_LINES = new Pattern("(\n*)$");
      Parser3.prototype.PATTERN_YAML_HEADER = new Pattern("^\\%YAML[: ][\\d\\.]+.*\n", "m");
      Parser3.prototype.PATTERN_LEADING_COMMENTS = new Pattern("^(\\#.*?\n)+", "m");
      Parser3.prototype.PATTERN_DOCUMENT_MARKER_START = new Pattern("^\\-\\-\\-.*?\n", "m");
      Parser3.prototype.PATTERN_DOCUMENT_MARKER_END = new Pattern("^\\.\\.\\.\\s*$", "m");
      Parser3.prototype.PATTERN_FOLDED_SCALAR_BY_INDENTATION = {};
      Parser3.prototype.CONTEXT_NONE = 0;
      Parser3.prototype.CONTEXT_SEQUENCE = 1;
      Parser3.prototype.CONTEXT_MAPPING = 2;
      function Parser3(offset) {
        this.offset = offset != null ? offset : 0;
        this.lines = [];
        this.currentLineNb = -1;
        this.currentLine = "";
        this.refs = {};
      }
      Parser3.prototype.parse = function(value, exceptionOnInvalidType, objectDecoder) {
        var alias, allowOverwrite, block, c, context, data, e, first, i, indent3, isRef, j, k, key, l, lastKey, len, len1, len2, len3, lineCount, m, matches, mergeNode, n, name, parsed, parsedItem, parser2, ref, ref1, ref2, refName, refValue, val, values;
        if (exceptionOnInvalidType == null) {
          exceptionOnInvalidType = false;
        }
        if (objectDecoder == null) {
          objectDecoder = null;
        }
        this.currentLineNb = -1;
        this.currentLine = "";
        this.lines = this.cleanup(value).split("\n");
        data = null;
        context = this.CONTEXT_NONE;
        allowOverwrite = false;
        while (this.moveToNextLine()) {
          if (this.isCurrentLineEmpty()) {
            continue;
          }
          if (this.currentLine[0] === "	") {
            throw new ParseException("A YAML file cannot contain tabs as indentation.", this.getRealCurrentLineNb() + 1, this.currentLine);
          }
          isRef = mergeNode = false;
          if (values = this.PATTERN_SEQUENCE_ITEM.exec(this.currentLine)) {
            if (this.CONTEXT_MAPPING === context) {
              throw new ParseException("You cannot define a sequence item when in a mapping");
            }
            context = this.CONTEXT_SEQUENCE;
            if (data == null) {
              data = [];
            }
            if (values.value != null && (matches = this.PATTERN_ANCHOR_VALUE.exec(values.value))) {
              isRef = matches.ref;
              values.value = matches.value;
            }
            if (!(values.value != null) || Utils.trim(values.value, " ") === "" || Utils.ltrim(values.value, " ").indexOf("#") === 0) {
              if (this.currentLineNb < this.lines.length - 1 && !this.isNextLineUnIndentedCollection()) {
                c = this.getRealCurrentLineNb() + 1;
                parser2 = new Parser3(c);
                parser2.refs = this.refs;
                data.push(parser2.parse(this.getNextEmbedBlock(null, true), exceptionOnInvalidType, objectDecoder));
              } else {
                data.push(null);
              }
            } else {
              if (((ref = values.leadspaces) != null ? ref.length : void 0) && (matches = this.PATTERN_COMPACT_NOTATION.exec(values.value))) {
                c = this.getRealCurrentLineNb();
                parser2 = new Parser3(c);
                parser2.refs = this.refs;
                block = values.value;
                indent3 = this.getCurrentLineIndentation();
                if (this.isNextLineIndented(false)) {
                  block += "\n" + this.getNextEmbedBlock(indent3 + values.leadspaces.length + 1, true);
                }
                data.push(parser2.parse(block, exceptionOnInvalidType, objectDecoder));
              } else {
                data.push(this.parseValue(values.value, exceptionOnInvalidType, objectDecoder));
              }
            }
          } else if ((values = this.PATTERN_MAPPING_ITEM.exec(this.currentLine)) && values.key.indexOf(" #") === -1) {
            if (this.CONTEXT_SEQUENCE === context) {
              throw new ParseException("You cannot define a mapping item when in a sequence");
            }
            context = this.CONTEXT_MAPPING;
            if (data == null) {
              data = {};
            }
            Inline.configure(exceptionOnInvalidType, objectDecoder);
            try {
              key = Inline.parseScalar(values.key);
            } catch (error) {
              e = error;
              e.parsedLine = this.getRealCurrentLineNb() + 1;
              e.snippet = this.currentLine;
              throw e;
            }
            if (key === "<<") {
              mergeNode = true;
              allowOverwrite = true;
              if (((ref1 = values.value) != null ? ref1.indexOf("*") : void 0) === 0) {
                refName = values.value.slice(1);
                if (this.refs[refName] == null) {
                  throw new ParseException('Reference "' + refName + '" does not exist.', this.getRealCurrentLineNb() + 1, this.currentLine);
                }
                refValue = this.refs[refName];
                if (typeof refValue !== "object") {
                  throw new ParseException("YAML merge keys used with a scalar value instead of an object.", this.getRealCurrentLineNb() + 1, this.currentLine);
                }
                if (refValue instanceof Array) {
                  for (i = j = 0, len = refValue.length; j < len; i = ++j) {
                    value = refValue[i];
                    if (data[name = String(i)] == null) {
                      data[name] = value;
                    }
                  }
                } else {
                  for (key in refValue) {
                    value = refValue[key];
                    if (data[key] == null) {
                      data[key] = value;
                    }
                  }
                }
              } else {
                if (values.value != null && values.value !== "") {
                  value = values.value;
                } else {
                  value = this.getNextEmbedBlock();
                }
                c = this.getRealCurrentLineNb() + 1;
                parser2 = new Parser3(c);
                parser2.refs = this.refs;
                parsed = parser2.parse(value, exceptionOnInvalidType);
                if (typeof parsed !== "object") {
                  throw new ParseException("YAML merge keys used with a scalar value instead of an object.", this.getRealCurrentLineNb() + 1, this.currentLine);
                }
                if (parsed instanceof Array) {
                  for (l = 0, len1 = parsed.length; l < len1; l++) {
                    parsedItem = parsed[l];
                    if (typeof parsedItem !== "object") {
                      throw new ParseException("Merge items must be objects.", this.getRealCurrentLineNb() + 1, parsedItem);
                    }
                    if (parsedItem instanceof Array) {
                      for (i = m = 0, len2 = parsedItem.length; m < len2; i = ++m) {
                        value = parsedItem[i];
                        k = String(i);
                        if (!data.hasOwnProperty(k)) {
                          data[k] = value;
                        }
                      }
                    } else {
                      for (key in parsedItem) {
                        value = parsedItem[key];
                        if (!data.hasOwnProperty(key)) {
                          data[key] = value;
                        }
                      }
                    }
                  }
                } else {
                  for (key in parsed) {
                    value = parsed[key];
                    if (!data.hasOwnProperty(key)) {
                      data[key] = value;
                    }
                  }
                }
              }
            } else if (values.value != null && (matches = this.PATTERN_ANCHOR_VALUE.exec(values.value))) {
              isRef = matches.ref;
              values.value = matches.value;
            }
            if (mergeNode) {
            } else if (!(values.value != null) || Utils.trim(values.value, " ") === "" || Utils.ltrim(values.value, " ").indexOf("#") === 0) {
              if (!this.isNextLineIndented() && !this.isNextLineUnIndentedCollection()) {
                if (allowOverwrite || data[key] === void 0) {
                  data[key] = null;
                }
              } else {
                c = this.getRealCurrentLineNb() + 1;
                parser2 = new Parser3(c);
                parser2.refs = this.refs;
                val = parser2.parse(this.getNextEmbedBlock(), exceptionOnInvalidType, objectDecoder);
                if (allowOverwrite || data[key] === void 0) {
                  data[key] = val;
                }
              }
            } else {
              val = this.parseValue(values.value, exceptionOnInvalidType, objectDecoder);
              if (allowOverwrite || data[key] === void 0) {
                data[key] = val;
              }
            }
          } else {
            lineCount = this.lines.length;
            if (lineCount === 1 || lineCount === 2 && Utils.isEmpty(this.lines[1])) {
              try {
                value = Inline.parse(this.lines[0], exceptionOnInvalidType, objectDecoder);
              } catch (error) {
                e = error;
                e.parsedLine = this.getRealCurrentLineNb() + 1;
                e.snippet = this.currentLine;
                throw e;
              }
              if (typeof value === "object") {
                if (value instanceof Array) {
                  first = value[0];
                } else {
                  for (key in value) {
                    first = value[key];
                    break;
                  }
                }
                if (typeof first === "string" && first.indexOf("*") === 0) {
                  data = [];
                  for (n = 0, len3 = value.length; n < len3; n++) {
                    alias = value[n];
                    data.push(this.refs[alias.slice(1)]);
                  }
                  value = data;
                }
              }
              return value;
            } else if ((ref2 = Utils.ltrim(value).charAt(0)) === "[" || ref2 === "{") {
              try {
                return Inline.parse(value, exceptionOnInvalidType, objectDecoder);
              } catch (error) {
                e = error;
                e.parsedLine = this.getRealCurrentLineNb() + 1;
                e.snippet = this.currentLine;
                throw e;
              }
            }
            throw new ParseException("Unable to parse.", this.getRealCurrentLineNb() + 1, this.currentLine);
          }
          if (isRef) {
            if (data instanceof Array) {
              this.refs[isRef] = data[data.length - 1];
            } else {
              lastKey = null;
              for (key in data) {
                lastKey = key;
              }
              this.refs[isRef] = data[lastKey];
            }
          }
        }
        if (Utils.isEmpty(data)) {
          return null;
        } else {
          return data;
        }
      };
      Parser3.prototype.getRealCurrentLineNb = function() {
        return this.currentLineNb + this.offset;
      };
      Parser3.prototype.getCurrentLineIndentation = function() {
        return this.currentLine.length - Utils.ltrim(this.currentLine, " ").length;
      };
      Parser3.prototype.getNextEmbedBlock = function(indentation, includeUnindentedCollection) {
        var data, indent3, isItUnindentedCollection, newIndent, removeComments, removeCommentsPattern, unindentedEmbedBlock;
        if (indentation == null) {
          indentation = null;
        }
        if (includeUnindentedCollection == null) {
          includeUnindentedCollection = false;
        }
        this.moveToNextLine();
        if (indentation == null) {
          newIndent = this.getCurrentLineIndentation();
          unindentedEmbedBlock = this.isStringUnIndentedCollectionItem(this.currentLine);
          if (!this.isCurrentLineEmpty() && newIndent === 0 && !unindentedEmbedBlock) {
            throw new ParseException("Indentation problem.", this.getRealCurrentLineNb() + 1, this.currentLine);
          }
        } else {
          newIndent = indentation;
        }
        data = [this.currentLine.slice(newIndent)];
        if (!includeUnindentedCollection) {
          isItUnindentedCollection = this.isStringUnIndentedCollectionItem(this.currentLine);
        }
        removeCommentsPattern = this.PATTERN_FOLDED_SCALAR_END;
        removeComments = !removeCommentsPattern.test(this.currentLine);
        while (this.moveToNextLine()) {
          indent3 = this.getCurrentLineIndentation();
          if (indent3 === newIndent) {
            removeComments = !removeCommentsPattern.test(this.currentLine);
          }
          if (removeComments && this.isCurrentLineComment()) {
            continue;
          }
          if (this.isCurrentLineBlank()) {
            data.push(this.currentLine.slice(newIndent));
            continue;
          }
          if (isItUnindentedCollection && !this.isStringUnIndentedCollectionItem(this.currentLine) && indent3 === newIndent) {
            this.moveToPreviousLine();
            break;
          }
          if (indent3 >= newIndent) {
            data.push(this.currentLine.slice(newIndent));
          } else if (Utils.ltrim(this.currentLine).charAt(0) === "#") {
          } else if (indent3 === 0) {
            this.moveToPreviousLine();
            break;
          } else {
            throw new ParseException("Indentation problem.", this.getRealCurrentLineNb() + 1, this.currentLine);
          }
        }
        return data.join("\n");
      };
      Parser3.prototype.moveToNextLine = function() {
        if (this.currentLineNb >= this.lines.length - 1) {
          return false;
        }
        this.currentLine = this.lines[++this.currentLineNb];
        return true;
      };
      Parser3.prototype.moveToPreviousLine = function() {
        this.currentLine = this.lines[--this.currentLineNb];
      };
      Parser3.prototype.parseValue = function(value, exceptionOnInvalidType, objectDecoder) {
        var e, foldedIndent, matches, modifiers, pos, ref, ref1, val;
        if (value.indexOf("*") === 0) {
          pos = value.indexOf("#");
          if (pos !== -1) {
            value = value.substr(1, pos - 2);
          } else {
            value = value.slice(1);
          }
          if (this.refs[value] === void 0) {
            throw new ParseException('Reference "' + value + '" does not exist.', this.currentLine);
          }
          return this.refs[value];
        }
        if (matches = this.PATTERN_FOLDED_SCALAR_ALL.exec(value)) {
          modifiers = (ref = matches.modifiers) != null ? ref : "";
          foldedIndent = Math.abs(parseInt(modifiers));
          if (isNaN(foldedIndent)) {
            foldedIndent = 0;
          }
          val = this.parseFoldedScalar(matches.separator, this.PATTERN_DECIMAL.replace(modifiers, ""), foldedIndent);
          if (matches.type != null) {
            Inline.configure(exceptionOnInvalidType, objectDecoder);
            return Inline.parseScalar(matches.type + " " + val);
          } else {
            return val;
          }
        }
        if ((ref1 = value.charAt(0)) === "[" || ref1 === "{" || ref1 === '"' || ref1 === "'") {
          while (true) {
            try {
              return Inline.parse(value, exceptionOnInvalidType, objectDecoder);
            } catch (error) {
              e = error;
              if (e instanceof ParseMore && this.moveToNextLine()) {
                value += "\n" + Utils.trim(this.currentLine, " ");
              } else {
                e.parsedLine = this.getRealCurrentLineNb() + 1;
                e.snippet = this.currentLine;
                throw e;
              }
            }
          }
        } else {
          if (this.isNextLineIndented()) {
            value += "\n" + this.getNextEmbedBlock();
          }
          return Inline.parse(value, exceptionOnInvalidType, objectDecoder);
        }
      };
      Parser3.prototype.parseFoldedScalar = function(separator, indicator, indentation) {
        var isCurrentLineBlank, j, len, line, matches, newText, notEOF, pattern, ref, text;
        if (indicator == null) {
          indicator = "";
        }
        if (indentation == null) {
          indentation = 0;
        }
        notEOF = this.moveToNextLine();
        if (!notEOF) {
          return "";
        }
        isCurrentLineBlank = this.isCurrentLineBlank();
        text = "";
        while (notEOF && isCurrentLineBlank) {
          if (notEOF = this.moveToNextLine()) {
            text += "\n";
            isCurrentLineBlank = this.isCurrentLineBlank();
          }
        }
        if (indentation === 0) {
          if (matches = this.PATTERN_INDENT_SPACES.exec(this.currentLine)) {
            indentation = matches[0].length;
          }
        }
        if (indentation > 0) {
          pattern = this.PATTERN_FOLDED_SCALAR_BY_INDENTATION[indentation];
          if (pattern == null) {
            pattern = new Pattern("^ {" + indentation + "}(.*)$");
            Parser3.prototype.PATTERN_FOLDED_SCALAR_BY_INDENTATION[indentation] = pattern;
          }
          while (notEOF && (isCurrentLineBlank || (matches = pattern.exec(this.currentLine)))) {
            if (isCurrentLineBlank) {
              text += this.currentLine.slice(indentation);
            } else {
              text += matches[1];
            }
            if (notEOF = this.moveToNextLine()) {
              text += "\n";
              isCurrentLineBlank = this.isCurrentLineBlank();
            }
          }
        } else if (notEOF) {
          text += "\n";
        }
        if (notEOF) {
          this.moveToPreviousLine();
        }
        if (separator === ">") {
          newText = "";
          ref = text.split("\n");
          for (j = 0, len = ref.length; j < len; j++) {
            line = ref[j];
            if (line.length === 0 || line.charAt(0) === " ") {
              newText = Utils.rtrim(newText, " ") + line + "\n";
            } else {
              newText += line + " ";
            }
          }
          text = newText;
        }
        if (indicator !== "+") {
          text = Utils.rtrim(text);
        }
        if (indicator === "") {
          text = this.PATTERN_TRAILING_LINES.replace(text, "\n");
        } else if (indicator === "-") {
          text = this.PATTERN_TRAILING_LINES.replace(text, "");
        }
        return text;
      };
      Parser3.prototype.isNextLineIndented = function(ignoreComments) {
        var EOF, currentIndentation, ret;
        if (ignoreComments == null) {
          ignoreComments = true;
        }
        currentIndentation = this.getCurrentLineIndentation();
        EOF = !this.moveToNextLine();
        if (ignoreComments) {
          while (!EOF && this.isCurrentLineEmpty()) {
            EOF = !this.moveToNextLine();
          }
        } else {
          while (!EOF && this.isCurrentLineBlank()) {
            EOF = !this.moveToNextLine();
          }
        }
        if (EOF) {
          return false;
        }
        ret = false;
        if (this.getCurrentLineIndentation() > currentIndentation) {
          ret = true;
        }
        this.moveToPreviousLine();
        return ret;
      };
      Parser3.prototype.isCurrentLineEmpty = function() {
        var trimmedLine;
        trimmedLine = Utils.trim(this.currentLine, " ");
        return trimmedLine.length === 0 || trimmedLine.charAt(0) === "#";
      };
      Parser3.prototype.isCurrentLineBlank = function() {
        return Utils.trim(this.currentLine, " ") === "";
      };
      Parser3.prototype.isCurrentLineComment = function() {
        var ltrimmedLine;
        ltrimmedLine = Utils.ltrim(this.currentLine, " ");
        return ltrimmedLine.charAt(0) === "#";
      };
      Parser3.prototype.cleanup = function(value) {
        var count, i, indent3, j, l, len, len1, line, lines, ref, ref1, ref2, smallestIndent, trimmedValue;
        if (value.indexOf("\r") !== -1) {
          value = value.split("\r\n").join("\n").split("\r").join("\n");
        }
        count = 0;
        ref = this.PATTERN_YAML_HEADER.replaceAll(value, ""), value = ref[0], count = ref[1];
        this.offset += count;
        ref1 = this.PATTERN_LEADING_COMMENTS.replaceAll(value, "", 1), trimmedValue = ref1[0], count = ref1[1];
        if (count === 1) {
          this.offset += Utils.subStrCount(value, "\n") - Utils.subStrCount(trimmedValue, "\n");
          value = trimmedValue;
        }
        ref2 = this.PATTERN_DOCUMENT_MARKER_START.replaceAll(value, "", 1), trimmedValue = ref2[0], count = ref2[1];
        if (count === 1) {
          this.offset += Utils.subStrCount(value, "\n") - Utils.subStrCount(trimmedValue, "\n");
          value = trimmedValue;
          value = this.PATTERN_DOCUMENT_MARKER_END.replace(value, "");
        }
        lines = value.split("\n");
        smallestIndent = -1;
        for (j = 0, len = lines.length; j < len; j++) {
          line = lines[j];
          if (Utils.trim(line, " ").length === 0) {
            continue;
          }
          indent3 = line.length - Utils.ltrim(line).length;
          if (smallestIndent === -1 || indent3 < smallestIndent) {
            smallestIndent = indent3;
          }
        }
        if (smallestIndent > 0) {
          for (i = l = 0, len1 = lines.length; l < len1; i = ++l) {
            line = lines[i];
            lines[i] = line.slice(smallestIndent);
          }
          value = lines.join("\n");
        }
        return value;
      };
      Parser3.prototype.isNextLineUnIndentedCollection = function(currentIndentation) {
        var notEOF, ret;
        if (currentIndentation == null) {
          currentIndentation = null;
        }
        if (currentIndentation == null) {
          currentIndentation = this.getCurrentLineIndentation();
        }
        notEOF = this.moveToNextLine();
        while (notEOF && this.isCurrentLineEmpty()) {
          notEOF = this.moveToNextLine();
        }
        if (notEOF === false) {
          return false;
        }
        ret = false;
        if (this.getCurrentLineIndentation() === currentIndentation && this.isStringUnIndentedCollectionItem(this.currentLine)) {
          ret = true;
        }
        this.moveToPreviousLine();
        return ret;
      };
      Parser3.prototype.isStringUnIndentedCollectionItem = function() {
        return this.currentLine === "-" || this.currentLine.slice(0, 2) === "- ";
      };
      return Parser3;
    }();
    module.exports = Parser2;
  }
});

// node_modules/yamljs/lib/Dumper.js
var require_Dumper = __commonJS({
  "node_modules/yamljs/lib/Dumper.js"(exports, module) {
    var Dumper;
    var Inline;
    var Utils;
    Utils = require_Utils();
    Inline = require_Inline();
    Dumper = function() {
      function Dumper2() {
      }
      Dumper2.indentation = 4;
      Dumper2.prototype.dump = function(input, inline, indent3, exceptionOnInvalidType, objectEncoder) {
        var i, key, len, output, prefix, value, willBeInlined;
        if (inline == null) {
          inline = 0;
        }
        if (indent3 == null) {
          indent3 = 0;
        }
        if (exceptionOnInvalidType == null) {
          exceptionOnInvalidType = false;
        }
        if (objectEncoder == null) {
          objectEncoder = null;
        }
        output = "";
        prefix = indent3 ? Utils.strRepeat(" ", indent3) : "";
        if (inline <= 0 || typeof input !== "object" || input instanceof Date || Utils.isEmpty(input)) {
          output += prefix + Inline.dump(input, exceptionOnInvalidType, objectEncoder);
        } else {
          if (input instanceof Array) {
            for (i = 0, len = input.length; i < len; i++) {
              value = input[i];
              willBeInlined = inline - 1 <= 0 || typeof value !== "object" || Utils.isEmpty(value);
              output += prefix + "-" + (willBeInlined ? " " : "\n") + this.dump(value, inline - 1, willBeInlined ? 0 : indent3 + this.indentation, exceptionOnInvalidType, objectEncoder) + (willBeInlined ? "\n" : "");
            }
          } else {
            for (key in input) {
              value = input[key];
              willBeInlined = inline - 1 <= 0 || typeof value !== "object" || Utils.isEmpty(value);
              output += prefix + Inline.dump(key, exceptionOnInvalidType, objectEncoder) + ":" + (willBeInlined ? " " : "\n") + this.dump(value, inline - 1, willBeInlined ? 0 : indent3 + this.indentation, exceptionOnInvalidType, objectEncoder) + (willBeInlined ? "\n" : "");
            }
          }
        }
        return output;
      };
      return Dumper2;
    }();
    module.exports = Dumper;
  }
});

// node_modules/yamljs/lib/Yaml.js
var require_Yaml = __commonJS({
  "node_modules/yamljs/lib/Yaml.js"(exports, module) {
    var Dumper;
    var Parser2;
    var Utils;
    var Yaml;
    Parser2 = require_Parser();
    Dumper = require_Dumper();
    Utils = require_Utils();
    Yaml = function() {
      function Yaml2() {
      }
      Yaml2.parse = function(input, exceptionOnInvalidType, objectDecoder) {
        if (exceptionOnInvalidType == null) {
          exceptionOnInvalidType = false;
        }
        if (objectDecoder == null) {
          objectDecoder = null;
        }
        return new Parser2().parse(input, exceptionOnInvalidType, objectDecoder);
      };
      Yaml2.parseFile = function(path, callback, exceptionOnInvalidType, objectDecoder) {
        var input;
        if (callback == null) {
          callback = null;
        }
        if (exceptionOnInvalidType == null) {
          exceptionOnInvalidType = false;
        }
        if (objectDecoder == null) {
          objectDecoder = null;
        }
        if (callback != null) {
          return Utils.getStringFromFile(path, function(_this) {
            return function(input2) {
              var result;
              result = null;
              if (input2 != null) {
                result = _this.parse(input2, exceptionOnInvalidType, objectDecoder);
              }
              callback(result);
            };
          }(this));
        } else {
          input = Utils.getStringFromFile(path);
          if (input != null) {
            return this.parse(input, exceptionOnInvalidType, objectDecoder);
          }
          return null;
        }
      };
      Yaml2.dump = function(input, inline, indent3, exceptionOnInvalidType, objectEncoder) {
        var yaml2;
        if (inline == null) {
          inline = 2;
        }
        if (indent3 == null) {
          indent3 = 4;
        }
        if (exceptionOnInvalidType == null) {
          exceptionOnInvalidType = false;
        }
        if (objectEncoder == null) {
          objectEncoder = null;
        }
        yaml2 = new Dumper();
        yaml2.indentation = indent3;
        return yaml2.dump(input, inline, 0, exceptionOnInvalidType, objectEncoder);
      };
      Yaml2.stringify = function(input, inline, indent3, exceptionOnInvalidType, objectEncoder) {
        return this.dump(input, inline, indent3, exceptionOnInvalidType, objectEncoder);
      };
      Yaml2.load = function(path, callback, exceptionOnInvalidType, objectDecoder) {
        return this.parseFile(path, callback, exceptionOnInvalidType, objectDecoder);
      };
      return Yaml2;
    }();
    if (typeof window !== "undefined" && window !== null) {
      window.YAML = Yaml;
    }
    if (typeof window === "undefined" || window === null) {
      exports.YAML = Yaml;
    }
    module.exports = Yaml;
  }
});

// node_modules/curlconverter/node_modules/jsesc/jsesc.js
var require_jsesc = __commonJS({
  "node_modules/curlconverter/node_modules/jsesc/jsesc.js"(exports, module) {
    "use strict";
    var object = {};
    var hasOwnProperty = object.hasOwnProperty;
    var forOwn = (object2, callback) => {
      for (const key in object2) {
        if (hasOwnProperty.call(object2, key)) {
          callback(key, object2[key]);
        }
      }
    };
    var extend = (destination, source) => {
      if (!source) {
        return destination;
      }
      forOwn(source, (key, value) => {
        destination[key] = value;
      });
      return destination;
    };
    var forEach = (array, callback) => {
      const length = array.length;
      let index = -1;
      while (++index < length) {
        callback(array[index]);
      }
    };
    var fourHexEscape = (hex) => {
      return "\\u" + ("0000" + hex).slice(-4);
    };
    var hexadecimal = (code, lowercase) => {
      let hexadecimal2 = code.toString(16);
      if (lowercase)
        return hexadecimal2;
      return hexadecimal2.toUpperCase();
    };
    var toString = object.toString;
    var isArray = Array.isArray;
    var isBuffer = (value) => {
      return typeof Buffer === "function" && Buffer.isBuffer(value);
    };
    var isObject = (value) => {
      return toString.call(value) == "[object Object]";
    };
    var isString = (value) => {
      return typeof value == "string" || toString.call(value) == "[object String]";
    };
    var isNumber2 = (value) => {
      return typeof value == "number" || toString.call(value) == "[object Number]";
    };
    var isFunction = (value) => {
      return typeof value == "function";
    };
    var isMap = (value) => {
      return toString.call(value) == "[object Map]";
    };
    var isSet = (value) => {
      return toString.call(value) == "[object Set]";
    };
    var singleEscapes = {
      "\\": "\\\\",
      "\b": "\\b",
      "\f": "\\f",
      "\n": "\\n",
      "\r": "\\r",
      "	": "\\t"
    };
    var regexSingleEscape4 = /[\\\b\f\n\r\t]/;
    var regexDigit4 = /[0-9]/;
    var regexWhitespace = /[\xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/;
    var escapeEverythingRegex = /([\uD800-\uDBFF][\uDC00-\uDFFF])|([\uD800-\uDFFF])|(['"`])|[^]/g;
    var escapeNonAsciiRegex = /([\uD800-\uDBFF][\uDC00-\uDFFF])|([\uD800-\uDFFF])|(['"`])|[^ !#-&\(-\[\]-_a-~]/g;
    var jsesc = (argument, options) => {
      const increaseIndentation = () => {
        oldIndent = indent3;
        ++options.indentLevel;
        indent3 = options.indent.repeat(options.indentLevel);
      };
      const defaults = {
        "escapeEverything": false,
        "minimal": false,
        "isScriptContext": false,
        "quotes": "single",
        "wrap": false,
        "es6": false,
        "json": false,
        "compact": true,
        "lowercaseHex": false,
        "numbers": "decimal",
        "indent": "	",
        "indentLevel": 0,
        "__inline1__": false,
        "__inline2__": false
      };
      const json = options && options.json;
      if (json) {
        defaults.quotes = "double";
        defaults.wrap = true;
      }
      options = extend(defaults, options);
      if (options.quotes != "single" && options.quotes != "double" && options.quotes != "backtick") {
        options.quotes = "single";
      }
      const quote = options.quotes == "double" ? '"' : options.quotes == "backtick" ? "`" : "'";
      const compact = options.compact;
      const lowercaseHex = options.lowercaseHex;
      let indent3 = options.indent.repeat(options.indentLevel);
      let oldIndent = "";
      const inline1 = options.__inline1__;
      const inline2 = options.__inline2__;
      const newLine = compact ? "" : "\n";
      let result;
      let isEmpty = true;
      const useBinNumbers = options.numbers == "binary";
      const useOctNumbers = options.numbers == "octal";
      const useDecNumbers = options.numbers == "decimal";
      const useHexNumbers = options.numbers == "hexadecimal";
      if (json && argument && isFunction(argument.toJSON)) {
        argument = argument.toJSON();
      }
      if (!isString(argument)) {
        if (isMap(argument)) {
          if (argument.size == 0) {
            return "new Map()";
          }
          if (!compact) {
            options.__inline1__ = true;
            options.__inline2__ = false;
          }
          return "new Map(" + jsesc(Array.from(argument), options) + ")";
        }
        if (isSet(argument)) {
          if (argument.size == 0) {
            return "new Set()";
          }
          return "new Set(" + jsesc(Array.from(argument), options) + ")";
        }
        if (isBuffer(argument)) {
          if (argument.length == 0) {
            return "Buffer.from([])";
          }
          return "Buffer.from(" + jsesc(Array.from(argument), options) + ")";
        }
        if (isArray(argument)) {
          result = [];
          options.wrap = true;
          if (inline1) {
            options.__inline1__ = false;
            options.__inline2__ = true;
          }
          if (!inline2) {
            increaseIndentation();
          }
          forEach(argument, (value) => {
            isEmpty = false;
            if (inline2) {
              options.__inline2__ = false;
            }
            result.push((compact || inline2 ? "" : indent3) + jsesc(value, options));
          });
          if (isEmpty) {
            return "[]";
          }
          if (inline2) {
            return "[" + result.join(", ") + "]";
          }
          return "[" + newLine + result.join("," + newLine) + newLine + (compact ? "" : oldIndent) + "]";
        } else if (isNumber2(argument)) {
          if (json) {
            return JSON.stringify(argument);
          }
          if (useDecNumbers) {
            return String(argument);
          }
          if (useHexNumbers) {
            let hexadecimal2 = argument.toString(16);
            if (!lowercaseHex) {
              hexadecimal2 = hexadecimal2.toUpperCase();
            }
            return "0x" + hexadecimal2;
          }
          if (useBinNumbers) {
            return "0b" + argument.toString(2);
          }
          if (useOctNumbers) {
            return "0o" + argument.toString(8);
          }
        } else if (!isObject(argument)) {
          if (json) {
            return JSON.stringify(argument) || "null";
          }
          return String(argument);
        } else {
          result = [];
          options.wrap = true;
          increaseIndentation();
          forOwn(argument, (key, value) => {
            isEmpty = false;
            result.push((compact ? "" : indent3) + jsesc(key, options) + ":" + (compact ? "" : " ") + jsesc(value, options));
          });
          if (isEmpty) {
            return "{}";
          }
          return "{" + newLine + result.join("," + newLine) + newLine + (compact ? "" : oldIndent) + "}";
        }
      }
      const regex = options.escapeEverything ? escapeEverythingRegex : escapeNonAsciiRegex;
      result = argument.replace(regex, (char, pair, lone, quoteChar, index, string) => {
        if (pair) {
          if (options.minimal)
            return pair;
          const first = pair.charCodeAt(0);
          const second = pair.charCodeAt(1);
          if (options.es6) {
            const codePoint = (first - 55296) * 1024 + second - 56320 + 65536;
            const hex2 = hexadecimal(codePoint, lowercaseHex);
            return "\\u{" + hex2 + "}";
          }
          return fourHexEscape(hexadecimal(first, lowercaseHex)) + fourHexEscape(hexadecimal(second, lowercaseHex));
        }
        if (lone) {
          return fourHexEscape(hexadecimal(lone.charCodeAt(0), lowercaseHex));
        }
        if (char == "\0" && !json && !regexDigit4.test(string.charAt(index + 1))) {
          return "\\0";
        }
        if (quoteChar) {
          if (quoteChar == quote || options.escapeEverything) {
            return "\\" + quoteChar;
          }
          return quoteChar;
        }
        if (regexSingleEscape4.test(char)) {
          return singleEscapes[char];
        }
        if (options.minimal && !regexWhitespace.test(char)) {
          return char;
        }
        const hex = hexadecimal(char.charCodeAt(0), lowercaseHex);
        if (json || hex.length > 2) {
          return fourHexEscape(hex);
        }
        return "\\x" + ("00" + hex).slice(-2);
      });
      if (quote == "`") {
        result = result.replace(/\$\{/g, "\\${");
      }
      if (options.isScriptContext) {
        result = result.replace(/<\/(script|style)/gi, "<\\/$1").replace(/<!--/g, json ? "\\u003C!--" : "\\x3C!--");
      }
      if (options.wrap) {
        result = quote + result + quote;
      }
      return result;
    };
    jsesc.version = "3.0.2";
    module.exports = jsesc;
  }
});

// node_modules/curlconverter/dist/src/util.js
var CCError = class extends Error {
};
var UTF8encoder = new TextEncoder();
function has(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
function isInt(s) {
  return /^\s*[+-]?\d+$/.test(s);
}

// node_modules/curlconverter/dist/src/shell/Word.js
var Word = class {
  constructor(tokens) {
    this.valueOf = Word.toString;
    if (typeof tokens === "string") {
      tokens = [tokens];
    }
    if (tokens === void 0 || tokens.length === 0) {
      tokens = [""];
    }
    this.tokens = [];
    for (const t of tokens) {
      if (typeof t === "string") {
        if (this.tokens.length > 0 && typeof this.tokens[this.tokens.length - 1] === "string") {
          this.tokens[this.tokens.length - 1] += t;
        } else if (t) {
          this.tokens.push(t);
        }
      } else {
        this.tokens.push(t);
      }
    }
    if (this.tokens.length === 0) {
      this.tokens.push("");
    }
  }
  get length() {
    let len = 0;
    for (const t of this.tokens) {
      if (typeof t === "string") {
        len += t.length;
      } else {
        len += 1;
      }
    }
    return len;
  }
  *[Symbol.iterator]() {
    for (const t of this.tokens) {
      if (typeof t === "string") {
        for (const c of t) {
          yield c;
        }
      } else {
        yield t;
      }
    }
  }
  get(index) {
    let i = 0;
    for (const t of this.tokens) {
      if (typeof t === "string") {
        if (i + t.length > index) {
          return t[index - i];
        }
        i += t.length;
      } else {
        if (i === index) {
          return t;
        }
        i += 1;
      }
    }
    throw new CCError("Index out of bounds");
  }
  charAt(index = 0) {
    try {
      return this.get(index);
    } catch (_a) {
    }
    return "";
  }
  indexOf(search, start) {
    if (start === void 0) {
      start = 0;
    }
    let i = 0;
    for (const t of this.tokens) {
      if (typeof t === "string") {
        if (i + t.length > start) {
          const index = t.indexOf(search, start - i);
          if (index !== -1) {
            return i + index;
          }
        }
        i += t.length;
      } else {
        i += 1;
      }
    }
    return -1;
  }
  indexOfFirstChar(search) {
    let i = 0;
    for (const t of this.tokens) {
      if (typeof t === "string") {
        for (const c of t) {
          if (search.includes(c)) {
            return i;
          }
          i += 1;
        }
      } else {
        i += 1;
      }
    }
    return -1;
  }
  removeFirstChar(c) {
    if (this.length === 0) {
      return new Word();
    }
    if (this.charAt(0) === c) {
      return this.slice(1);
    }
    return this.copy();
  }
  copy() {
    return new Word(this.tokens);
  }
  slice(indexStart, indexEnd) {
    if (indexStart === void 0) {
      indexStart = this.length;
    }
    if (indexEnd === void 0) {
      indexEnd = this.length;
    }
    if (indexStart >= this.length) {
      return new Word();
    }
    if (indexStart < 0) {
      indexStart = Math.max(indexStart + this.length, 0);
    }
    if (indexEnd < 0) {
      indexEnd = Math.max(indexEnd + this.length, 0);
    }
    if (indexEnd <= indexStart) {
      return new Word();
    }
    const ret = [];
    let i = 0;
    for (const t of this.tokens) {
      if (typeof t === "string") {
        if (i + t.length > indexStart) {
          if (i < indexEnd) {
            ret.push(t.slice(Math.max(indexStart - i, 0), indexEnd - i));
          }
        }
        i += t.length;
      } else {
        if (i >= indexStart && i < indexEnd) {
          ret.push(t);
        }
        i += 1;
      }
    }
    return new Word(ret);
  }
  includes(search, start) {
    if (start === void 0) {
      start = 0;
    }
    let i = 0;
    for (const t of this.tokens) {
      if (typeof t === "string") {
        if (i + t.length > start) {
          if (t.includes(search, start - i)) {
            return true;
          }
        }
        i += t.length;
      } else {
        i += 1;
      }
    }
    return false;
  }
  test(search) {
    for (const t of this.tokens) {
      if (typeof t === "string") {
        if (search.test(t)) {
          return true;
        }
      }
    }
    return false;
  }
  prepend(c) {
    const ret = this.copy();
    if (ret.tokens.length && typeof ret.tokens[0] === "string") {
      ret.tokens[0] = c + ret.tokens[0];
    } else {
      ret.tokens.unshift(c);
    }
    return ret;
  }
  append(c) {
    const ret = this.copy();
    if (ret.tokens.length && typeof ret.tokens[ret.tokens.length - 1] === "string") {
      ret.tokens[ret.tokens.length - 1] += c;
    } else {
      ret.tokens.push(c);
    }
    return ret;
  }
  add(other) {
    return new Word([...this.tokens, ...other.tokens]);
  }
  match(regex) {
    for (const t of this.tokens) {
      if (typeof t === "string") {
        const match = t.match(regex);
        if (match) {
          return match;
        }
      }
    }
    return null;
  }
  replace(search, replacement) {
    const ret = [];
    for (const t of this.tokens) {
      if (typeof t === "string") {
        ret.push(t.replace(search, replacement));
      } else {
        ret.push(t);
      }
    }
    return new Word(ret);
  }
  split(separator, limit) {
    const ret = [];
    let i = 0;
    let start = 0;
    while (i < this.length) {
      let match = true;
      for (let j = 0; j < separator.length; j++) {
        if (this.get(i + j) !== separator.charAt(j)) {
          match = false;
          break;
        }
      }
      if (match) {
        ret.push(this.slice(start, i));
        i += separator.length;
        start = i;
        if (limit !== void 0 && ret.length === limit - 1) {
          break;
        }
      } else {
        i += 1;
      }
    }
    if (start <= this.length) {
      ret.push(this.slice(start));
    }
    return ret;
  }
  toLowerCase() {
    return new Word(this.tokens.map((t) => typeof t === "string" ? t.toLowerCase() : t));
  }
  toUpperCase() {
    return new Word(this.tokens.map((t) => typeof t === "string" ? t.toUpperCase() : t));
  }
  trim() {
    const ret = [];
    let i, t;
    for ([i, t] of this.tokens.entries()) {
      if (typeof t === "string") {
        if (i === 0) {
          t = t.trimStart();
        }
        if (i === this.tokens.length - 1) {
          t = t.trimEnd();
        }
        if (t) {
          ret.push(t);
        }
      } else {
        ret.push(t);
      }
    }
    if (ret.length === 0) {
      return new Word();
    }
    return new Word(ret);
  }
  isEmpty() {
    if (this.tokens.length === 0) {
      return true;
    }
    if (this.tokens.length === 1 && typeof this.tokens[0] === "string") {
      return this.tokens[0].length === 0;
    }
    return false;
  }
  toBool() {
    return !this.isEmpty();
  }
  isString() {
    for (const t of this.tokens) {
      if (typeof t !== "string") {
        return false;
      }
    }
    return true;
  }
  firstShellToken() {
    for (const t of this.tokens) {
      if (typeof t !== "string") {
        return t;
      }
    }
    return null;
  }
  startsWith(prefix) {
    if (this.tokens.length === 0) {
      return false;
    }
    if (typeof this.tokens[0] === "string") {
      return this.tokens[0].startsWith(prefix);
    }
    return false;
  }
  endsWith(suffix) {
    if (this.tokens.length === 0) {
      return false;
    }
    const lastToken = this.tokens[this.tokens.length - 1];
    if (typeof lastToken === "string") {
      return lastToken.endsWith(suffix);
    }
    return false;
  }
  toString() {
    return this.tokens.map((t) => typeof t === "string" ? t : t.text).join("");
  }
};
function eq(it, other) {
  if (it === void 0 || it === null || other === void 0 || other === null) {
    return it === other;
  }
  if (typeof other === "string") {
    return it.tokens.length === 1 && typeof it.tokens[0] === "string" && it.tokens[0] === other;
  }
  return it.tokens.length === other.tokens.length && it.tokens.every((itToken, i) => {
    const otherToken = other.tokens[i];
    if (typeof itToken === "string") {
      return itToken === otherToken;
    } else if (typeof otherToken !== "string") {
      return itToken.text === otherToken.text;
    }
    return false;
  });
}
function firstShellToken(word) {
  if (typeof word === "string") {
    return null;
  }
  return word.firstShellToken();
}
function mergeWords(words) {
  const ret = [];
  for (const w of words) {
    if (w instanceof Word) {
      ret.push(...w.tokens);
    } else {
      ret.push(w);
    }
  }
  return new Word(ret);
}
function joinWords(words, joinChar) {
  const ret = [];
  for (const w of words) {
    if (ret.length) {
      ret.push(joinChar);
    }
    ret.push(...w.tokens);
  }
  return new Word(ret);
}

// node_modules/curlconverter/dist/src/shell/webParser.js
var import_web_tree_sitter = __toESM(require_tree_sitter(), 1);
await import_web_tree_sitter.default.init();
var Bash = await import_web_tree_sitter.default.Language.load("/tree-sitter-bash.wasm");
var parser = new import_web_tree_sitter.default();
parser.setLanguage(Bash);
var webParser_default = parser;

// node_modules/curlconverter/dist/src/Warnings.js
function warnf(global, warning) {
  global.warnings.push(warning);
}
function underlineNode(node, curlCommand) {
  curlCommand = node.tree.rootNode.text;
  const line = curlCommand.split("\n")[node.startPosition.row];
  const onOneLine = node.endPosition.row === node.startPosition.row;
  const end = onOneLine ? node.endPosition.column : line.length;
  return `${line}
` + " ".repeat(node.startPosition.column) + "^".repeat(end - node.startPosition.column) + (onOneLine ? "" : "^");
}
function underlineNodeEnd(node, curlCommand) {
  curlCommand = node.tree.rootNode.text;
  const line = curlCommand.split("\n")[node.endPosition.row];
  const onOneLine = node.endPosition.row === node.startPosition.row;
  const start = onOneLine ? node.startPosition.column : 0;
  return `${line}
` + " ".repeat(start) + "^".repeat(node.endPosition.column);
}
function warnIfPartsIgnored(request, warnings, support) {
  if (request.urls.length > 1 && !(support === null || support === void 0 ? void 0 : support.multipleUrls)) {
    warnings.push([
      "multiple-urls",
      "found " + request.urls.length + " URLs, only the first one will be used: " + request.urls.map((u) => JSON.stringify(u.originalUrl.toString())).join(", ")
    ]);
  }
  if (request.dataReadsFile && !(support === null || support === void 0 ? void 0 : support.multipleUrls)) {
    warnings.push([
      "unsafe-data",
      "the generated data content is wrong, " + JSON.stringify("@" + request.dataReadsFile) + " means read the file " + JSON.stringify(request.dataReadsFile)
    ]);
  }
  if (request.urls[0].queryReadsFile && !(support === null || support === void 0 ? void 0 : support.queryReadsFile)) {
    warnings.push([
      "unsafe-query",
      "the generated URL query string is wrong, " + JSON.stringify("@" + request.urls[0].queryReadsFile) + " means read the file " + JSON.stringify(request.urls[0].queryReadsFile)
    ]);
  }
  if (request.cookieFiles && !(support === null || support === void 0 ? void 0 : support.cookieFiles)) {
    warnings.push([
      "cookie-files",
      "passing a file for --cookie/-b is not supported: " + request.cookieFiles.map((c) => JSON.stringify(c.toString())).join(", ")
    ]);
  }
}

// node_modules/curlconverter/dist/src/shell/tokenizer.js
var BACKSLASHES = /\\./gs;
function removeBackslash(m) {
  return m.charAt(1) === "\n" ? "" : m.charAt(1);
}
function removeBackslashes(str) {
  return str.replace(BACKSLASHES, removeBackslash);
}
var DOUBLE_QUOTE_BACKSLASHES = /\\[\\$`"\n]/gs;
function removeDoubleQuoteBackslashes(str) {
  return str.replace(DOUBLE_QUOTE_BACKSLASHES, removeBackslash);
}
var ANSI_BACKSLASHES = /\\(\\|a|b|e|E|f|n|r|t|v|'|"|\?|[0-7]{1,3}|x[0-9A-Fa-f]{1,2}|u[0-9A-Fa-f]{1,4}|U[0-9A-Fa-f]{1,8}|c.)/gs;
function removeAnsiCBackslashes(str) {
  function unescapeChar(m) {
    switch (m.charAt(1)) {
      case "\\":
        return "\\";
      case "a":
        return "\x07";
      case "b":
        return "\b";
      case "e":
      case "E":
        return "\x1B";
      case "f":
        return "\f";
      case "n":
        return "\n";
      case "r":
        return "\r";
      case "t":
        return "	";
      case "v":
        return "\v";
      case "'":
        return "'";
      case '"':
        return '"';
      case "?":
        return "?";
      case "c":
        if (m.codePointAt(2) > 127) {
          throw new CCError('non-ASCII control character in ANSI-C quoted string: "\\u{' + m.codePointAt(2).toString(16) + '}"');
        }
        return m[2] === "?" ? "\x7F" : String.fromCodePoint(m[2].toUpperCase().codePointAt(0) & 31);
      case "x":
      case "u":
      case "U":
        return String.fromCodePoint(parseInt(m.slice(2), 16));
      case "0":
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
        return String.fromCodePoint(parseInt(m.slice(1), 8) % 256);
      default:
        throw new CCError("unhandled character in ANSI-C escape code: " + JSON.stringify(m));
    }
  }
  return str.replace(ANSI_BACKSLASHES, unescapeChar);
}
function toTokens(node, curlCommand, warnings) {
  let vals = [];
  switch (node.type) {
    case "word":
      return [removeBackslashes(node.text)];
    case "raw_string":
      return [node.text.slice(1, -1)];
    case "ansii_c_string":
      return [removeAnsiCBackslashes(node.text.slice(2, -1))];
    case "string":
    case "string_expansion": {
      let prevEnd = node.type === "string" ? 1 : 2;
      let res = "";
      for (const child of node.namedChildren) {
        res += removeDoubleQuoteBackslashes(node.text.slice(prevEnd, child.startIndex - node.startIndex));
        const subVal = toTokens(child, curlCommand, warnings);
        if (typeof subVal === "string") {
          res += subVal;
        } else {
          if (res) {
            vals.push(res);
            res = "";
          }
          vals = vals.concat(subVal);
        }
        prevEnd = child.endIndex - node.startIndex;
      }
      res += removeDoubleQuoteBackslashes(node.text.slice(prevEnd, -1));
      if (res || vals.length === 0) {
        vals.push(res);
      }
      return vals;
    }
    case "simple_expansion":
      warnings.push([
        "expansion",
        "found shell environment variable\n" + underlineNode(node, curlCommand)
      ]);
      if (node.firstNamedChild && node.firstNamedChild.type === "special_variable_name") {
        warnings.push([
          "special_variable_name",
          node.text + " is a special Bash variable\n" + underlineNode(node.firstNamedChild, curlCommand)
        ]);
      }
      return [
        {
          type: "variable",
          value: node.text.slice(1),
          text: node.text,
          syntaxNode: node
        }
      ];
    case "expansion":
      warnings.push([
        "expansion",
        "found expansion expression\n" + underlineNode(node, curlCommand)
      ]);
      return [
        {
          type: "variable",
          value: node.text.slice(2, -1),
          text: node.text,
          syntaxNode: node
        }
      ];
    case "command_substitution":
      warnings.push([
        "expansion",
        "found command substitution expression\n" + underlineNode(node, curlCommand)
      ]);
      return [
        {
          type: "command",
          value: node.text.slice(node.text.startsWith("$(") ? 2 : 1, -1),
          text: node.text,
          syntaxNode: node
        }
      ];
    case "concatenation": {
      let prevEnd = 0;
      let res = "";
      for (const child of node.children) {
        res += node.text.slice(prevEnd, child.startIndex - node.startIndex);
        prevEnd = child.endIndex - node.startIndex;
        const subVal = toTokens(child, curlCommand, warnings);
        if (typeof subVal === "string") {
          res += subVal;
        } else {
          if (res) {
            vals.push(res);
            res = "";
          }
          vals = vals.concat(subVal);
        }
      }
      res += node.text.slice(prevEnd);
      if (res || vals.length === 0) {
        vals.push(res);
      }
      return vals;
    }
    default:
      throw new CCError("unexpected argument type " + JSON.stringify(node.type) + '. Must be one of "word", "string", "raw_string", "ansii_c_string", "expansion", "simple_expansion", "string_expansion" or "concatenation"\n' + underlineNode(node, curlCommand));
  }
}
function toWord(node, curlCommand, warnings) {
  return new Word(toTokens(node, curlCommand, warnings));
}
function findFirstCommandNode(ast, curlCommand, warnings) {
  for (const n of [ast.rootNode, ...ast.rootNode.children]) {
    if (n.type === "ERROR") {
      warnings.push([
        "bash",
        `Bash parsing error on line ${n.startPosition.row + 1}:
` + underlineNode(n, curlCommand)
      ]);
      break;
    }
  }
  if (ast.rootNode.type !== "program") {
    throw new CCError('expected a "program" top-level AST node, got ' + ast.rootNode.type + " instead");
  }
  if (ast.rootNode.childCount < 1 || !ast.rootNode.children) {
    throw new CCError('empty "program" node');
  }
  let command, lastNode, stdin, stdinFile;
  for (const n of ast.rootNode.children) {
    if (n.type === "comment") {
      continue;
    } else if (n.type === "command") {
      command = n;
      lastNode = n;
      break;
    } else if (n.type === "redirected_statement") {
      if (!n.childCount) {
        throw new CCError('got empty "redirected_statement" AST node');
      }
      let redirects;
      [command, ...redirects] = n.namedChildren;
      lastNode = n;
      if (command.type !== "command") {
        throw new CCError('got "redirected_statement" AST node whose first child is not a "command", got ' + command.type + " instead\n" + underlineNode(command, curlCommand));
      }
      if (n.childCount < 2) {
        throw new CCError('got "redirected_statement" AST node with only one child - no redirect');
      }
      if (redirects.length > 1) {
        warnings.push([
          "multiple-redirects",
          "found " + redirects.length + " redirect nodes. Only the first one will be used:\n" + underlineNode(redirects[1], curlCommand)
        ]);
      }
      const redirect = redirects[0];
      if (redirect.type === "file_redirect") {
        stdinFile = toWord(redirect.namedChildren[0], curlCommand, warnings);
      } else if (redirect.type === "heredoc_redirect") {
        if (redirect.namedChildCount < 1) {
          throw new CCError('got "redirected_statement" AST node with heredoc but no heredoc start');
        }
        const heredocStart = redirect.namedChildren[0].text;
        const heredocBody = n.nextNamedSibling;
        lastNode = heredocBody;
        if (!heredocBody) {
          throw new CCError('got "redirected_statement" AST node with no heredoc body');
        }
        if (heredocBody.type !== "heredoc_body") {
          throw new CCError('got "redirected_statement" AST node with heredoc but no heredoc body, got ' + heredocBody.type + " instead");
        }
        if (heredocStart.length) {
          stdin = new Word(heredocBody.text.slice(0, -heredocStart.length));
        } else {
          stdin = new Word(heredocBody.text);
        }
      } else if (redirect.type === "herestring_redirect") {
        if (redirect.namedChildCount < 1 || !redirect.firstNamedChild) {
          throw new CCError('got "redirected_statement" AST node with empty herestring');
        }
        stdin = new Word(redirect.firstNamedChild.text);
      } else {
        throw new CCError('got "redirected_statement" AST node whose second child is not one of "file_redirect", "heredoc_redirect" or "herestring_redirect", got ' + command.type + " instead");
      }
      break;
    } else if (n.type === "ERROR") {
      throw new CCError(`Bash parsing error on line ${n.startPosition.row + 1}:
` + underlineNode(n, curlCommand));
    } else {
      throw new CCError('expected a "command" or "redirected_statement" AST node, instead got ' + ast.rootNode.children[0].type + "\n" + underlineNode(ast.rootNode.children[0], curlCommand));
    }
  }
  if (lastNode && lastNode.nextNamedSibling) {
    warnings.push([
      "extra-commands",
      `curl command ends on line ${lastNode.endPosition.row + 1}, everything after this is ignored:
` + underlineNodeEnd(lastNode, curlCommand)
    ]);
    const curlCommandLines = curlCommand.split("\n");
    const lastNodeLine = curlCommandLines[lastNode.endPosition.row];
    const impromperBackslash = lastNodeLine.match(/\\\s+$/);
    if (impromperBackslash && curlCommandLines.length > lastNode.endPosition.row + 1 && impromperBackslash.index !== void 0) {
      warnings.push([
        "unescaped-newline",
        "The trailling '\\' on line " + (lastNode.endPosition.row + 1) + " is followed by whitespace, so it won't escape the newline after it:\n" + lastNodeLine + "\n" + " ".repeat(impromperBackslash.index) + "^".repeat(impromperBackslash[0].length)
      ]);
    }
  }
  if (!command) {
    throw new CCError('expected a "command" or "redirected_statement" AST node, only found "comment" nodes');
  }
  return [command, stdin, stdinFile];
}
function tokenize(curlCommand, warnings = []) {
  const ast = webParser_default.parse(curlCommand);
  const [command, stdin, stdinFile] = findFirstCommandNode(ast, curlCommand, warnings);
  if (command.childCount < 1) {
    throw new CCError('empty "command" node');
  }
  let commandNameLoc = 0;
  for (const n of command.namedChildren) {
    if (n.type === "variable_assignment" || n.type === "file_redirect") {
      warnings.push([
        "command-preamble",
        "skipping " + JSON.stringify(n.type) + " expression\n" + underlineNode(n, curlCommand)
      ]);
      commandNameLoc += 1;
    } else {
      if (n.type !== "command_name") {
        throw new CCError('expected "command_name", "variable_assignment" or "file_redirect" AST node, found ' + n.type + " instead\n" + underlineNode(n, curlCommand));
      }
      break;
    }
  }
  const [name, ...args] = command.namedChildren.slice(commandNameLoc);
  if (name === void 0) {
    throw new CCError('found "command" AST node with no "command_name" child\n' + underlineNode(command, curlCommand));
  }
  if (name.childCount < 1 || !name.firstChild) {
    throw new CCError('found empty "command_name" AST node\n' + underlineNode(name, curlCommand));
  } else if (name.childCount > 1) {
    warnings.push([
      "extra-command_name-children",
      'expected "command_name" node to only have one child but it has ' + name.childCount
    ]);
  }
  const nameWord = toWord(name.firstChild, curlCommand, warnings);
  const nameWordStr = nameWord.toString();
  const cmdNameShellToken = firstShellToken(nameWord);
  if (cmdNameShellToken) {
    if (nameWordStr !== "$curl") {
      throw new CCError("expected command name to be a simple value but found a " + cmdNameShellToken.type + "\n" + underlineNode(cmdNameShellToken.syntaxNode, curlCommand));
    }
  } else if (nameWordStr.trim() !== "curl") {
    const c = nameWordStr.trim();
    if (!c) {
      throw new CCError("found command without a command_name");
    }
    throw new CCError('command should begin with "curl" but instead begins with ' + JSON.stringify(clip(c)));
  }
  return [
    [nameWord, ...args.map((a) => toWord(a, curlCommand, warnings))],
    stdin,
    stdinFile
  ];
}

// node_modules/curlconverter/dist/src/curl/auth.js
var CURLAUTH_BASIC = 1 << 0;
var CURLAUTH_DIGEST = 1 << 1;
var CURLAUTH_NEGOTIATE = 1 << 2;
var CURLAUTH_NTLM = 1 << 3;
var CURLAUTH_DIGEST_IE = 1 << 4;
var CURLAUTH_NTLM_WB = 1 << 5;
var CURLAUTH_BEARER = 1 << 6;
var CURLAUTH_AWS_SIGV4 = 1 << 7;
var CURLAUTH_ANY = ~CURLAUTH_DIGEST_IE;
function pickAuth(mask) {
  if (mask === CURLAUTH_ANY) {
    return "basic";
  }
  const auths = [
    [CURLAUTH_NEGOTIATE, "negotiate"],
    [CURLAUTH_BEARER, "bearer"],
    [CURLAUTH_DIGEST, "digest"],
    [CURLAUTH_NTLM, "ntlm"],
    [CURLAUTH_NTLM_WB, "ntlm-wb"],
    [CURLAUTH_BASIC, "basic"],
    [CURLAUTH_AWS_SIGV4, "aws-sigv4"]
  ];
  for (const [auth, authName] of auths) {
    if (mask & auth) {
      return authName;
    }
  }
  return "none";
}

// node_modules/curlconverter/dist/src/curl/opts.js
var curlLongOpts = {
  "url": { type: "string", name: "url" },
  "dns-ipv4-addr": { type: "string", name: "dns-ipv4-addr" },
  "dns-ipv6-addr": { type: "string", name: "dns-ipv6-addr" },
  "random-file": { type: "string", name: "random-file" },
  "egd-file": { type: "string", name: "egd-file" },
  "oauth2-bearer": { type: "string", name: "oauth2-bearer" },
  "connect-timeout": { type: "string", name: "connect-timeout" },
  "doh-url": { type: "string", name: "doh-url" },
  "ciphers": { type: "string", name: "ciphers" },
  "dns-interface": { type: "string", name: "dns-interface" },
  "disable-epsv": { type: "bool", name: "disable-epsv" },
  "no-disable-epsv": { type: "bool", name: "disable-epsv", expand: false },
  "disallow-username-in-url": { type: "bool", name: "disallow-username-in-url" },
  "no-disallow-username-in-url": { type: "bool", name: "disallow-username-in-url", expand: false },
  "epsv": { type: "bool", name: "epsv" },
  "no-epsv": { type: "bool", name: "epsv", expand: false },
  "dns-servers": { type: "string", name: "dns-servers" },
  "trace": { type: "string", name: "trace" },
  "npn": { type: "bool", name: "npn" },
  "no-npn": { type: "bool", name: "npn", expand: false },
  "trace-ascii": { type: "string", name: "trace-ascii" },
  "alpn": { type: "bool", name: "alpn" },
  "no-alpn": { type: "bool", name: "alpn", expand: false },
  "limit-rate": { type: "string", name: "limit-rate" },
  "rate": { type: "string", name: "rate" },
  "compressed": { type: "bool", name: "compressed" },
  "no-compressed": { type: "bool", name: "compressed", expand: false },
  "tr-encoding": { type: "bool", name: "tr-encoding" },
  "no-tr-encoding": { type: "bool", name: "tr-encoding", expand: false },
  "digest": { type: "bool", name: "digest" },
  "no-digest": { type: "bool", name: "digest", expand: false },
  "negotiate": { type: "bool", name: "negotiate" },
  "no-negotiate": { type: "bool", name: "negotiate", expand: false },
  "ntlm": { type: "bool", name: "ntlm" },
  "no-ntlm": { type: "bool", name: "ntlm", expand: false },
  "ntlm-wb": { type: "bool", name: "ntlm-wb" },
  "no-ntlm-wb": { type: "bool", name: "ntlm-wb", expand: false },
  "basic": { type: "bool", name: "basic" },
  "no-basic": { type: "bool", name: "basic", expand: false },
  "anyauth": { type: "bool", name: "anyauth" },
  "no-anyauth": { type: "bool", name: "anyauth", expand: false },
  "wdebug": { type: "bool", name: "wdebug" },
  "no-wdebug": { type: "bool", name: "wdebug", expand: false },
  "ftp-create-dirs": { type: "bool", name: "ftp-create-dirs" },
  "no-ftp-create-dirs": { type: "bool", name: "ftp-create-dirs", expand: false },
  "create-dirs": { type: "bool", name: "create-dirs" },
  "no-create-dirs": { type: "bool", name: "create-dirs", expand: false },
  "create-file-mode": { type: "string", name: "create-file-mode" },
  "max-redirs": { type: "string", name: "max-redirs" },
  "proxy-ntlm": { type: "bool", name: "proxy-ntlm" },
  "no-proxy-ntlm": { type: "bool", name: "proxy-ntlm", expand: false },
  "crlf": { type: "bool", name: "crlf" },
  "no-crlf": { type: "bool", name: "crlf", expand: false },
  "stderr": { type: "string", name: "stderr" },
  "aws-sigv4": { type: "string", name: "aws-sigv4" },
  "interface": { type: "string", name: "interface" },
  "krb": { type: "string", name: "krb" },
  "krb4": { type: "string", name: "krb" },
  "haproxy-protocol": { type: "bool", name: "haproxy-protocol" },
  "no-haproxy-protocol": { type: "bool", name: "haproxy-protocol", expand: false },
  "max-filesize": { type: "string", name: "max-filesize" },
  "disable-eprt": { type: "bool", name: "disable-eprt" },
  "no-disable-eprt": { type: "bool", name: "disable-eprt", expand: false },
  "eprt": { type: "bool", name: "eprt" },
  "no-eprt": { type: "bool", name: "eprt", expand: false },
  "xattr": { type: "bool", name: "xattr" },
  "no-xattr": { type: "bool", name: "xattr", expand: false },
  "ftp-ssl": { type: "bool", name: "ssl" },
  "no-ftp-ssl": { type: "bool", name: "ssl", expand: false },
  "ssl": { type: "bool", name: "ssl" },
  "no-ssl": { type: "bool", name: "ssl", expand: false },
  "ftp-pasv": { type: "bool", name: "ftp-pasv" },
  "no-ftp-pasv": { type: "bool", name: "ftp-pasv", expand: false },
  "socks5": { type: "string", name: "socks5" },
  "tcp-nodelay": { type: "bool", name: "tcp-nodelay" },
  "no-tcp-nodelay": { type: "bool", name: "tcp-nodelay", expand: false },
  "proxy-digest": { type: "bool", name: "proxy-digest" },
  "no-proxy-digest": { type: "bool", name: "proxy-digest", expand: false },
  "proxy-basic": { type: "bool", name: "proxy-basic" },
  "no-proxy-basic": { type: "bool", name: "proxy-basic", expand: false },
  "retry": { type: "string", name: "retry" },
  "retry-connrefused": { type: "bool", name: "retry-connrefused" },
  "no-retry-connrefused": { type: "bool", name: "retry-connrefused", expand: false },
  "retry-delay": { type: "string", name: "retry-delay" },
  "retry-max-time": { type: "string", name: "retry-max-time" },
  "proxy-negotiate": { type: "bool", name: "proxy-negotiate" },
  "no-proxy-negotiate": { type: "bool", name: "proxy-negotiate", expand: false },
  "form-escape": { type: "bool", name: "form-escape" },
  "no-form-escape": { type: "bool", name: "form-escape", expand: false },
  "ftp-account": { type: "string", name: "ftp-account" },
  "proxy-anyauth": { type: "bool", name: "proxy-anyauth" },
  "no-proxy-anyauth": { type: "bool", name: "proxy-anyauth", expand: false },
  "trace-time": { type: "bool", name: "trace-time" },
  "no-trace-time": { type: "bool", name: "trace-time", expand: false },
  "ignore-content-length": { type: "bool", name: "ignore-content-length" },
  "no-ignore-content-length": { type: "bool", name: "ignore-content-length", expand: false },
  "ftp-skip-pasv-ip": { type: "bool", name: "ftp-skip-pasv-ip" },
  "no-ftp-skip-pasv-ip": { type: "bool", name: "ftp-skip-pasv-ip", expand: false },
  "ftp-method": { type: "string", name: "ftp-method" },
  "local-port": { type: "string", name: "local-port" },
  "socks4": { type: "string", name: "socks4" },
  "socks4a": { type: "string", name: "socks4a" },
  "ftp-alternative-to-user": { type: "string", name: "ftp-alternative-to-user" },
  "ftp-ssl-reqd": { type: "bool", name: "ssl-reqd" },
  "no-ftp-ssl-reqd": { type: "bool", name: "ssl-reqd", expand: false },
  "ssl-reqd": { type: "bool", name: "ssl-reqd" },
  "no-ssl-reqd": { type: "bool", name: "ssl-reqd", expand: false },
  "sessionid": { type: "bool", name: "sessionid" },
  "no-sessionid": { type: "bool", name: "sessionid", expand: false },
  "ftp-ssl-control": { type: "bool", name: "ftp-ssl-control" },
  "no-ftp-ssl-control": { type: "bool", name: "ftp-ssl-control", expand: false },
  "ftp-ssl-ccc": { type: "bool", name: "ftp-ssl-ccc" },
  "no-ftp-ssl-ccc": { type: "bool", name: "ftp-ssl-ccc", expand: false },
  "ftp-ssl-ccc-mode": { type: "string", name: "ftp-ssl-ccc-mode" },
  "libcurl": { type: "string", name: "libcurl" },
  "raw": { type: "bool", name: "raw" },
  "no-raw": { type: "bool", name: "raw", expand: false },
  "post301": { type: "bool", name: "post301" },
  "no-post301": { type: "bool", name: "post301", expand: false },
  "keepalive": { type: "bool", name: "keepalive" },
  "no-keepalive": { type: "bool", name: "keepalive", expand: false },
  "socks5-hostname": { type: "string", name: "socks5-hostname" },
  "keepalive-time": { type: "string", name: "keepalive-time" },
  "post302": { type: "bool", name: "post302" },
  "no-post302": { type: "bool", name: "post302", expand: false },
  "noproxy": { type: "string", name: "noproxy" },
  "socks5-gssapi-nec": { type: "bool", name: "socks5-gssapi-nec" },
  "no-socks5-gssapi-nec": { type: "bool", name: "socks5-gssapi-nec", expand: false },
  "proxy1.0": { type: "string", name: "proxy1.0" },
  "tftp-blksize": { type: "string", name: "tftp-blksize" },
  "mail-from": { type: "string", name: "mail-from" },
  "mail-rcpt": { type: "string", name: "mail-rcpt" },
  "ftp-pret": { type: "bool", name: "ftp-pret" },
  "no-ftp-pret": { type: "bool", name: "ftp-pret", expand: false },
  "proto": { type: "string", name: "proto" },
  "proto-redir": { type: "string", name: "proto-redir" },
  "resolve": { type: "string", name: "resolve" },
  "delegation": { type: "string", name: "delegation" },
  "mail-auth": { type: "string", name: "mail-auth" },
  "post303": { type: "bool", name: "post303" },
  "no-post303": { type: "bool", name: "post303", expand: false },
  "metalink": { type: "bool", name: "metalink" },
  "no-metalink": { type: "bool", name: "metalink", expand: false },
  "sasl-authzid": { type: "string", name: "sasl-authzid" },
  "sasl-ir": { type: "bool", name: "sasl-ir" },
  "no-sasl-ir": { type: "bool", name: "sasl-ir", expand: false },
  "test-event": { type: "bool", name: "test-event" },
  "no-test-event": { type: "bool", name: "test-event", expand: false },
  "unix-socket": { type: "string", name: "unix-socket" },
  "path-as-is": { type: "bool", name: "path-as-is" },
  "no-path-as-is": { type: "bool", name: "path-as-is", expand: false },
  "socks5-gssapi-service": { type: "string", name: "proxy-service-name" },
  "proxy-service-name": { type: "string", name: "proxy-service-name" },
  "service-name": { type: "string", name: "service-name" },
  "proto-default": { type: "string", name: "proto-default" },
  "expect100-timeout": { type: "string", name: "expect100-timeout" },
  "tftp-no-options": { type: "bool", name: "tftp-no-options" },
  "no-tftp-no-options": { type: "bool", name: "tftp-no-options", expand: false },
  "connect-to": { type: "string", name: "connect-to" },
  "abstract-unix-socket": { type: "string", name: "abstract-unix-socket" },
  "tls-max": { type: "string", name: "tls-max" },
  "suppress-connect-headers": { type: "bool", name: "suppress-connect-headers" },
  "no-suppress-connect-headers": { type: "bool", name: "suppress-connect-headers", expand: false },
  "compressed-ssh": { type: "bool", name: "compressed-ssh" },
  "no-compressed-ssh": { type: "bool", name: "compressed-ssh", expand: false },
  "happy-eyeballs-timeout-ms": { type: "string", name: "happy-eyeballs-timeout-ms" },
  "retry-all-errors": { type: "bool", name: "retry-all-errors" },
  "no-retry-all-errors": { type: "bool", name: "retry-all-errors", expand: false },
  "http1.0": { type: "bool", name: "http1.0" },
  "http1.1": { type: "bool", name: "http1.1" },
  "http2": { type: "bool", name: "http2" },
  "http2-prior-knowledge": { type: "bool", name: "http2-prior-knowledge" },
  "http3": { type: "bool", name: "http3" },
  "http3-only": { type: "bool", name: "http3-only" },
  "http0.9": { type: "bool", name: "http0.9" },
  "no-http0.9": { type: "bool", name: "http0.9", expand: false },
  "tlsv1": { type: "bool", name: "tlsv1" },
  "tlsv1.0": { type: "bool", name: "tlsv1.0" },
  "tlsv1.1": { type: "bool", name: "tlsv1.1" },
  "tlsv1.2": { type: "bool", name: "tlsv1.2" },
  "tlsv1.3": { type: "bool", name: "tlsv1.3" },
  "tls13-ciphers": { type: "string", name: "tls13-ciphers" },
  "proxy-tls13-ciphers": { type: "string", name: "proxy-tls13-ciphers" },
  "sslv2": { type: "bool", name: "sslv2" },
  "sslv3": { type: "bool", name: "sslv3" },
  "ipv4": { type: "bool", name: "ipv4" },
  "ipv6": { type: "bool", name: "ipv6" },
  "append": { type: "bool", name: "append" },
  "no-append": { type: "bool", name: "append", expand: false },
  "user-agent": { type: "string", name: "user-agent" },
  "cookie": { type: "string", name: "cookie" },
  "alt-svc": { type: "string", name: "alt-svc" },
  "hsts": { type: "string", name: "hsts" },
  "use-ascii": { type: "bool", name: "use-ascii" },
  "no-use-ascii": { type: "bool", name: "use-ascii", expand: false },
  "cookie-jar": { type: "string", name: "cookie-jar" },
  "continue-at": { type: "string", name: "continue-at" },
  "data": { type: "string", name: "data" },
  "data-raw": { type: "string", name: "data-raw" },
  "data-ascii": { type: "string", name: "data-ascii" },
  "data-binary": { type: "string", name: "data-binary" },
  "data-urlencode": { type: "string", name: "data-urlencode" },
  "json": { type: "string", name: "json" },
  "url-query": { type: "string", name: "url-query" },
  "dump-header": { type: "string", name: "dump-header" },
  "referer": { type: "string", name: "referer" },
  "cert": { type: "string", name: "cert" },
  "cacert": { type: "string", name: "cacert" },
  "cert-type": { type: "string", name: "cert-type" },
  "key": { type: "string", name: "key" },
  "key-type": { type: "string", name: "key-type" },
  "pass": { type: "string", name: "pass" },
  "engine": { type: "string", name: "engine" },
  "capath": { type: "string", name: "capath" },
  "pubkey": { type: "string", name: "pubkey" },
  "hostpubmd5": { type: "string", name: "hostpubmd5" },
  "hostpubsha256": { type: "string", name: "hostpubsha256" },
  "crlfile": { type: "string", name: "crlfile" },
  "tlsuser": { type: "string", name: "tlsuser" },
  "tlspassword": { type: "string", name: "tlspassword" },
  "tlsauthtype": { type: "string", name: "tlsauthtype" },
  "ssl-allow-beast": { type: "bool", name: "ssl-allow-beast" },
  "no-ssl-allow-beast": { type: "bool", name: "ssl-allow-beast", expand: false },
  "ssl-auto-client-cert": { type: "bool", name: "ssl-auto-client-cert" },
  "no-ssl-auto-client-cert": { type: "bool", name: "ssl-auto-client-cert", expand: false },
  "proxy-ssl-auto-client-cert": { type: "bool", name: "proxy-ssl-auto-client-cert" },
  "no-proxy-ssl-auto-client-cert": { type: "bool", name: "proxy-ssl-auto-client-cert", expand: false },
  "pinnedpubkey": { type: "string", name: "pinnedpubkey" },
  "proxy-pinnedpubkey": { type: "string", name: "proxy-pinnedpubkey" },
  "cert-status": { type: "bool", name: "cert-status" },
  "no-cert-status": { type: "bool", name: "cert-status", expand: false },
  "doh-cert-status": { type: "bool", name: "doh-cert-status" },
  "no-doh-cert-status": { type: "bool", name: "doh-cert-status", expand: false },
  "false-start": { type: "bool", name: "false-start" },
  "no-false-start": { type: "bool", name: "false-start", expand: false },
  "ssl-no-revoke": { type: "bool", name: "ssl-no-revoke" },
  "no-ssl-no-revoke": { type: "bool", name: "ssl-no-revoke", expand: false },
  "ssl-revoke-best-effort": { type: "bool", name: "ssl-revoke-best-effort" },
  "no-ssl-revoke-best-effort": { type: "bool", name: "ssl-revoke-best-effort", expand: false },
  "tcp-fastopen": { type: "bool", name: "tcp-fastopen" },
  "no-tcp-fastopen": { type: "bool", name: "tcp-fastopen", expand: false },
  "proxy-tlsuser": { type: "string", name: "proxy-tlsuser" },
  "proxy-tlspassword": { type: "string", name: "proxy-tlspassword" },
  "proxy-tlsauthtype": { type: "string", name: "proxy-tlsauthtype" },
  "proxy-cert": { type: "string", name: "proxy-cert" },
  "proxy-cert-type": { type: "string", name: "proxy-cert-type" },
  "proxy-key": { type: "string", name: "proxy-key" },
  "proxy-key-type": { type: "string", name: "proxy-key-type" },
  "proxy-pass": { type: "string", name: "proxy-pass" },
  "proxy-ciphers": { type: "string", name: "proxy-ciphers" },
  "proxy-crlfile": { type: "string", name: "proxy-crlfile" },
  "proxy-ssl-allow-beast": { type: "bool", name: "proxy-ssl-allow-beast" },
  "no-proxy-ssl-allow-beast": { type: "bool", name: "proxy-ssl-allow-beast", expand: false },
  "login-options": { type: "string", name: "login-options" },
  "proxy-cacert": { type: "string", name: "proxy-cacert" },
  "proxy-capath": { type: "string", name: "proxy-capath" },
  "proxy-insecure": { type: "bool", name: "proxy-insecure" },
  "no-proxy-insecure": { type: "bool", name: "proxy-insecure", expand: false },
  "proxy-tlsv1": { type: "bool", name: "proxy-tlsv1" },
  "socks5-basic": { type: "bool", name: "socks5-basic" },
  "no-socks5-basic": { type: "bool", name: "socks5-basic", expand: false },
  "socks5-gssapi": { type: "bool", name: "socks5-gssapi" },
  "no-socks5-gssapi": { type: "bool", name: "socks5-gssapi", expand: false },
  "etag-save": { type: "string", name: "etag-save" },
  "etag-compare": { type: "string", name: "etag-compare" },
  "curves": { type: "string", name: "curves" },
  "fail": { type: "bool", name: "fail" },
  "no-fail": { type: "bool", name: "fail", expand: false },
  "fail-early": { type: "bool", name: "fail-early" },
  "no-fail-early": { type: "bool", name: "fail-early", expand: false },
  "styled-output": { type: "bool", name: "styled-output" },
  "no-styled-output": { type: "bool", name: "styled-output", expand: false },
  "mail-rcpt-allowfails": { type: "bool", name: "mail-rcpt-allowfails" },
  "no-mail-rcpt-allowfails": { type: "bool", name: "mail-rcpt-allowfails", expand: false },
  "fail-with-body": { type: "bool", name: "fail-with-body" },
  "no-fail-with-body": { type: "bool", name: "fail-with-body", expand: false },
  "remove-on-error": { type: "bool", name: "remove-on-error" },
  "no-remove-on-error": { type: "bool", name: "remove-on-error", expand: false },
  "form": { type: "string", name: "form" },
  "form-string": { type: "string", name: "form-string" },
  "globoff": { type: "bool", name: "globoff" },
  "no-globoff": { type: "bool", name: "globoff", expand: false },
  "get": { type: "bool", name: "get" },
  "request-target": { type: "string", name: "request-target" },
  "help": { type: "bool", name: "help" },
  "no-help": { type: "bool", name: "help", expand: false },
  "header": { type: "string", name: "header" },
  "proxy-header": { type: "string", name: "proxy-header" },
  "include": { type: "bool", name: "include" },
  "no-include": { type: "bool", name: "include", expand: false },
  "head": { type: "bool", name: "head" },
  "no-head": { type: "bool", name: "head", expand: false },
  "junk-session-cookies": { type: "bool", name: "junk-session-cookies" },
  "no-junk-session-cookies": { type: "bool", name: "junk-session-cookies", expand: false },
  "remote-header-name": { type: "bool", name: "remote-header-name" },
  "no-remote-header-name": { type: "bool", name: "remote-header-name", expand: false },
  "insecure": { type: "bool", name: "insecure" },
  "no-insecure": { type: "bool", name: "insecure", expand: false },
  "doh-insecure": { type: "bool", name: "doh-insecure" },
  "no-doh-insecure": { type: "bool", name: "doh-insecure", expand: false },
  "config": { type: "string", name: "config" },
  "list-only": { type: "bool", name: "list-only" },
  "no-list-only": { type: "bool", name: "list-only", expand: false },
  "location": { type: "bool", name: "location" },
  "no-location": { type: "bool", name: "location", expand: false },
  "location-trusted": { type: "bool", name: "location-trusted" },
  "no-location-trusted": { type: "bool", name: "location-trusted", expand: false },
  "max-time": { type: "string", name: "max-time" },
  "manual": { type: "bool", name: "manual" },
  "no-manual": { type: "bool", name: "manual", expand: false },
  "netrc": { type: "bool", name: "netrc" },
  "no-netrc": { type: "bool", name: "netrc", expand: false },
  "netrc-optional": { type: "bool", name: "netrc-optional" },
  "no-netrc-optional": { type: "bool", name: "netrc-optional", expand: false },
  "netrc-file": { type: "string", name: "netrc-file" },
  "buffer": { type: "bool", name: "buffer" },
  "no-buffer": { type: "bool", name: "buffer", expand: false },
  "output": { type: "string", name: "output" },
  "remote-name": { type: "bool", name: "remote-name" },
  "no-remote-name": { type: "bool", name: "remote-name", expand: false },
  "remote-name-all": { type: "bool", name: "remote-name-all" },
  "no-remote-name-all": { type: "bool", name: "remote-name-all", expand: false },
  "output-dir": { type: "string", name: "output-dir" },
  "clobber": { type: "bool", name: "clobber" },
  "no-clobber": { type: "bool", name: "clobber", expand: false },
  "proxytunnel": { type: "bool", name: "proxytunnel" },
  "no-proxytunnel": { type: "bool", name: "proxytunnel", expand: false },
  "ftp-port": { type: "string", name: "ftp-port" },
  "disable": { type: "bool", name: "disable" },
  "no-disable": { type: "bool", name: "disable", expand: false },
  "quote": { type: "string", name: "quote" },
  "range": { type: "string", name: "range" },
  "remote-time": { type: "bool", name: "remote-time" },
  "no-remote-time": { type: "bool", name: "remote-time", expand: false },
  "silent": { type: "bool", name: "silent" },
  "no-silent": { type: "bool", name: "silent", expand: false },
  "show-error": { type: "bool", name: "show-error" },
  "no-show-error": { type: "bool", name: "show-error", expand: false },
  "telnet-option": { type: "string", name: "telnet-option" },
  "upload-file": { type: "string", name: "upload-file" },
  "user": { type: "string", name: "user" },
  "proxy-user": { type: "string", name: "proxy-user" },
  "verbose": { type: "bool", name: "verbose" },
  "no-verbose": { type: "bool", name: "verbose", expand: false },
  "version": { type: "bool", name: "version" },
  "no-version": { type: "bool", name: "version", expand: false },
  "write-out": { type: "string", name: "write-out" },
  "proxy": { type: "string", name: "proxy" },
  "preproxy": { type: "string", name: "preproxy" },
  "request": { type: "string", name: "request" },
  "speed-limit": { type: "string", name: "speed-limit" },
  "speed-time": { type: "string", name: "speed-time" },
  "time-cond": { type: "string", name: "time-cond" },
  "parallel": { type: "bool", name: "parallel" },
  "no-parallel": { type: "bool", name: "parallel", expand: false },
  "parallel-max": { type: "string", name: "parallel-max" },
  "parallel-immediate": { type: "bool", name: "parallel-immediate" },
  "no-parallel-immediate": { type: "bool", name: "parallel-immediate", expand: false },
  "progress-bar": { type: "bool", name: "progress-bar" },
  "no-progress-bar": { type: "bool", name: "progress-bar", expand: false },
  "progress-meter": { type: "bool", name: "progress-meter" },
  "no-progress-meter": { type: "bool", name: "progress-meter", expand: false },
  "next": { type: "bool", name: "next" },
  port: { type: "string", name: "port", removed: "7.3" },
  "ftp-ascii": { type: "bool", name: "use-ascii", removed: "7.10.7" },
  "3p-url": { type: "string", name: "3p-url", removed: "7.16.0" },
  "3p-user": { type: "string", name: "3p-user", removed: "7.16.0" },
  "3p-quote": { type: "string", name: "3p-quote", removed: "7.16.0" },
  "http2.0": { type: "bool", name: "http2", removed: "7.36.0" },
  "no-http2.0": { type: "bool", name: "http2", removed: "7.36.0" },
  "telnet-options": { type: "string", name: "telnet-option", removed: "7.49.0" },
  "http-request": { type: "string", name: "request", removed: "7.49.0" },
  "capath ": { type: "string", name: "capath", removed: "7.49.0" },
  ftpport: { type: "string", name: "ftp-port", removed: "7.49.0" },
  environment: { type: "bool", name: "environment", removed: "7.54.1" },
  "no-tlsv1": { type: "bool", name: "tlsv1", removed: "7.54.1" },
  "no-tlsv1.2": { type: "bool", name: "tlsv1.2", removed: "7.54.1" },
  "no-http2-prior-knowledge": { type: "bool", name: "http2-prior-knowledge", removed: "7.54.1" },
  "no-ipv6": { type: "bool", name: "ipv6", removed: "7.54.1" },
  "no-ipv4": { type: "bool", name: "ipv4", removed: "7.54.1" },
  "no-sslv2": { type: "bool", name: "sslv2", removed: "7.54.1" },
  "no-tlsv1.0": { type: "bool", name: "tlsv1.0", removed: "7.54.1" },
  "no-tlsv1.1": { type: "bool", name: "tlsv1.1", removed: "7.54.1" },
  "no-sslv3": { type: "bool", name: "sslv3", removed: "7.54.1" },
  "no-get": { type: "bool", name: "get", removed: "7.54.1" },
  "no-http1.0": { type: "bool", name: "http1.0", removed: "7.54.1" },
  "no-next": { type: "bool", name: "next", removed: "7.54.1" },
  "no-tlsv1.3": { type: "bool", name: "tlsv1.3", removed: "7.54.1" },
  "no-environment": { type: "bool", name: "environment", removed: "7.54.1" },
  "no-http1.1": { type: "bool", name: "http1.1", removed: "7.54.1" },
  "no-proxy-tlsv1": { type: "bool", name: "proxy-tlsv1", removed: "7.54.1" },
  "no-http2": { type: "bool", name: "http2", removed: "7.54.1" }
};
var shortened = {};
for (const [opt, val] of Object.entries(curlLongOpts)) {
  if (val === null) {
    continue;
  }
  const expand = val.expand === void 0 ? true : val.expand;
  delete val.expand;
  if (expand && !val.removed) {
    for (let i = 1; i < opt.length; i++) {
      const shortenedOpt = opt.slice(0, i);
      if (!Object.prototype.hasOwnProperty.call(shortened, shortenedOpt)) {
        shortened[shortenedOpt] = val;
      } else {
        shortened[shortenedOpt] = null;
      }
    }
  }
}
for (const shortenedOpt of Object.keys(shortened)) {
  if (!Object.prototype.hasOwnProperty.call(curlLongOpts, shortenedOpt)) {
    curlLongOpts[shortenedOpt] = shortened[shortenedOpt];
  }
}
var COMMON_SUPPORTED_ARGS = [
  "url",
  "proto-default",
  "request",
  "get",
  "head",
  "no-head",
  "header",
  "user-agent",
  "referer",
  "range",
  "time-cond",
  "cookie",
  "oauth2-bearer",
  "user",
  "basic",
  "no-basic",
  "data",
  "data-raw",
  "data-ascii",
  "data-binary",
  "data-urlencode",
  "json",
  "url-query",
  "globoff"
];
var ignoredArgs = /* @__PURE__ */ new Set([
  "help",
  "no-help",
  "silent",
  "no-silent",
  "verbose",
  "no-verbose",
  "version",
  "no-version",
  "progress-bar",
  "no-progress-bar",
  "progress-meter",
  "no-progress-meter",
  "show-error",
  "no-show-error"
]);
function toBoolean(opt) {
  if (opt.startsWith("no-disable-")) {
    return true;
  }
  if (opt.startsWith("disable-") || opt.startsWith("no-")) {
    return false;
  }
  return true;
}
var curlShortOpts = {
  "0": "http1.0",
  "1": "tlsv1",
  "2": "sslv2",
  "3": "sslv3",
  "4": "ipv4",
  "6": "ipv6",
  "a": "append",
  "A": "user-agent",
  "b": "cookie",
  "B": "use-ascii",
  "c": "cookie-jar",
  "C": "continue-at",
  "d": "data",
  "D": "dump-header",
  "e": "referer",
  "E": "cert",
  "f": "fail",
  "F": "form",
  "g": "globoff",
  "G": "get",
  "h": "help",
  "H": "header",
  "i": "include",
  "I": "head",
  "j": "junk-session-cookies",
  "J": "remote-header-name",
  "k": "insecure",
  "K": "config",
  "l": "list-only",
  "L": "location",
  "m": "max-time",
  "M": "manual",
  "n": "netrc",
  "N": "no-buffer",
  "o": "output",
  "O": "remote-name",
  "p": "proxytunnel",
  "P": "ftp-port",
  "q": "disable",
  "Q": "quote",
  "r": "range",
  "R": "remote-time",
  "s": "silent",
  "S": "show-error",
  "t": "telnet-option",
  "T": "upload-file",
  "u": "user",
  "U": "proxy-user",
  "v": "verbose",
  "V": "version",
  "w": "write-out",
  "x": "proxy",
  "X": "request",
  "Y": "speed-limit",
  "y": "speed-time",
  "z": "time-cond",
  "Z": "parallel",
  "#": "progress-bar",
  ":": "next"
};
var changedShortOpts = {
  p: "used to be short for --port <port> (a since-deleted flag) until curl 7.3",
  t: "used to be short for --upload (a since-deleted boolean flag) until curl 7.7",
  c: "used to be short for --continue (a since-deleted boolean flag) until curl 7.9",
  "@": "used to be short for --create-dirs until curl 7.10.7",
  Z: "used to be short for --max-redirs <num> until curl 7.10.7",
  9: "used to be short for --crlf until curl 7.10.8",
  8: "used to be short for --stderr <file> until curl 7.10.8",
  7: "used to be short for --interface <name> until curl 7.10.8",
  6: "used to be short for --krb <level> (which itself used to be --krb4 <level>) until curl 7.10.8",
  5: "used to be another way to specify the url until curl 7.10.8",
  "*": "used to be another way to specify the url until curl 7.49.0",
  "~": "used to be short for --xattr until curl 7.49.0"
};
var canBeList = /* @__PURE__ */ new Set([
  "url",
  "upload-file",
  "output",
  "header",
  "proxy-header",
  "form",
  "data",
  "url-query",
  "mail-rcpt",
  "resolve",
  "connect-to",
  "cookie",
  "quote",
  "telnet-option",
  "authArgs"
]);
function checkSupported(global, lookup, longArg, supportedOpts) {
  if (supportedOpts && !supportedOpts.has(longArg.name) && !ignoredArgs.has(longArg.name)) {
    warnf(global, [
      longArg.name,
      "--" + lookup + " is not a supported option" + (longArg.removed ? ", it was removed in curl " + longArg.removed : "")
    ]);
  }
}
function pushProp(obj, prop, value) {
  if (!Object.prototype.hasOwnProperty.call(obj, prop)) {
    obj[prop] = [];
  }
  obj[prop].push(value);
  return obj;
}
function pushArgValue(global, config2, argName, value) {
  switch (argName) {
    case "data":
    case "data-ascii":
      return pushProp(config2, "data", ["data", value]);
    case "data-binary":
      return pushProp(config2, "data", [
        value.startsWith("@") ? "binary" : "data",
        value
      ]);
    case "data-raw":
      return pushProp(config2, "data", [
        value.startsWith("@") ? "raw" : "data",
        value
      ]);
    case "data-urlencode":
      return pushProp(config2, "data", ["urlencode", value]);
    case "json":
      config2.json = true;
      return pushProp(config2, "data", ["json", value]);
    case "url-query":
      if (value.startsWith("+")) {
        return pushProp(config2, "url-query", ["raw", value.slice(1)]);
      }
      return pushProp(config2, "url-query", ["urlencode", value]);
    case "form":
      return pushProp(config2, "form", { value, type: "form" });
    case "form-string":
      return pushProp(config2, "form", { value, type: "string" });
    case "aws-sigv4":
      pushProp(config2, "authArgs", [argName, true]);
      config2.authtype |= CURLAUTH_AWS_SIGV4;
      break;
    case "oauth2-bearer":
      pushProp(config2, "authArgs", [argName, true]);
      config2.authtype |= CURLAUTH_BEARER;
      break;
    case "language":
      global[argName] = value.toString();
      return;
  }
  return pushProp(config2, argName, value);
}
function setArgValue(global, config2, argName, toggle) {
  switch (argName) {
    case "digest":
      pushProp(config2, "authArgs", [argName, toggle]);
      if (toggle) {
        config2.authtype |= CURLAUTH_DIGEST;
      } else {
        config2.authtype &= ~CURLAUTH_DIGEST;
      }
      break;
    case "negotiate":
      pushProp(config2, "authArgs", [argName, toggle]);
      if (toggle) {
        config2.authtype |= CURLAUTH_NEGOTIATE;
      } else {
        config2.authtype &= ~CURLAUTH_NEGOTIATE;
      }
      break;
    case "ntlm":
      pushProp(config2, "authArgs", [argName, toggle]);
      if (toggle) {
        config2.authtype |= CURLAUTH_NTLM;
      } else {
        config2.authtype &= ~CURLAUTH_NTLM;
      }
      break;
    case "ntlm-wb":
      pushProp(config2, "authArgs", [argName, toggle]);
      if (toggle) {
        config2.authtype |= CURLAUTH_NTLM_WB;
      } else {
        config2.authtype &= ~CURLAUTH_NTLM_WB;
      }
      break;
    case "basic":
      pushProp(config2, "authArgs", [argName, toggle]);
      if (toggle) {
        config2.authtype |= CURLAUTH_BASIC;
      } else {
        config2.authtype &= ~CURLAUTH_BASIC;
      }
      break;
    case "anyauth":
      pushProp(config2, "authArgs", [argName, toggle]);
      if (toggle) {
        config2.authtype = CURLAUTH_ANY;
      }
      break;
    case "location":
      config2["location"] = toggle;
      break;
    case "location-trusted":
      config2["location"] = toggle;
      config2["location-trusted"] = toggle;
      break;
    case "verbose":
    case "version":
    case "help":
    case "stdin":
      global[argName] = toggle;
      break;
    case "next":
      if (toggle && config2.url && config2.url.length > 0 && config2.url.length >= (config2["upload-file"] || []).length && config2.url.length >= (config2.output || []).length) {
        config2 = { authtype: CURLAUTH_BASIC };
        global.configs.push(config2);
      }
      break;
    default:
      config2[argName] = toggle;
  }
  return config2;
}
function parseArgs(args, longOpts = curlLongOpts, shortOpts = curlShortOpts, supportedOpts, warnings = []) {
  let config2 = { authtype: CURLAUTH_BASIC };
  const global = { configs: [config2], warnings };
  for (let i = 1, stillflags = true; i < args.length; i++) {
    const arg = args[i];
    if (stillflags && arg.startsWith("-")) {
      if (eq(arg, "--")) {
        stillflags = false;
      } else if (arg.startsWith("--")) {
        const shellToken = firstShellToken(arg);
        if (shellToken) {
          throw new CCError("this " + shellToken.type + " could " + (shellToken.type === "command" ? "return" : "be") + " anything\n" + underlineNode(shellToken.syntaxNode));
        }
        const argStr = arg.toString();
        const lookup = argStr.slice(2);
        const longArg = longOpts[lookup];
        if (longArg === null) {
          throw new CCError("option " + argStr + ": is ambiguous");
        }
        if (typeof longArg === "undefined") {
          throw new CCError("option " + argStr + ": is unknown");
        }
        if (longArg.type === "string") {
          i++;
          if (i >= args.length) {
            throw new CCError("option " + argStr + ": requires parameter");
          }
          pushArgValue(global, config2, longArg.name, args[i]);
        } else {
          config2 = setArgValue(global, config2, longArg.name, toBoolean(argStr.slice(2)));
        }
        checkSupported(global, lookup, longArg, supportedOpts);
      } else {
        if (arg.length === 1) {
          if (Object.prototype.hasOwnProperty.call(shortOpts, "")) {
            const shortFor = shortOpts[""];
            const longArg = longOpts[shortFor];
            if (longArg === null) {
              throw new CCError("option -: is unknown");
            }
            config2 = setArgValue(global, config2, longArg.name, toBoolean(shortFor));
          } else {
            throw new CCError("option -: is unknown");
          }
        }
        for (let j = 1; j < arg.length; j++) {
          const jthChar = arg.get(j);
          if (typeof jthChar !== "string") {
            throw new CCError("this " + jthChar.type + " could " + (jthChar.type === "command" ? "return" : "be") + " anything\n" + underlineNode(jthChar.syntaxNode));
          }
          if (!has(shortOpts, jthChar)) {
            if (has(changedShortOpts, jthChar)) {
              throw new CCError("option " + arg + ": " + changedShortOpts[jthChar]);
            }
            throw new CCError("option " + arg + ": is unknown");
          }
          const lookup = jthChar;
          const shortFor = shortOpts[lookup];
          const longArg = longOpts[shortFor];
          if (longArg === null) {
            throw new CCError("ambiguous short option -" + jthChar);
          }
          if (longArg.type === "string") {
            let val;
            if (j + 1 < arg.length) {
              val = arg.slice(j + 1);
              j = arg.length;
            } else if (i + 1 < args.length) {
              i++;
              val = args[i];
            } else {
              throw new CCError("option " + arg.toString() + ": requires parameter");
            }
            pushArgValue(global, config2, longArg.name, val);
          } else {
            config2 = setArgValue(global, config2, longArg.name, toBoolean(shortFor));
          }
          if (lookup) {
            checkSupported(global, lookup, longArg, supportedOpts);
          }
        }
      }
    } else {
      if (typeof arg !== "string" && arg.tokens.length && typeof arg.tokens[0] !== "string") {
        const isOrBeginsWith = arg.tokens.length === 1 ? "is" : "begins with";
        warnings.push([
          "ambiguous argument",
          "argument " + isOrBeginsWith + " a " + arg.tokens[0].type + ", assuming it's a URL\n" + underlineNode(arg.tokens[0].syntaxNode)
        ]);
      }
      pushArgValue(global, config2, "url", arg);
    }
  }
  for (const cfg of global.configs) {
    for (const [arg, values] of Object.entries(cfg)) {
      if (Array.isArray(values) && !canBeList.has(arg)) {
        cfg[arg] = values[values.length - 1];
      }
    }
  }
  return global;
}

// node_modules/curlconverter/dist/src/Headers.js
var COMMA_SEPARATED = new Set([
  "A-IM",
  "Accept",
  "Accept-Charset",
  "Accept-Encoding",
  "Accept-Language",
  "Access-Control-Request-Headers",
  "Cache-Control",
  "Connection",
  "Content-Encoding",
  "Expect",
  "Forwarded",
  "If-Match",
  "If-None-Match",
  "Range",
  "TE",
  "Trailer",
  "Transfer-Encoding",
  "Upgrade",
  "Via",
  "Warning"
].map((h) => h.toLowerCase()));
var SEMICOLON_SEPARATED = new Set(["Content-Type", "Cookie", "Prefer"].map((h) => h.toLowerCase()));
var Headers = class {
  constructor(headerArgs, warnings = []) {
    let headers = [];
    if (headerArgs) {
      for (const header of headerArgs) {
        if (header.startsWith("@")) {
          warnings.push([
            "header-file",
            "passing a file for --header/-H is not supported: " + JSON.stringify(header.toString())
          ]);
          continue;
        }
        if (header.includes(":")) {
          const [name, value] = header.split(":", 2);
          const nameToken = firstShellToken(name);
          if (nameToken) {
            warnings.push([
              "header-expression",
              "ignoring " + nameToken.type + " in header name\n" + underlineNode(nameToken.syntaxNode)
            ]);
          }
          const hasValue = value && value.trim().toBool();
          const headerValue = hasValue ? value.removeFirstChar(" ") : null;
          headers.push([name, headerValue]);
        } else if (header.includes(";")) {
          const [name] = header.split(";", 2);
          headers.push([name, new Word()]);
        } else {
        }
      }
    }
    this.lowercase = headers.length > 0 && headers.every((h) => eq(h[0], h[0].toLowerCase()));
    const uniqueHeaders = {};
    for (const [name, value] of headers) {
      const lowerName = name.toLowerCase().toString();
      if (!uniqueHeaders[lowerName]) {
        uniqueHeaders[lowerName] = [];
      }
      uniqueHeaders[lowerName].push([name, value]);
    }
    headers = [];
    for (const [lowerName, repeatedHeaders] of Object.entries(uniqueHeaders)) {
      if (repeatedHeaders.length === 1) {
        headers.push(repeatedHeaders[0]);
        continue;
      }
      if (repeatedHeaders.every((h) => h[1] === null)) {
        const lastRepeat = repeatedHeaders[repeatedHeaders.length - 1];
        if (new Set(repeatedHeaders.map((h) => h[0])).size > 1) {
          warnings.push([
            "repeated-header",
            `"${lastRepeat[0]}" header unset ${repeatedHeaders.length} times`
          ]);
        }
        headers.push(lastRepeat);
        continue;
      }
      const nonEmptyHeaders = repeatedHeaders.filter((h) => h[1] !== null);
      if (nonEmptyHeaders.length === 1) {
        headers.push(nonEmptyHeaders[0]);
        continue;
      }
      let mergeChar = "";
      if (COMMA_SEPARATED.has(lowerName)) {
        mergeChar = ", ";
      } else if (SEMICOLON_SEPARATED.has(lowerName)) {
        mergeChar = "; ";
      }
      if (mergeChar) {
        const merged = joinWords(nonEmptyHeaders.map((h) => h[1]), mergeChar);
        warnings.push([
          "repeated-header",
          `merged ${nonEmptyHeaders.length} "${nonEmptyHeaders[nonEmptyHeaders.length - 1][0]}" headers together with "${mergeChar.trim()}"`
        ]);
        headers.push([nonEmptyHeaders[0][0], merged]);
        continue;
      }
      warnings.push([
        "repeated-header",
        `found ${nonEmptyHeaders.length} "${nonEmptyHeaders[nonEmptyHeaders.length - 1][0]}" headers, only the last one will be sent`
      ]);
      headers = headers.concat(nonEmptyHeaders);
    }
    this.headers = headers;
  }
  get length() {
    return this.headers.length;
  }
  *[Symbol.iterator]() {
    for (const h of this.headers) {
      yield h;
    }
  }
  get(header) {
    const lookup = header.toLowerCase();
    for (const [h, v] of this.headers) {
      if (h.toLowerCase().toString() === lookup) {
        return v;
      }
    }
    return void 0;
  }
  getContentType() {
    const contentTypeHeader = this.get("content-type");
    if (!contentTypeHeader) {
      return contentTypeHeader;
    }
    return contentTypeHeader.split(";")[0].trim().toString();
  }
  has(header) {
    const lookup = header.toLowerCase();
    for (const h of this.headers) {
      if (eq(h[0].toLowerCase(), lookup)) {
        return true;
      }
    }
    return false;
  }
  setIfMissing(header, value) {
    if (this.has(header)) {
      return false;
    }
    if (this.lowercase) {
      header = header.toLowerCase();
    }
    const k = typeof header === "string" ? new Word(header) : header;
    const v = typeof value === "string" ? new Word(value) : value;
    this.headers.push([k, v]);
    return true;
  }
  delete(header) {
    const lookup = header.toLowerCase();
    for (let i = this.headers.length - 1; i >= 0; i--) {
      if (this.headers[i][0].toLowerCase().toString() === lookup) {
        this.headers.splice(i, 1);
      }
    }
  }
  clearNulls() {
    for (let i = this.headers.length - 1; i >= 0; i--) {
      if (this.headers[i][1] === null) {
        this.headers.splice(i, 1);
      }
    }
  }
  count(header) {
    let count = 0;
    const lookup = header.toLowerCase();
    for (const h of this.headers || []) {
      if (h[0].toLowerCase().toString() === lookup) {
        count += 1;
      }
    }
    return count;
  }
};
function parseCookiesStrict(cookieString2) {
  const cookies = [];
  for (let cookie of cookieString2.split(";")) {
    cookie = cookie.replace(/^ /, "");
    const [name, value] = cookie.split("=", 2);
    if (value === void 0) {
      return null;
    }
    cookies.push([name, value]);
  }
  if (new Set(cookies.map((c) => c[0])).size !== cookies.length) {
    return null;
  }
  return cookies;
}
function parseCookies(cookieString2) {
  const cookies = [];
  for (let cookie of cookieString2.split(";")) {
    cookie = cookie.trim();
    if (!cookie) {
      continue;
    }
    const [name, value] = cookie.split("=", 2);
    cookies.push([name.trim(), (value || "").trim()]);
  }
  if (new Set(cookies.map((c) => c[0])).size !== cookies.length) {
    return null;
  }
  return cookies;
}

// node_modules/curlconverter/dist/src/curl/url.js
function parseurl(global, config2, url) {
  var _a;
  const u = {
    scheme: new Word(),
    host: new Word(),
    path: new Word(),
    query: new Word(),
    originalQuery: new Word(),
    fragment: new Word()
  };
  if (!config2.globoff) {
    url = url.replace(/\\([[\]{}])/g, "$1");
  }
  let schemeMatch = null;
  if (url.tokens.length && typeof url.tokens[0] === "string") {
    schemeMatch = url.tokens[0].match(/^([a-zA-Z0-9+-.]*):\/\/*/);
  }
  if (schemeMatch) {
    const [schemeAndSlashes, scheme] = schemeMatch;
    u.scheme = new Word(scheme.toLowerCase());
    url = url.slice(schemeAndSlashes.length);
  } else {
    u.scheme = (_a = config2["proto-default"]) !== null && _a !== void 0 ? _a : new Word("http");
  }
  if (!eq(u.scheme, "http") && !eq(u.scheme, "https")) {
    warnf(global, ["bad-scheme", `Protocol "${u.scheme}" not supported`]);
  }
  const hostMatch = url.indexOfFirstChar("/?#");
  if (hostMatch !== -1) {
    u.host = url.slice(0, hostMatch);
    u.path = url.slice(hostMatch);
    const fragmentIndex = u.path.indexOf("#");
    const queryIndex = u.path.indexOf("?");
    if (fragmentIndex !== -1) {
      u.fragment = u.path.slice(fragmentIndex);
      if (queryIndex !== -1 && queryIndex < fragmentIndex) {
        u.query = u.path.slice(queryIndex, fragmentIndex);
        u.path = u.path.slice(0, queryIndex);
      } else {
        u.path = u.path.slice(0, fragmentIndex);
      }
    } else if (queryIndex !== -1) {
      u.query = u.path.slice(queryIndex);
      u.path = u.path.slice(0, queryIndex);
    }
  } else {
    u.host = url;
  }
  const authMatch = u.host.indexOf("@");
  if (authMatch !== -1) {
    const auth = u.host.slice(0, authMatch);
    u.host = u.host.slice(authMatch + 1);
    if (!config2["disallow-username-in-url"]) {
      u.auth = auth;
      if (auth.includes(":")) {
        [u.user, u.password] = auth.split(":", 2);
      } else {
        u.user = auth;
        u.password = new Word();
      }
    }
  }
  return u;
}

// node_modules/curlconverter/dist/src/Query.js
function _percentEncode(s) {
  return [...UTF8encoder.encode(s)].map((b) => {
    if (b >= 65 && b <= 90 || b >= 97 && b <= 122 || b >= 48 && b <= 57 || b === 45 || b === 46 || b === 95 || b === 126) {
      return String.fromCharCode(b);
    }
    return "%" + b.toString(16).toUpperCase().padStart(2, "0");
  }).join("");
}
function percentEncode(s) {
  const newTokens = [];
  for (const token of s.tokens) {
    newTokens.push(typeof token === "string" ? _percentEncode(token) : token);
  }
  return new Word(newTokens);
}
function percentEncodePlus(s) {
  const newTokens = [];
  for (const token of s.tokens) {
    newTokens.push(typeof token === "string" ? _percentEncode(token).replace(/%20/g, "+") : token);
  }
  return new Word(newTokens);
}
function wordDecodeURIComponent(s) {
  const newTokens = [];
  for (const token of s.tokens) {
    newTokens.push(typeof token === "string" ? decodeURIComponent(token) : token);
  }
  return new Word(newTokens);
}
function parseQueryString(s) {
  if (!s || s.isEmpty()) {
    return [null, null];
  }
  const asList = [];
  for (const param of s.split("&")) {
    if (!param.includes("=")) {
      return [null, null];
    }
    const [key, val] = param.split("=", 2);
    let decodedKey;
    let decodedVal;
    try {
      decodedKey = wordDecodeURIComponent(key.replace(/\+/g, " "));
      decodedVal = wordDecodeURIComponent(val.replace(/\+/g, " "));
    } catch (e) {
      if (e instanceof URIError) {
        return [null, null];
      }
      throw e;
    }
    const roundTripKey = percentEncode(decodedKey);
    const roundTripVal = percentEncode(decodedVal);
    if (!eq(roundTripKey, key) && !eq(roundTripKey.replace(/%20/g, "+"), key) || !eq(roundTripVal, val) && !eq(roundTripVal.replace(/%20/g, "+"), val)) {
      return [null, null];
    }
    asList.push([decodedKey, decodedVal]);
  }
  const keyWords = {};
  const uniqueKeys = {};
  let prevKey = null;
  for (const [key, val] of asList) {
    const keyStr = key.toString();
    if (prevKey === keyStr) {
      uniqueKeys[keyStr].push(val);
    } else if (!Object.prototype.hasOwnProperty.call(uniqueKeys, keyStr)) {
      uniqueKeys[keyStr] = [val];
      keyWords[keyStr] = key;
    } else {
      return [asList, null];
    }
    prevKey = keyStr;
  }
  const asDict = [];
  for (const [keyStr, val] of Object.entries(uniqueKeys)) {
    asDict.push([keyWords[keyStr], val.length === 1 ? val[0] : val]);
  }
  return [asList, asDict];
}

// node_modules/curlconverter/dist/src/curl/form.js
function parseForm(form) {
  const multipartUploads = [];
  for (const multipartArgument of form) {
    if (!multipartArgument.value.includes("=")) {
      throw new CCError("invalid value for --form/-F: " + JSON.stringify(multipartArgument.value.toString()));
    }
    const [name, value] = multipartArgument.value.split("=", 2);
    const isString = multipartArgument.type === "string";
    if (!isString && value.charAt(0) === "@") {
      const contentFile = value.slice(1);
      const filename = contentFile;
      multipartUploads.push({ name, contentFile, filename });
    } else if (!isString && value.charAt(0) === "<") {
      const contentFile = value.slice(1);
      multipartUploads.push({ name, contentFile });
    } else {
      const content = value;
      multipartUploads.push({ name, content });
    }
  }
  return multipartUploads;
}

// node_modules/curlconverter/dist/src/Request.js
function buildURL(global, config2, url, uploadFile, stdin, stdinFile) {
  const u = parseurl(global, config2, url);
  if (uploadFile) {
    if (u.path.isEmpty()) {
      u.path = uploadFile.prepend("/");
    } else if (u.path.endsWith("/")) {
      u.path = u.path.add(uploadFile);
    }
    if (config2.get) {
      warnf(global, [
        "data-ignored",
        "curl doesn't let you pass --get and --upload-file together"
      ]);
    }
  }
  const urlWithOriginalQuery = mergeWords([
    u.scheme,
    "://",
    u.host,
    u.path,
    u.query,
    u.fragment
  ]);
  let urlQueryArray = null;
  let queryArray = null;
  let queryStrReadsFile = null;
  if (u.query.toBool() || config2["url-query"] && config2["url-query"].length) {
    let queryStr = null;
    let queryParts = [];
    if (u.query.toBool()) {
      queryParts.push(["raw", u.query.slice(1)]);
      [queryArray, queryStr, queryStrReadsFile] = buildData(queryParts, stdin, stdinFile);
      urlQueryArray = queryArray;
    }
    if (config2["url-query"]) {
      queryParts = queryParts.concat(config2["url-query"]);
      [queryArray, queryStr, queryStrReadsFile] = buildData(queryParts, stdin, stdinFile);
    }
    u.query = new Word();
    if (queryStr && queryStr.toBool()) {
      u.query = queryStr.prepend("?");
    }
  }
  const urlWithoutQueryArray = mergeWords([
    u.scheme,
    "://",
    u.host,
    u.path,
    u.fragment
  ]);
  url = mergeWords([u.scheme, "://", u.host, u.path, u.query, u.fragment]);
  let urlWithoutQueryList = url;
  let [queryList, queryDict] = parseQueryString(u.query.toBool() ? u.query.slice(1) : new Word());
  if (queryList && queryList.length) {
    urlWithoutQueryList = mergeWords([
      u.scheme,
      "://",
      u.host,
      u.path,
      u.fragment
    ]);
  } else {
    queryList = null;
    queryDict = null;
  }
  return [
    u,
    url,
    queryStrReadsFile,
    urlWithoutQueryList,
    queryList,
    queryDict,
    urlWithoutQueryArray,
    urlWithOriginalQuery,
    queryArray,
    urlQueryArray
  ];
}
function buildData(configData, stdin, stdinFile) {
  const data = [];
  let dataStrState = new Word();
  for (const [i, x] of configData.entries()) {
    const type = x[0];
    let value = x[1];
    let name = null;
    if (i > 0 && type !== "json") {
      dataStrState = dataStrState.append("&");
    }
    if (type === "urlencode") {
      const splitOn = value.includes("=") || !value.includes("@") ? "=" : "@";
      if (value.includes("@") || value.includes("=")) {
        [name, value] = value.split(splitOn, 2);
      }
      if (splitOn === "=") {
        if (name && name.toBool()) {
          dataStrState = dataStrState.add(name).append("=");
        }
        dataStrState = dataStrState.add(percentEncodePlus(value));
        continue;
      }
      name = name && name.toBool() ? name : null;
      value = value.prepend("@");
    }
    let filename = null;
    if (type !== "raw" && value.startsWith("@")) {
      filename = value.slice(1);
      if (eq(filename, "-")) {
        if (stdin !== void 0) {
          switch (type) {
            case "binary":
            case "json":
              value = stdin;
              break;
            case "urlencode":
              value = mergeWords([
                name && name.length ? name.append("=") : new Word(),
                percentEncodePlus(stdin)
              ]);
              break;
            default:
              value = stdin.replace(/[\n\r]/g, "");
          }
          filename = null;
        } else if (stdinFile !== void 0) {
          filename = stdinFile;
        } else {
        }
      }
    }
    if (filename !== null) {
      if (dataStrState.toBool()) {
        data.push(dataStrState);
        dataStrState = new Word();
      }
      data.push([type, name, filename]);
    } else {
      dataStrState = dataStrState.add(value);
    }
  }
  if (dataStrState.toBool()) {
    data.push(dataStrState);
  }
  let dataStrReadsFile = null;
  const dataStr = mergeWords(data.map((d) => {
    if (Array.isArray(d)) {
      const name = d[1];
      const filename = d[2];
      dataStrReadsFile || (dataStrReadsFile = filename.toString());
      if (name) {
        return mergeWords([name, "=@", filename]);
      }
      return filename.prepend("@");
    }
    return d;
  }));
  return [data, dataStr, dataStrReadsFile];
}
function buildRequest(global, config2, stdin, stdinFile) {
  var _a, _b;
  if (!config2.url || !config2.url.length) {
    throw new CCError("no URL specified!");
  }
  const headers = new Headers(config2.header);
  let cookies;
  const cookieFiles = [];
  const cookieHeader = headers.get("cookie");
  if (cookieHeader) {
    const parsedCookies = parseCookiesStrict(cookieHeader);
    if (parsedCookies) {
      cookies = parsedCookies;
    }
  } else if (cookieHeader === void 0 && config2.cookie) {
    const cookieStrings = [];
    for (const c of config2.cookie) {
      if (c.includes("=")) {
        cookieStrings.push(c);
      } else {
        cookieFiles.push(c);
      }
    }
    if (cookieStrings.length) {
      const cookieString2 = joinWords(config2.cookie, "; ");
      headers.setIfMissing("Cookie", cookieString2);
      const parsedCookies = parseCookies(cookieString2);
      if (parsedCookies) {
        cookies = parsedCookies;
      }
    }
  }
  if (config2["user-agent"]) {
    headers.setIfMissing("User-Agent", config2["user-agent"]);
  }
  if (config2.referer) {
    const referer = config2.referer.replace(/;auto$/, "");
    if (referer.length) {
      headers.setIfMissing("Referer", referer);
    }
  }
  if (config2.range) {
    let range = config2.range.prepend("bytes=");
    if (!range.includes("-")) {
      range = range.append("-");
    }
    headers.setIfMissing("Range", range);
  }
  if (config2["time-cond"]) {
    let timecond = config2["time-cond"];
    let header = "If-Modified-Since";
    switch (timecond.charAt(0)) {
      case "+":
        timecond = timecond.slice(1);
        break;
      case "-":
        timecond = timecond.slice(1);
        header = "If-Unmodified-Since";
        break;
      case "=":
        timecond = timecond.slice(1);
        header = "Last-Modified";
        break;
    }
    headers.setIfMissing(header, timecond);
  }
  let data;
  let dataStr;
  let dataStrReadsFile;
  let queryArray;
  if (config2.data && config2.data.length) {
    if (config2.get) {
      config2["url-query"] = config2.data;
      delete config2.data;
    } else {
      [data, dataStr, dataStrReadsFile] = buildData(config2.data, stdin, stdinFile);
    }
  }
  if (config2["url-query"]) {
    [queryArray] = buildData(config2["url-query"], stdin, stdinFile);
  }
  const urls = [];
  const uploadFiles = config2["upload-file"] || [];
  const outputFiles = config2.output || [];
  for (let [i, originalUrl] of config2.url.entries()) {
    const uploadFile = uploadFiles[i];
    const output = outputFiles[i];
    const [urlObj, url, queryReadsFile, urlWithoutQueryList, queryList, queryDict, urlWithoutQueryArray, urlWithOriginalQuery, queryArray2, urlQueryArray] = buildURL(global, config2, originalUrl, uploadFile, stdin, stdinFile);
    let method = new Word("GET");
    if (config2.request && !eq(config2.request, "null")) {
      method = config2.request;
    } else if (config2.head) {
      method = new Word("HEAD");
    } else if (uploadFile) {
      method = new Word("PUT");
    } else if (!config2.get && (has(config2, "data") || has(config2, "form"))) {
      method = new Word("POST");
    }
    const requestUrl = {
      originalUrl,
      urlWithoutQueryList,
      url,
      urlObj,
      urlWithOriginalQuery,
      urlWithoutQueryArray,
      method
    };
    if (queryReadsFile) {
      requestUrl.queryReadsFile = queryReadsFile;
    }
    if (queryList) {
      requestUrl.queryList = queryList;
      if (queryDict) {
        requestUrl.queryDict = queryDict;
      }
    }
    if (queryArray2) {
      requestUrl.queryArray = queryArray2;
    }
    if (urlQueryArray) {
      requestUrl.urlQueryArray = urlQueryArray;
    }
    if (uploadFile) {
      requestUrl.uploadFile = uploadFile;
    }
    if (output) {
      requestUrl.output = output;
    }
    const auth = config2.user || urlObj.auth;
    if (auth) {
      const [user, pass] = auth.split(":", 2);
      requestUrl.auth = [user, pass ? pass : new Word()];
    }
    urls.push(requestUrl);
  }
  if (config2.get && config2.data) {
    delete config2.data;
  }
  if ((config2["upload-file"] || []).length > config2.url.length) {
    warnf(global, [
      "too-many-upload-files",
      "Got more --upload-file/-T options than URLs: " + ((_a = config2["upload-file"]) === null || _a === void 0 ? void 0 : _a.map((f) => JSON.stringify(f.toString())).join(", "))
    ]);
  }
  if ((config2.output || []).length > config2.url.length) {
    warnf(global, [
      "too-many-ouptut-files",
      "Got more --output/-o options than URLs: " + ((_b = config2.output) === null || _b === void 0 ? void 0 : _b.map((f) => JSON.stringify(f.toString())).join(", "))
    ]);
  }
  const request = {
    urls,
    authType: pickAuth(config2.authtype),
    headers
  };
  if (stdin) {
    request.stdin = stdin;
  }
  if (stdinFile) {
    request.stdinFile = stdinFile;
  }
  if (cookies) {
    request.cookies = cookies;
  }
  if (cookieFiles.length) {
    request.cookieFiles = cookieFiles;
  }
  if (config2["cookie-jar"]) {
    request.cookieJar = config2["cookie-jar"];
  }
  if (config2.compressed !== void 0) {
    request.compressed = config2.compressed;
  }
  if (config2.json) {
    headers.setIfMissing("Content-Type", "application/json");
    headers.setIfMissing("Accept", "application/json");
  } else if (config2.data) {
    headers.setIfMissing("Content-Type", "application/x-www-form-urlencoded");
  } else if (config2.form) {
    request.multipartUploads = parseForm(config2.form);
  }
  if (config2["aws-sigv4"]) {
    request.authType = "aws-sigv4";
    request.awsSigV4 = config2["aws-sigv4"];
  }
  if (request.authType === "bearer" && config2["oauth2-bearer"]) {
    const bearer = config2["oauth2-bearer"].prepend("Bearer ");
    headers.setIfMissing("Authorization", bearer);
  }
  if (config2.delegation) {
    request.delegation = config2.delegation;
  }
  headers.clearNulls();
  if (config2.data && config2.data.length) {
    request.data = dataStr;
    if (dataStrReadsFile) {
      request.dataReadsFile = dataStrReadsFile;
    }
    request.dataArray = data;
    request.isDataRaw = false;
    request.isDataBinary = (data || []).some((d) => Array.isArray(d) && d[0] === "binary");
  }
  if (queryArray) {
    request.queryArray = queryArray;
  }
  if (config2.insecure) {
    request.insecure = true;
  }
  if (config2.cert) {
    request.cert = config2.key ? [config2.cert, config2.key] : config2.cert;
  }
  if (config2.cacert) {
    request.cacert = config2.cacert;
  }
  if (config2.capath) {
    request.capath = config2.capath;
  }
  if (config2.proxy) {
    request.proxy = config2.proxy;
    if (config2["proxy-user"]) {
      request.proxyAuth = config2["proxy-user"];
    }
  }
  if (config2["max-time"]) {
    request.timeout = config2["max-time"];
    if (config2["max-time"].isString() && isNaN(parseFloat(config2["max-time"].toString()))) {
      warnf(global, [
        "max-time-not-number",
        "option --max-time: expected a proper numerical parameter: " + JSON.stringify(config2["max-time"].toString())
      ]);
    }
  }
  if (config2["connect-timeout"]) {
    request.connectTimeout = config2["connect-timeout"];
    if (config2["connect-timeout"].isString() && isNaN(parseFloat(config2["connect-timeout"].toString()))) {
      warnf(global, [
        "connect-timeout-not-number",
        "option --connect-timeout: expected a proper numerical parameter: " + JSON.stringify(config2["connect-timeout"].toString())
      ]);
    }
  }
  if (Object.prototype.hasOwnProperty.call(config2, "location")) {
    request.followRedirects = config2.location;
  }
  if (config2["location-trusted"]) {
    request.followRedirectsTrusted = config2["location-trusted"];
  }
  if (config2["max-redirs"]) {
    request.maxRedirects = config2["max-redirs"].trim();
    if (config2["max-redirs"].isString() && !isInt(config2["max-redirs"].toString())) {
      warnf(global, [
        "max-redirs-not-int",
        "option --max-redirs: expected a proper numerical parameter: " + JSON.stringify(config2["max-redirs"].toString())
      ]);
    }
  }
  const http2 = config2.http2 || config2["http2-prior-knowledge"];
  if (http2) {
    request.http2 = http2;
  }
  if (config2.http3 || config2["http3-only"]) {
    request.http3 = true;
  }
  return request;
}
function buildRequests(global, stdin, stdinFile) {
  if (!global.configs.length) {
    warnf(global, ["no-configs", "got empty config object"]);
  }
  return global.configs.map((config2) => buildRequest(global, config2, stdin, stdinFile));
}
function getFirst(requests, warnings, support) {
  if (requests.length > 1) {
    warnings.push([
      "next",
      "got " + requests.length + " configs because of --next, using the first one"
    ]);
  }
  const request = requests[0];
  warnIfPartsIgnored(request, warnings, support);
  return request;
}

// node_modules/curlconverter/dist/src/parse.js
function clip(s, maxLength = 30) {
  if (s.length > maxLength) {
    return s.slice(0, maxLength - 3) + "...";
  }
  return s;
}
function toArgv(curlCommand, warnings) {
  if (typeof curlCommand === "string") {
    return tokenize(curlCommand, warnings);
  }
  if (curlCommand.length === 0) {
    throw new CCError("no arguments provided");
  }
  if (curlCommand[0].trim() !== "curl") {
    throw new CCError('command should begin with "curl" but instead begins with ' + JSON.stringify(clip(curlCommand[0])));
  }
  return [curlCommand.map((arg) => new Word(arg)), void 0, void 0];
}
function parseCurlCommand(curlCommand, supportedArgs19, warnings = []) {
  const [argv, stdin, stdinFile] = toArgv(curlCommand, warnings);
  const globalConfig = parseArgs(argv, curlLongOpts, curlShortOpts, supportedArgs19, warnings);
  return buildRequests(globalConfig, stdin, stdinFile);
}

// node_modules/curlconverter/dist/src/generators/ansible.js
var import_yamljs = __toESM(require_Yaml(), 1);
var supportedArgs = /* @__PURE__ */ new Set([
  ...COMMON_SUPPORTED_ARGS,
  "insecure",
  "no-insecure"
]);
function getDataString(request) {
  if (!request.data) {
    return;
  }
  if (request.headers.getContentType() === "application/json") {
    const dataStr = request.data.toString();
    try {
      const dataAsJson = JSON.parse(dataStr);
      const roundtrips = JSON.stringify(dataAsJson) === dataStr;
      return [dataAsJson, roundtrips];
    } catch (_a) {
    }
  }
  return;
}
function _toAnsible(requests, warnings = []) {
  const request = getFirst(requests, warnings);
  const r = {
    url: request.urls[0].url.toString(),
    method: request.urls[0].method.toString()
  };
  if (request.data) {
    const asJson = getDataString(request);
    if (asJson) {
      r.body = asJson[0];
      r.body_format = "json";
    } else {
      r.body = request.data.toString();
    }
  }
  if (request.headers.length) {
    r.headers = {};
    for (const h of request.headers) {
      const [k, v] = h;
      if (v !== null) {
        r.headers[k.toString()] = v.toString();
      }
    }
  }
  if (request.urls[0].auth) {
    if (request.urls[0].auth[0].toBool()) {
      r.url_username = request.urls[0].auth[0].toString();
    }
    if (request.urls[0].auth[1].toBool()) {
      r.url_password = request.urls[0].auth[1].toString();
    }
  }
  if (request.insecure) {
    r.validate_certs = false;
  }
  return import_yamljs.default.stringify([
    {
      name: request.urls[0].urlWithoutQueryList.toString(),
      uri: r,
      register: "result"
    }
  ], 100, 2);
}
function toAnsibleWarn(curlCommand, warnings = []) {
  const requests = parseCurlCommand(curlCommand, supportedArgs, warnings);
  const ansible = _toAnsible(requests, warnings);
  return [ansible, warnings];
}
function toAnsible(curlCommand) {
  return toAnsibleWarn(curlCommand)[0];
}

// node_modules/curlconverter/dist/src/generators/javascript/javascript.js
var import_jsesc = __toESM(require_jsesc(), 1);
var javaScriptSupportedArgs = /* @__PURE__ */ new Set([
  ...COMMON_SUPPORTED_ARGS,
  "upload-file",
  "form",
  "form-string",
  "digest",
  "no-digest",
  "next"
]);
var nodeSupportedArgs = /* @__PURE__ */ new Set([...javaScriptSupportedArgs, "proxy"]);
function reprObj(value, indentLevel) {
  const escaped = (0, import_jsesc.default)(value, {
    quotes: "single",
    minimal: false,
    compact: false,
    indent: "    ",
    indentLevel: indentLevel ? indentLevel : 0
  });
  if (typeof value === "string") {
    return "'" + escaped + "'";
  }
  return escaped;
}
function reprPairs(d, indentLevel = 0, indent3 = "    ", list = true, imports) {
  if (d.length === 0) {
    return list ? "[]" : "{}";
  }
  let code = list ? "[\n" : "{\n";
  for (const [i, [key, value]] of d.entries()) {
    code += indent3.repeat(indentLevel + 1);
    if (list) {
      code += "[" + repr(key, imports) + ", " + repr(value, imports) + "]";
    } else {
      code += repr(key, imports) + ": " + repr(value, imports);
    }
    code += i < d.length - 1 ? ",\n" : "\n";
  }
  code += indent3.repeat(indentLevel) + (list ? "]" : "}");
  return code;
}
function reprAsStringToStringDict(d, indentLevel = 0, imports, indent3 = "    ") {
  return reprPairs(d, indentLevel, indent3, false, imports);
}
function reprAsStringTuples(d, indentLevel = 0, imports, indent3 = "    ") {
  return reprPairs(d, indentLevel, indent3, true, imports);
}
function reprStringToStringList(d, indentLevel = 0, imports, indent3 = "    ", list = true) {
  if (d.length === 0) {
    return list ? "[]" : "{}";
  }
  let code = "{\n";
  for (const [i, [key, value]] of d.entries()) {
    let valueStr;
    if (Array.isArray(value)) {
      valueStr = "[" + value.map((v) => repr(v, imports)).join(", ") + "]";
    } else {
      valueStr = repr(value, imports);
    }
    code += indent3.repeat(indentLevel + 1);
    code += repr(key, imports) + ": " + valueStr;
    code += i < d.length - 1 ? ",\n" : "\n";
  }
  code += indent3.repeat(indentLevel) + "}";
  return code;
}
var regexEscape = /'|"|\\|\p{C}|\p{Z}/gu;
var regexDigit = /[0-9]/;
function esc(s, quote = "'") {
  return s.replace(regexEscape, (c, index, string) => {
    switch (c[0]) {
      case " ":
        return " ";
      case "\\":
        return "\\\\";
      case "\b":
        return "\\b";
      case "\f":
        return "\\f";
      case "\n":
        return "\\n";
      case "\r":
        return "\\r";
      case "	":
        return "\\t";
      case "\v":
        return "\\v";
      case "'":
      case '"':
        return c === quote ? "\\" + c : c;
      case "\0":
        if (!regexDigit.test(string.charAt(index + 1))) {
          return "\\0";
        }
        break;
    }
    if (c.length === 2) {
      const first = c.charCodeAt(0);
      const second = c.charCodeAt(1);
      return "\\u" + first.toString(16).padStart(4, "0") + "\\u" + second.toString(16).padStart(4, "0");
    }
    const hex = c.charCodeAt(0).toString(16);
    if (hex.length > 2) {
      return "\\u" + hex.padStart(4, "0");
    }
    return "\\x" + hex.padStart(2, "0");
  });
}
function reprStr(s, quote) {
  if (quote === void 0) {
    quote = "'";
    if (s.includes("'") && !s.includes('"')) {
      quote = '"';
    }
  }
  return quote + esc(s, quote) + quote;
}
function addImport(imports, name, from) {
  for (const [n, f] of imports) {
    if (n === name && f === from)
      return;
  }
  imports.push([name, from]);
}
function reprImportsRequire(imports) {
  const ret = [];
  if (imports.length === 0) {
    return "";
  }
  for (const [name, from] of imports.sort(bySecondElem)) {
    if (name.startsWith("* as ")) {
      ret.push(`const ${name.slice("* as ".length)} = require(${reprStr(from)});`);
    } else if (name.includes(".")) {
      ret.push(`const ${name} = require(${reprStr(from)}).${name};`);
    } else {
      ret.push(`const ${name} = require(${reprStr(from)});`);
    }
  }
  return ret.join("\n") + "\n";
}
function repr(w, imports) {
  const ret = [];
  for (const t of w.tokens) {
    if (typeof t === "string") {
      ret.push(reprStr(t));
    } else if (t.type === "variable") {
      ret.push("process.env[" + reprStr(t.value) + "]");
    } else {
      ret.push("execSync(" + reprStr(t.value) + ").stdout");
      addImport(imports, "execSync", "node:child_process");
    }
  }
  return ret.join(" + ");
}
function reprFetch(w, isNode, imports) {
  if (!isNode) {
    return reprStr(w.toString());
  }
  return repr(w, imports);
}
function asParseFloatTimes1000(w, imports) {
  if (w.isString()) {
    const originalValue = w.toString();
    const asFloat = parseFloat(originalValue) * 1e3;
    if (!isNaN(asFloat)) {
      return asFloat.toString();
    }
  }
  return "parseFloat(" + repr(w, imports) + ") * 1000";
}
function asParseInt(w, imports) {
  if (w.isString()) {
    const originalValue = w.toString();
    const asInt = parseInt(originalValue);
    if (!isNaN(asInt)) {
      return originalValue;
    }
  }
  return "parseInt(" + repr(w, imports) + ")";
}
function bySecondElem(a, b) {
  return a[1].localeCompare(b[1]);
}
function getDataString2(request, isNode, imports) {
  if (!request.data) {
    return ["", null];
  }
  const originalStringRepr = reprFetch(request.data, isNode, imports);
  const contentType = request.headers.getContentType();
  if (contentType === "application/json" && request.data.isString()) {
    try {
      const dataStr = request.data.toString();
      const parsed = JSON.parse(dataStr);
      if (typeof parsed !== "object" || parsed === null) {
        return [originalStringRepr, null];
      }
      const roundtrips = JSON.stringify(parsed) === dataStr;
      const jsonAsJavaScript = reprObj(parsed, 1);
      const dataString = "JSON.stringify(" + jsonAsJavaScript + ")";
      return [dataString, roundtrips ? null : originalStringRepr];
    } catch (_a) {
      return [originalStringRepr, null];
    }
  }
  if (contentType === "application/x-www-form-urlencoded") {
    try {
      const [queryList, queryDict] = parseQueryString(request.data);
      if (queryList) {
        if (eq(request.headers.get("content-type"), "application/x-www-form-urlencoded")) {
          request.headers.delete("content-type");
        }
        const queryObj = queryDict && queryDict.every((q) => !Array.isArray(q[1])) ? reprAsStringToStringDict(queryDict, 1, imports) : reprAsStringTuples(queryList, 1, imports);
        return ["new URLSearchParams(" + queryObj + ")", null];
      }
      return [originalStringRepr, null];
    } catch (_b) {
      return [originalStringRepr, null];
    }
  }
  return [originalStringRepr, null];
}
function requestToJavaScriptOrNode(request, warnings, fetchImports, imports, isNode) {
  warnIfPartsIgnored(request, warnings, {
    multipleUrls: true,
    queryReadsFile: true
  });
  let code = "";
  if (request.multipartUploads) {
    if (isNode) {
      fetchImports.add("FormData");
    }
    code += "const form = new FormData();\n";
    for (const m of request.multipartUploads) {
      code += "form.append(" + reprFetch(m.name, isNode, imports) + ", ";
      if ("contentFile" in m) {
        if (isNode) {
          if (eq(m.contentFile, "-")) {
            addImport(imports, "fs", "fs");
            code += "fs.readFileSync(0).toString()";
            if (m.filename) {
              code += ", " + reprFetch(m.filename, isNode, imports);
            }
          } else {
            fetchImports.add("fileFromSync");
            code += "fileFromSync(" + reprFetch(m.contentFile, isNode, imports) + ")";
          }
        } else {
          code += "File(['<data goes here>'], " + reprFetch(m.contentFile, isNode, imports) + ")";
          warnings.push([
            "--form",
            "you can't read a file for --form/-F in the browser"
          ]);
        }
      } else {
        code += reprFetch(m.content, isNode, imports);
      }
      code += ");\n";
    }
    code += "\n";
  }
  const [dataString, commentedOutDataString] = getDataString2(request, isNode, imports);
  if (request.urls[0].auth && request.authType === "digest") {
    const [user, password] = request.urls[0].auth;
    addImport(imports, "* as DigestFetch", "digest-fetch");
    code += "const client = new DigestFetch(" + reprFetch(user, isNode, imports) + ", " + reprFetch(password, isNode, imports) + ");\n";
    code += "client.";
  }
  for (const urlObj of request.urls) {
    code += "fetch(" + reprFetch(urlObj.url, isNode, imports);
    if (urlObj.queryReadsFile) {
      warnings.push([
        "unsafe-query",
        "the URL query string is not correct, " + JSON.stringify("@" + urlObj.queryReadsFile) + " means it should read the file " + JSON.stringify(urlObj.queryReadsFile)
      ]);
    }
    const method = urlObj.method.toLowerCase();
    if (!eq(method, "get") || request.headers.length || urlObj.auth && request.authType === "basic" || request.data || request.multipartUploads || isNode && request.proxy) {
      code += ", {\n";
      if (!eq(method, "get")) {
        code += "    method: " + reprFetch(request.urls[0].method, isNode, imports) + ",\n";
      }
      if (request.headers.length || urlObj.auth && request.authType === "basic") {
        code += "    headers: {\n";
        for (const [headerName, headerValue] of request.headers) {
          code += "        " + reprFetch(headerName, isNode, imports) + ": " + reprFetch(headerValue || new Word(), isNode, imports) + ",\n";
        }
        if (urlObj.auth && request.authType === "basic") {
          code += "        'Authorization': 'Basic ' + btoa(" + reprFetch(joinWords(urlObj.auth, ":"), isNode, imports) + "),\n";
        }
        if (code.endsWith(",\n")) {
          code = code.slice(0, -2);
          code += "\n";
        }
        code += "    },\n";
      }
      if (urlObj.uploadFile) {
        if (isNode) {
          fetchImports.add("fileFromSync");
          code += "    body: fileFromSync(" + reprFetch(urlObj.uploadFile, isNode, imports) + "),\n";
        } else {
          code += "    body: File(['<data goes here>'], " + reprFetch(urlObj.uploadFile, isNode, imports) + "),\n";
          warnings.push([
            "--form",
            "you can't read a file for --upload-file/-F in the browser"
          ]);
        }
      } else if (request.data) {
        if (commentedOutDataString) {
          code += "    // body: " + commentedOutDataString + ",\n";
        }
        code += "    body: " + dataString + ",\n";
      } else if (request.multipartUploads) {
        code += "    body: form,\n";
      }
      if (isNode && request.proxy) {
        const proxy = request.proxy.includes("://") ? request.proxy : request.proxy.prepend("http://");
        let [protocol] = proxy.split("://", 2);
        protocol = protocol.toLowerCase();
        if (!protocol.toBool()) {
          protocol = new Word("http");
        }
        if (eq(protocol, "socks")) {
          protocol = new Word("socks4");
          proxy.replace(/^socks/, "socks4");
        }
        if (eq(protocol, "socks4") || eq(protocol, "socks5") || eq(protocol, "socks5h") || eq(protocol, "socks4a")) {
          addImport(imports, "{ SocksProxyAgent }", "socks-proxy-agent");
          code += "    agent: new SocksProxyAgent(" + reprFetch(proxy, isNode, imports) + "),\n";
        } else if (eq(protocol, "http") || eq(protocol, "https")) {
          addImport(imports, "HttpsProxyAgent", "https-proxy-agent");
          code += "    agent: new HttpsProxyAgent(" + reprFetch(proxy, isNode, imports) + "),\n";
        } else {
          warnings.push([
            "--proxy",
            "failed to parse --proxy/-x or unknown protocol: " + protocol
          ]);
        }
      }
      if (code.endsWith(",\n")) {
        code = code.slice(0, -2);
      }
      code += "\n}";
    }
    code += ");\n";
  }
  return code;
}
function _toJavaScriptOrNode(requests, warnings, isNode) {
  const fetchImports = /* @__PURE__ */ new Set();
  const imports = [];
  const code = requests.map((r) => requestToJavaScriptOrNode(r, warnings, fetchImports, imports, isNode)).join("\n");
  let importCode = "";
  if (isNode) {
    importCode += "import fetch";
    if (fetchImports.size) {
      importCode += ", { " + Array.from(fetchImports).sort().join(", ") + " }";
    }
    importCode += " from 'node-fetch';\n";
  }
  if (imports.length) {
    for (const [varName, imp] of Array.from(imports).sort(bySecondElem)) {
      importCode += "import " + varName + " from " + reprStr(imp) + ";\n";
    }
  }
  if (importCode) {
    return importCode + "\n" + code;
  }
  return code;
}
function _toJavaScript(requests, warnings = []) {
  return _toJavaScriptOrNode(requests, warnings, false);
}
function _toNode(requests, warnings = []) {
  return _toJavaScriptOrNode(requests, warnings, true);
}
function toJavaScriptWarn(curlCommand, warnings = []) {
  const requests = parseCurlCommand(curlCommand, javaScriptSupportedArgs, warnings);
  return [_toJavaScript(requests, warnings), warnings];
}
function toJavaScript(curlCommand) {
  const [result] = toJavaScriptWarn(curlCommand);
  return result;
}
function toNodeWarn(curlCommand, warnings = []) {
  const requests = parseCurlCommand(curlCommand, nodeSupportedArgs, warnings);
  return [_toNode(requests, warnings), warnings];
}
function toNode(curlCommand) {
  return toNodeWarn(curlCommand)[0];
}

// node_modules/curlconverter/dist/src/generators/cfml.js
var supportedArgs2 = /* @__PURE__ */ new Set([
  ...COMMON_SUPPORTED_ARGS,
  "form",
  "form-string",
  "max-time",
  "proxy",
  "proxy-user"
]);
function repr2(w) {
  if (typeof w !== "string" && !w.isString()) {
  }
  let s = w.toString();
  let quote = '"';
  if (s.includes('"') && !s.includes("'")) {
    quote = "'";
  }
  s = esc(s, quote).replace(/#/g, "##");
  if (quote === '"') {
    return '"' + s.replace(/"/g, '""') + '"';
  }
  return "'" + s.replace(/'/g, "''") + "'";
}
function _toCFML(requests, warnings = []) {
  const request = getFirst(requests, warnings);
  let cfmlCode = "";
  cfmlCode += "httpService = new http();\n";
  cfmlCode += "httpService.setUrl(" + repr2(request.urls[0].url) + ");\n";
  cfmlCode += "httpService.setMethod(" + repr2(request.urls[0].method) + ");\n";
  if (request.cookies) {
    for (const [headerName, headerValue] of request.cookies) {
      cfmlCode += 'httpService.addParam(type="cookie", name=' + repr2(headerName) + ", value=" + repr2(headerValue) + ");\n";
    }
    request.headers.delete("Cookie");
  }
  if (request.headers.length) {
    for (const [headerName, headerValue] of request.headers) {
      cfmlCode += 'httpService.addParam(type="header", name=' + repr2(headerName) + ", value=" + repr2(headerValue || new Word()) + ");\n";
    }
  }
  if (request.timeout) {
    cfmlCode += "httpService.setTimeout(" + (parseInt(request.timeout.toString(), 10) || 0) + ");\n";
  }
  if (request.urls[0].auth) {
    const [authUser, authPassword] = request.urls[0].auth;
    cfmlCode += "httpService.setUsername(" + repr2(authUser) + ");\n";
    cfmlCode += "httpService.setPassword(" + repr2(authPassword || "") + ");\n";
  }
  if (request.proxy) {
    const p = request.proxy.toString();
    let proxy = p;
    let proxyPort = "1080";
    const proxyPart = p.match(/:([0-9]+)/);
    if (proxyPart) {
      proxy = p.slice(0, proxyPart.index);
      proxyPort = proxyPart[1];
    }
    cfmlCode += "httpService.setProxyServer(" + repr2(proxy) + ");\n";
    cfmlCode += "httpService.setProxyPort(" + proxyPort.trim() + ");\n";
    if (request.proxyAuth) {
      const [proxyUser, proxyPassword] = request.proxyAuth.split(":", 2);
      cfmlCode += "httpService.setProxyUser(" + repr2(proxyUser) + ");\n";
      cfmlCode += "httpService.setProxyPassword(" + repr2(proxyPassword || "") + ");\n";
    }
  }
  if (request.data || request.multipartUploads) {
    if (request.multipartUploads) {
      for (const m of request.multipartUploads) {
        if ("contentFile" in m) {
          cfmlCode += 'httpService.addParam(type="file", name=' + repr2(m.name) + ', file="#expandPath(' + repr2(m.contentFile) + ')#");\n';
        } else {
          cfmlCode += 'httpService.addParam(type="formfield", name=' + repr2(m.name) + ", value=" + repr2(m.content) + ");\n";
        }
      }
    } else if (!request.isDataRaw && request.data && request.data.charAt(0) === "@") {
      cfmlCode += 'httpService.addParam(type="body", value="#' + (request.isDataBinary ? "fileReadBinary" : "fileRead") + "(expandPath(" + repr2(request.data.toString().substring(1)) + '))#");\n';
    } else {
      cfmlCode += 'httpService.addParam(type="body", value=' + repr2(request.data) + ");\n";
    }
  }
  cfmlCode += "\nresult = httpService.send().getPrefix();\n";
  cfmlCode += "writeDump(result);\n";
  return cfmlCode;
}
function toCFMLWarn(curlCommand, warnings = []) {
  const requests = parseCurlCommand(curlCommand, supportedArgs2, warnings);
  const cfml = _toCFML(requests, warnings);
  return [cfml, warnings];
}
function toCFML(curlCommand) {
  return toCFMLWarn(curlCommand)[0];
}

// node_modules/curlconverter/dist/src/generators/javascript/axios.js
var supportedArgs3 = /* @__PURE__ */ new Set([
  ...COMMON_SUPPORTED_ARGS,
  "max-time",
  "form",
  "form-string",
  "proxy",
  "proxy-user"
]);
function _getDataString(request, imports) {
  if (!request.data) {
    return [null, null];
  }
  const originalStringRepr = repr(request.data, imports);
  const contentType = request.headers.getContentType();
  const exactContentType = request.headers.get("content-type");
  if (contentType === "application/json" && request.data.isString()) {
    const dataStr = request.data.toString();
    const parsed = JSON.parse(dataStr);
    if (typeof parsed !== "object" || parsed === null) {
      return [originalStringRepr, null];
    }
    const roundtrips = JSON.stringify(parsed) === dataStr;
    const jsonAsJavaScript = reprObj(parsed, 1);
    if (roundtrips && eq(exactContentType, "application/json") && eq(request.headers.get("accept"), "application/json, text/plain, */*")) {
      request.headers.delete("content-type");
      request.headers.delete("accept");
    }
    return [jsonAsJavaScript, roundtrips ? null : originalStringRepr];
  }
  if (contentType === "application/x-www-form-urlencoded") {
    const [queryList, queryDict] = parseQueryString(request.data);
    if (queryList) {
      if (eq(exactContentType, "application/x-www-form-urlencoded")) {
        request.headers.delete("content-type");
      }
      const queryObj = queryDict && queryDict.every((q) => !Array.isArray(q[1])) ? reprAsStringToStringDict(queryDict, 1, imports) : reprAsStringTuples(queryList, 1, imports);
      return ["new URLSearchParams(" + queryObj + ")", null];
    } else {
      return [originalStringRepr, null];
    }
  }
  return [null, null];
}
function getDataString3(request, imports) {
  if (!request.data) {
    return [null, null];
  }
  let dataString = null;
  let commentedOutDataString = null;
  try {
    [dataString, commentedOutDataString] = _getDataString(request, imports);
  } catch (_a) {
  }
  if (!dataString) {
    dataString = repr(request.data, imports);
  }
  return [dataString, commentedOutDataString];
}
function buildConfigObject(request, method, methodStr, methods, dataMethods, hasSearchParams, imports) {
  let code = "{\n";
  if (!methods.includes(methodStr)) {
    code += "    method: " + repr(method, imports) + ",\n";
  }
  if (hasSearchParams) {
    code += "    params: params,\n";
  } else if (request.urls[0].queryDict) {
    code += "    params: " + reprStringToStringList(request.urls[0].queryDict, 1, imports) + ",\n";
  }
  const [dataString, commentedOutDataString] = getDataString3(request, imports);
  if (request.headers.length || request.multipartUploads) {
    code += "    headers: {\n";
    if (request.multipartUploads) {
      code += "        ...form.getHeaders(),\n";
    }
    for (const [key, value] of request.headers) {
      code += "        " + repr(key, imports) + ": " + repr(value !== null && value !== void 0 ? value : new Word(), imports) + ",\n";
    }
    if (code.endsWith(",\n")) {
      code = code.slice(0, -2);
      code += "\n";
    }
    code += "    },\n";
  }
  if (request.urls[0].auth) {
    const [username, password] = request.urls[0].auth;
    code += "    auth: {\n";
    code += "        username: " + repr(username, imports);
    if (password.toBool()) {
      code += ",\n";
      code += "        password: " + repr(password, imports) + "\n";
    } else {
      code += "\n";
    }
    code += "    },\n";
  }
  if (!dataMethods.includes(methodStr)) {
    if (request.data) {
      if (commentedOutDataString) {
        code += "    // data: " + commentedOutDataString + ",\n";
      }
      code += "    data: " + dataString + ",\n";
    } else if (request.multipartUploads) {
      code += "    data: form,\n";
    }
  }
  if (request.timeout) {
    if (parseFloat(request.timeout.toString()) !== 0) {
      code += "    timeout: " + asParseFloatTimes1000(request.timeout, imports) + ",\n";
    }
  }
  if (request.proxy && request.proxy.toString() === "") {
    code += "    proxy: false,\n";
  } else if (request.proxy) {
    const proxy = request.proxy.includes("://") ? request.proxy : request.proxy.prepend("http://");
    let [protocol, host] = proxy.split("://", 2);
    protocol = protocol.toLowerCase().toString() === "socks" ? new Word("socks4") : protocol.toLowerCase();
    let port = "1080";
    const proxyPart = host.match(/:([0-9]+$)/);
    if (proxyPart) {
      host = host.slice(0, proxyPart.index);
      port = proxyPart[1];
    }
    code += "    proxy: {\n";
    code += "        protocol: " + repr(protocol, imports) + ",\n";
    code += "        host: " + repr(host, imports) + ",\n";
    if (isInt(port)) {
      code += "        port: " + port + ",\n";
    } else {
      code += "        port: " + reprStr(port) + ",\n";
    }
    if (request.proxyAuth) {
      const [proxyUser, proxyPassword] = request.proxyAuth.split(":", 2);
      code += "        auth: {\n";
      code += "            user: " + repr(proxyUser, imports);
      if (proxyPassword !== void 0) {
        code += ",\n";
        code += "            password: " + repr(proxyPassword, imports) + "\n";
      } else {
        code += "\n";
      }
      code += "        },\n";
    }
    if (code.endsWith(",\n")) {
      code = code.slice(0, -2);
      code += "\n";
    }
    code += "    },\n";
  }
  if (code.endsWith(",\n")) {
    code = code.slice(0, -2);
  }
  code += "\n}";
  return code;
}
function _toNodeAxios(requests, warnings = []) {
  const request = getFirst(requests, warnings);
  let importCode = "const axios = require('axios');\n";
  const imports = [];
  let code = "";
  const hasSearchParams = request.urls[0].queryList && (!request.urls[0].queryDict || request.urls[0].queryDict.some((q) => Array.isArray(q[1])));
  if (hasSearchParams && request.urls[0].queryList) {
    code += "const params = new URLSearchParams();\n";
    for (const [key, value] of request.urls[0].queryList) {
      code += "params.append(" + repr(key, imports) + ", " + repr(value, imports) + ");\n";
    }
    code += "\n";
  }
  if (request.multipartUploads) {
    addImport(imports, "FormData", "form-data");
    code += "const form = new FormData();\n";
    for (const m of request.multipartUploads) {
      code += "form.append(" + repr(m.name, imports) + ", ";
      if ("contentFile" in m) {
        addImport(imports, "fs", "fs");
        if (eq(m.contentFile, "-")) {
          code += "fs.readFileSync(0).toString()";
        } else {
          code += "fs.readFileSync(" + repr(m.contentFile, imports) + ")";
        }
        if ("filename" in m && m.filename) {
          code += ", " + repr(m.filename, imports);
        }
      } else {
        code += repr(m.content, imports);
      }
      code += ");\n";
    }
    code += "\n";
  }
  const method = request.urls[0].method.toLowerCase();
  const methodStr = method.toString();
  const methods = ["get", "delete", "head", "options", "post", "put", "patch"];
  code += "const response = await axios";
  if (methods.includes(methodStr)) {
    code += "." + methodStr;
  }
  code += "(";
  const url = request.urls[0].queryDict || hasSearchParams ? request.urls[0].urlWithoutQueryList : request.urls[0].url;
  const dataMethods = ["post", "put", "patch"];
  let needsConfig = !!(!methods.includes(methodStr) || request.urls[0].queryList || request.urls[0].queryDict || request.headers.length || request.urls[0].auth || request.multipartUploads || request.data && !dataMethods.includes(methodStr) || request.timeout || request.proxy);
  const needsData = dataMethods.includes(methodStr) && (request.data || request.multipartUploads || needsConfig);
  let dataString, commentedOutDataString;
  if (needsData) {
    code += "\n";
    code += "    " + repr(url, imports) + ",\n";
    if (request.data) {
      try {
        [dataString, commentedOutDataString] = getDataString3(request, imports);
        if (!dataString) {
          dataString = repr(request.data, imports);
        }
      } catch (_a) {
        dataString = repr(request.data, imports);
      }
      if (commentedOutDataString) {
        code += "    // " + commentedOutDataString + ",\n";
      }
      code += "    " + dataString;
    } else if (request.multipartUploads) {
      code += "    form";
    } else if (needsConfig) {
      code += "    ''";
    }
  } else {
    code += repr(url, imports);
  }
  needsConfig = !!(!methods.includes(methodStr) || request.urls[0].queryList || request.urls[0].queryDict || request.headers.length || request.urls[0].auth || request.multipartUploads || request.data && !dataMethods.includes(methodStr) || request.timeout || request.proxy);
  if (needsConfig) {
    const config2 = buildConfigObject(request, method, methodStr, methods, dataMethods, !!hasSearchParams, imports);
    if (needsData) {
      code += ",\n";
      for (const line of config2.split("\n")) {
        code += "    " + line + "\n";
      }
    } else {
      code += ", ";
      code += config2;
    }
  } else if (needsData) {
    code += "\n";
  }
  code += ");\n";
  importCode += reprImportsRequire(imports);
  return importCode + "\n" + code;
}
function toNodeAxiosWarn(curlCommand, warnings = []) {
  const requests = parseCurlCommand(curlCommand, supportedArgs3, warnings);
  const nodeAxios = _toNodeAxios(requests, warnings);
  return [nodeAxios, warnings];
}
function toNodeAxios(curlCommand) {
  return toNodeAxiosWarn(curlCommand)[0];
}

// node_modules/curlconverter/dist/src/generators/javascript/got.js
var supportedArgs4 = /* @__PURE__ */ new Set([
  ...COMMON_SUPPORTED_ARGS,
  "max-time",
  "connect-timeout",
  "location",
  "no-location",
  "location-trusted",
  "no-location-trusted",
  "max-redirs",
  "compressed",
  "insecure",
  "http2",
  "http2-prior-knowledge",
  "form",
  "form-string"
]);
function getBodyString(request, imports) {
  const exactContentType = request.headers.get("content-type");
  const contentType = request.headers.getContentType();
  if (request.multipartUploads) {
    if (eq(exactContentType, "multipart/form-data")) {
      request.headers.delete("content-type");
    }
    return ["body: form", null];
  }
  if (!request.data) {
    return [null, null];
  }
  const simpleString = "body: " + repr(request.data, imports);
  try {
    if (contentType === "application/json" && request.data.isString()) {
      const dataStr = request.data.toString();
      const parsed = JSON.parse(dataStr);
      const roundtrips = JSON.stringify(parsed) === dataStr;
      const jsonAsJavaScript = "json: " + reprObj(parsed, 1);
      if (roundtrips && eq(exactContentType, "application/json")) {
        request.headers.delete("content-type");
      }
      return [jsonAsJavaScript, roundtrips ? null : simpleString];
    }
    if (contentType === "application/x-www-form-urlencoded") {
      const [queryList, queryDict] = parseQueryString(request.data);
      if (queryDict && queryDict.every((v) => !Array.isArray(v[1]))) {
        if (eq(exactContentType, "application/x-www-form-urlencoded")) {
          request.headers.delete("content-type");
        }
        return [
          "form: " + reprAsStringToStringDict(queryDict, 1, imports),
          null
        ];
      }
      if (queryList) {
        let paramsCode = "body: new URLSearchParams([\n";
        for (const [key, val] of queryList) {
          paramsCode += `        [${repr(key, imports)}, ${repr(val, imports)}],
`;
        }
        if (paramsCode.endsWith(",\n")) {
          paramsCode = paramsCode.slice(0, -2);
          paramsCode += "\n";
        }
        paramsCode += "    ]).toString()";
        return [paramsCode, null];
      }
    }
  } catch (_a) {
  }
  return [simpleString, null];
}
function buildOptionsObject(request, method, methodStr, methods, nonDataMethods, warnings, imports) {
  let code = "{\n";
  if (!method.isString || !methods.includes(methodStr.toUpperCase())) {
    code += "    method: " + repr(method, imports) + ",\n";
  }
  if (request.urls[0].queryDict && request.urls[0].queryDict.every((v) => !Array.isArray(v[1]))) {
    code += "    searchParams: " + reprAsStringToStringDict(request.urls[0].queryDict, 1, imports) + ",\n";
  } else if (request.urls[0].queryList) {
    code += "    searchParams: new URLSearchParams([\n";
    for (const [key, val] of request.urls[0].queryList) {
      code += `        [${repr(key, imports)}, ${repr(val, imports)}],
`;
    }
    if (code.endsWith(",\n")) {
      code = code.slice(0, -2);
      code += "\n";
    }
    code += "    ]),\n";
  }
  const [bodyString, commentedOutBodyString] = getBodyString(request, imports);
  if (request.headers.length) {
    const headers = request.headers.headers.filter((h) => h[1] !== null);
    if (headers.length) {
      code += "    headers: " + reprAsStringToStringDict(headers, 1, imports) + ",\n";
    }
  }
  if (request.urls[0].auth) {
    const [username, password] = request.urls[0].auth;
    code += "    username: " + repr(username, imports) + ",\n";
    if (password.toBool()) {
      code += "    password: " + repr(password, imports) + ",\n";
    }
    if (request.authType !== "basic") {
    }
  }
  if (request.data || request.multipartUploads) {
    if (commentedOutBodyString) {
      code += "    // " + commentedOutBodyString + ",\n";
    }
    code += "    " + bodyString + ",\n";
    if (nonDataMethods.includes(methodStr.toUpperCase())) {
      code += "    allowGetBody: true,\n";
    }
  }
  if (request.timeout || request.connectTimeout) {
    code += "    timeout: {\n";
    if (request.timeout) {
      code += "        request: " + asParseFloatTimes1000(request.timeout, imports) + ",\n";
    }
    if (request.connectTimeout) {
      code += "        connect: " + asParseFloatTimes1000(request.connectTimeout, imports) + ",\n";
    }
    if (code.endsWith(",\n")) {
      code = code.slice(0, -2);
      code += "\n";
    }
    code += "    },\n";
  }
  let followRedirects = request.followRedirects;
  if (followRedirects === void 0) {
    followRedirects = true;
  }
  let maxRedirects = request.maxRedirects ? asParseInt(request.maxRedirects, imports) : null;
  const hasMaxRedirects = followRedirects && maxRedirects && maxRedirects !== "0" && maxRedirects !== "10";
  if (!followRedirects || maxRedirects === "0") {
    code += "    followRedirect: false,\n";
  } else if (maxRedirects) {
    if (maxRedirects === "-1") {
      maxRedirects = "Infinity";
    }
  }
  if (followRedirects && request.followRedirectsTrusted) {
    warnings.push([
      "--location-trusted",
      "got doesn't have an easy way to disable removing the Authorization: header on redirect"
    ]);
  }
  if (hasMaxRedirects) {
    code += "    maxRedirects: " + maxRedirects + ",\n";
  }
  if (request.compressed === false) {
    code += "    decompress: false,\n";
  }
  if (request.insecure) {
    code += "    https: {\n";
    code += "        rejectUnauthorized: false\n";
    code += "    },\n";
  }
  if (request.http2) {
    code += "    http2: true,\n";
  }
  if (code.endsWith(",\n")) {
    code = code.slice(0, -2);
  }
  code += "\n}";
  return code;
}
function _toNodeGot(requests, warnings = []) {
  const request = getFirst(requests, warnings);
  const imports = [];
  let code = "";
  if (request.multipartUploads) {
    code += "const form = new FormData();\n";
    for (const m of request.multipartUploads) {
      code += "form.append(" + repr(m.name, imports) + ", ";
      if ("contentFile" in m) {
        addImport(imports, "* as fs", "fs");
        if (eq(m.contentFile, "-")) {
          code += "fs.readFileSync(0).toString()";
        } else {
          code += "fs.readFileSync(" + repr(m.contentFile, imports) + ")";
        }
        if ("filename" in m && m.filename) {
          code += ", " + repr(m.filename, imports);
        }
      } else {
        code += repr(m.content, imports);
      }
      code += ");\n";
    }
    code += "\n";
    warnings.push(["node-form-data", "Node 18 is required for FormData"]);
  }
  const method = request.urls[0].method;
  const methodStr = method.toString();
  if (method.isString() && methodStr !== methodStr.toUpperCase()) {
    warnings.push([
      "lowercase-method",
      "got will uppercase the method: " + JSON.stringify(methodStr)
    ]);
  }
  const methods = ["GET", "POST", "PUT", "PATCH", "HEAD", "DELETE"];
  const nonDataMethods = ["GET", "HEAD"];
  code += "const response = await got";
  if (method.isString() && methods.includes(methodStr.toUpperCase()) && methodStr.toUpperCase() !== "GET") {
    code += "." + methodStr.toLowerCase();
  }
  code += "(";
  const url = request.urls[0].queryList ? request.urls[0].urlWithoutQueryList : request.urls[0].url;
  code += repr(url, imports);
  const needsOptions = !!(!method.isString() || !methods.includes(methodStr.toUpperCase()) || request.urls[0].queryList || request.urls[0].queryDict || request.headers.length || request.urls[0].auth || request.multipartUploads || request.data || request.followRedirects || request.maxRedirects || request.compressed || request.insecure || request.http2 || request.timeout || request.connectTimeout);
  if (needsOptions) {
    code += ", ";
    code += buildOptionsObject(request, method, methodStr, methods, nonDataMethods, warnings, imports);
  }
  code += ");\n";
  let importCode = "import got from 'got';\n";
  for (const [varName, imp] of Array.from(imports).sort(bySecondElem)) {
    importCode += "import " + varName + " from " + reprStr(imp) + ";\n";
  }
  return importCode + "\n" + code;
}
function toNodeGotWarn(curlCommand, warnings = []) {
  const requests = parseCurlCommand(curlCommand, supportedArgs4, warnings);
  const nodeGot = _toNodeGot(requests, warnings);
  return [nodeGot, warnings];
}
function toNodeGot(curlCommand) {
  return toNodeGotWarn(curlCommand)[0];
}

// node_modules/curlconverter/dist/src/generators/csharp.js
var supportedArgs5 = /* @__PURE__ */ new Set([
  ...COMMON_SUPPORTED_ARGS,
  "compressed",
  "form",
  "form-string",
  "http0.9",
  "http1.0",
  "http1.1",
  "insecure",
  "no-compressed",
  "no-digest",
  "no-http0.9",
  "no-insecure",
  "proxy",
  "upload-file"
]);
var regexEscape2 = /"|\\|\p{C}|\p{Z}/gu;
function reprStr2(s) {
  return '"' + s.replace(regexEscape2, (c) => {
    switch (c) {
      case " ":
        return " ";
      case "\0":
        return "\\0";
      case "\x07":
        return "\\a";
      case "\b":
        return "\\b";
      case "\f":
        return "\\f";
      case "\n":
        return "\\n";
      case "\r":
        return "\\r";
      case "	":
        return "\\t";
      case "\v":
        return "\\v";
      case "\\":
        return "\\\\";
      case '"':
        return '\\"';
    }
    if (c.length === 2) {
      const first = c.charCodeAt(0);
      const second = c.charCodeAt(1);
      return "\\u" + first.toString(16).padStart(4, "0") + "\\u" + second.toString(16).padStart(4, "0");
    }
    const hex = c.charCodeAt(0).toString(16);
    if (hex.length <= 4) {
      return "\\u" + hex.padStart(4, "0");
    }
    return "\\U" + hex.padStart(8, "0");
  }) + '"';
}
function repr3(w, imports) {
  const args = [];
  for (const t of w.tokens) {
    if (typeof t === "string") {
      args.push(reprStr2(t));
    } else if (t.type === "variable") {
      args.push("Environment.GetEnvironmentVariable(" + reprStr2(t.value) + ")");
      imports.add("System");
    } else {
      args.push("System.Diagnostics.Process.Start(" + reprStr2(t.value) + ")");
      imports.add("System.Diagnostics");
    }
  }
  return args.join(" + ");
}
function _toCSharp(requests, warnings = []) {
  const request = getFirst(requests, warnings);
  const imports = /* @__PURE__ */ new Set(["System.Net.Http"]);
  const methods = {
    DELETE: "Delete",
    GET: "Get",
    PATCH: "Patch",
    POST: "Post",
    PUT: "Put"
  };
  const moreMethods = {
    DELETE: "Delete",
    GET: "Get",
    HEAD: "Head",
    OPTIONS: "Options",
    PATCH: "Patch",
    POST: "Post",
    PUT: "Put",
    TRACE: "Trace"
  };
  const method = request.urls[0].method.toString();
  let methodStr = "new HttpMethod(" + repr3(request.urls[0].method, imports) + ")";
  if (has(moreMethods, method)) {
    methodStr = "HttpMethod." + moreMethods[method];
  }
  const simple = has(methods, method) && !(request.headers.length || request.urls[0].auth && request.authType === "basic" || request.multipartUploads || request.data || request.urls[0].uploadFile || request.urls[0].output);
  let s = "";
  if (request.insecure || request.proxy || request.compressed) {
    s += "HttpClientHandler handler = new HttpClientHandler();\n";
    if (request.insecure) {
      s += "handler.ServerCertificateCustomValidationCallback = HttpClientHandler.DangerousAcceptAnyServerCertificateValidator;\n";
    }
    if (request.proxy) {
      s += "handler.Proxy = new WebProxy(" + repr3(request.proxy, imports) + ");\n";
    }
    if (request.compressed) {
      s += "handler.AutomaticDecompression = DecompressionMethods.All;\n";
    }
    s += "\n";
    s += "HttpClient client = new HttpClient(handler);\n\n";
  } else {
    s += "HttpClient client = new HttpClient();\n\n";
  }
  if (simple) {
    if (method === "GET") {
      s += "string responseBody = await client.GetStringAsync(" + repr3(request.urls[0].url, imports) + ");\n";
    } else {
      s += "HttpResponseMessage response = await client." + methods[method] + "Async(" + repr3(request.urls[0].url, imports) + ");\n";
      s += "response.EnsureSuccessStatusCode();\n";
      s += "string responseBody = await response.Content.ReadAsStringAsync();\n";
    }
    return s;
  }
  s += "HttpRequestMessage request = new HttpRequestMessage(" + methodStr + ", " + repr3(request.urls[0].url, imports) + ");\n";
  const contentHeaders = {
    "content-length": "ContentLength",
    "content-location": "ContentLocation",
    "content-md5": "ContentMD5",
    "content-range": "ContentRange",
    "content-type": "ContentType",
    expires: "Expires",
    "last-modified": "LastModified"
  };
  const reqHeaders = request.headers.headers.filter((h) => !Object.keys(contentHeaders).includes(h[0].toLowerCase().toString()));
  const reqContentHeaders = request.headers.headers.filter((h) => Object.keys(contentHeaders).includes(h[0].toLowerCase().toString()));
  if (reqHeaders.length || request.urls[0].auth && request.authType === "basic") {
    s += "\n";
    for (const [headerName, headerValue] of reqHeaders) {
      if (headerValue === null) {
        continue;
      }
      if (["accept-encoding"].includes(headerName.toLowerCase().toString())) {
        s += "// ";
      }
      s += "request.Headers.Add(" + repr3(headerName, imports) + ", " + repr3(headerValue, imports) + ");\n";
    }
    if (request.urls[0].auth && request.authType === "basic") {
      s += 'request.Headers.Add("Authorization", "Basic " + Convert.ToBase64String(System.Text.ASCIIEncoding.ASCII.GetBytes(' + repr3(joinWords(request.urls[0].auth, ":"), imports) + ")));\n";
    }
    s += "\n";
  }
  if (request.urls[0].uploadFile) {
    s += "request.Content = new ByteArrayContent(File.ReadAllBytes(" + repr3(request.urls[0].uploadFile, imports) + "));\n";
  } else if (request.data) {
    if (!request.isDataRaw && request.data.startsWith("@")) {
      s += "request.Content = new StringContent(File.ReadAllText(" + repr3(request.data.slice(1), imports) + ').Replace("\\n", string.Empty).Replace("\\r", string.Empty));\n';
    } else {
      s += "request.Content = new StringContent(" + repr3(request.data, imports) + ");\n";
    }
  } else if (request.multipartUploads) {
    s += "\n";
    s += "MultipartFormDataContent content = new MultipartFormDataContent();\n";
    for (const m of request.multipartUploads) {
      const name = repr3(m.name, imports);
      const sentFilename = "filename" in m && m.filename;
      s += "content.Add(new ";
      if ("contentFile" in m) {
        if (eq(m.contentFile, "-")) {
          if (request.stdinFile) {
            s += "ByteArrayContent(File.ReadAllBytes(" + repr3(request.stdinFile, imports) + ")), " + name;
            if (sentFilename) {
              s += ", Path.GetFileName(" + repr3(sentFilename, imports) + ")";
            }
            s += ");\n";
          } else if (request.stdin) {
            s += "StringContent(" + repr3(request.stdin, imports) + "), " + name;
            if (sentFilename) {
              s += ", Path.GetFileName(" + repr3(sentFilename, imports) + ")";
            }
            s += ");\n";
          } else {
            s += "StringContent(Console.ReadLine()), " + name;
            if (sentFilename) {
              s += ", Path.GetFileName(" + repr3(sentFilename, imports) + ")";
            }
            s += ");\n";
          }
        } else {
          s += "ByteArrayContent(File.ReadAllBytes(" + repr3(m.contentFile, imports) + ")), " + name;
          if (sentFilename) {
            s += ", Path.GetFileName(" + repr3(sentFilename, imports) + ")";
          }
          s += ");\n";
        }
      } else {
        s += "StringContent(" + repr3(m.content, imports) + "), " + name + ");\n";
      }
    }
    s += "request.Content = content;\n";
  } else if (request.headers.has("content-type")) {
    s += 'request.Content = new StringContent("");\n';
  }
  if (reqContentHeaders.length) {
    for (const [headerName, headerValue] of reqContentHeaders) {
      if (headerValue === null) {
        continue;
      }
      const headerNameLower = headerName.toLowerCase().toString();
      if (headerNameLower === "content-type") {
        imports.add("System.Net.Http.Headers");
        if (headerValue.includes(";")) {
          s += "request.Content.Headers.ContentType = MediaTypeHeaderValue.Parse(" + repr3(headerValue, imports) + ");\n";
        } else {
          s += "request.Content.Headers.ContentType = new MediaTypeHeaderValue(" + repr3(headerValue, imports) + ");\n";
        }
      } else if (headerNameLower === "content-length") {
        if (headerValue.isString() && !isInt(headerValue.toString())) {
          warnings.push([
            "content-length-not-int",
            "Content-Length header value is not a number: " + repr3(headerValue, imports)
          ]);
        }
        s += "// request.Content.Headers.ContentLength = " + headerValue.split("\n")[0].toString() + ";\n";
      } else if (has(contentHeaders, headerNameLower)) {
        s += "request.Content.Headers." + contentHeaders[headerNameLower] + " = " + repr3(headerValue, imports) + ";\n";
      }
    }
  }
  if (request.urls[0].uploadFile || request.data || request.multipartUploads || reqContentHeaders.length) {
    s += "\n";
  }
  s += "HttpResponseMessage response = await client.SendAsync(request);\n";
  s += "response.EnsureSuccessStatusCode();\n";
  s += "string responseBody = await response.Content.ReadAsStringAsync();\n";
  if (imports.size) {
    s = "using " + [...imports].sort().join(";\nusing ") + ";\n\n" + s;
  }
  return s;
}
function toCSharpWarn(curlCommand, warnings = []) {
  const requests = parseCurlCommand(curlCommand, supportedArgs5, warnings);
  const cSharp = _toCSharp(requests, warnings);
  return [cSharp, warnings];
}
function toCSharp(curlCommand) {
  return toCSharpWarn(curlCommand)[0];
}

// node_modules/curlconverter/dist/src/generators/dart.js
var supportedArgs6 = /* @__PURE__ */ new Set([
  ...COMMON_SUPPORTED_ARGS,
  "compressed",
  "form",
  "form-string",
  "no-compressed"
]);
function escape(value, quote) {
  return esc(value, quote).replace(/\$/g, "\\$");
}
function reprStr3(value) {
  const quote = value.includes("'") && !value.includes('"') ? '"' : "'";
  return quote + escape(value, quote) + quote;
}
function repr4(value, imports) {
  const ret = [];
  for (const t of value.tokens) {
    if (typeof t === "string") {
      ret.push(reprStr3(t));
    } else if (t.type === "variable") {
      ret.push("(Platform.environment[" + reprStr3(t.value) + "] ?? '')");
      imports.add("dart:io");
    } else {
      ret.push("(await Process.run(" + reprStr3(t.value) + ", runInShell: true)).stdout");
      imports.add("dart:io");
    }
  }
  return ret.join(" + ");
}
function _toDart(requests, warnings = []) {
  const request = getFirst(requests, warnings);
  const imports = /* @__PURE__ */ new Set();
  if (request.urls[0].auth || request.isDataBinary)
    imports.add("dart:convert");
  let s = "void main() async {\n";
  if (request.urls[0].auth) {
    const [uname, pword] = request.urls[0].auth;
    s += "  var uname = " + repr4(uname, imports) + ";\n  var pword = " + repr4(pword, imports) + ";\n  var authn = 'Basic ' + base64Encode(utf8.encode('$uname:$pword'));\n\n";
  }
  const methods = ["HEAD", "GET", "POST", "PUT", "PATCH", "DELETE"];
  const rawRequestObj = request.multipartUploads || !methods.includes(request.urls[0].method.toString());
  const hasHeaders = request.headers.length || request.compressed || request.isDataBinary || request.urls[0].method.toLowerCase().toString() === "put";
  if (hasHeaders && !rawRequestObj) {
    s += "  var headers = {\n";
    for (const [hname, hval] of request.headers) {
      s += "    " + repr4(hname, imports) + ": " + repr4(hval !== null && hval !== void 0 ? hval : new Word(), imports) + ",\n";
    }
    if (request.urls[0].auth)
      s += "    'Authorization': authn,\n";
    if (request.compressed)
      s += "    'Accept-Encoding': 'gzip',\n";
    s += "  };\n";
    s += "\n";
  }
  const queryIsRepresentable = request.urls[0].queryList && request.urls[0].queryDict && Object.values(request.urls[0].queryDict).every((v) => !Array.isArray(v));
  if (queryIsRepresentable && request.urls[0].queryList) {
    s += "  var params = {\n";
    for (const [paramName, rawValue] of request.urls[0].queryList) {
      const paramValue = repr4(rawValue !== null && rawValue !== void 0 ? rawValue : new Word(), imports);
      s += "    " + repr4(paramName, imports) + ": " + paramValue + ",\n";
    }
    s += "  };\n";
    s += "  var query = params.entries.map((p) => '${p.key}=${p.value}').join('&');\n";
    s += "\n";
  }
  const hasData = request.data;
  if (request.data) {
    const [parsedQuery] = parseQueryString(request.data);
    if (parsedQuery && parsedQuery.length) {
      s += "  var data = {\n";
      for (const param of parsedQuery) {
        const [key, val] = param;
        s += "    " + repr4(key, imports) + ": " + repr4(val, imports) + ",\n";
      }
      s += "  };\n";
      s += "\n";
    } else {
      s += `  var data = ${repr4(request.data, imports)};

`;
    }
  }
  if (queryIsRepresentable) {
    let urlString = repr4(request.urls[0].urlWithoutQueryList, imports);
    if (urlString.endsWith("'") || urlString.endsWith('"')) {
      urlString = urlString.slice(0, -1) + "?$query" + urlString.slice(-1);
    } else {
      urlString += " + '?$query'";
    }
    s += "  var url = Uri.parse(" + urlString + ");\n";
  } else {
    s += "  var url = Uri.parse(" + repr4(request.urls[0].url, imports) + ");\n";
  }
  if (rawRequestObj) {
    let multipart = "http.";
    if (request.multipartUploads) {
      multipart += "MultipartRequest";
    } else {
      multipart += "Request";
    }
    multipart += "(" + repr4(request.urls[0].method, imports) + ", url)\n";
    for (const m of request.multipartUploads || []) {
      const name = repr4(m.name, imports);
      const sentFilename = "filename" in m && m.filename;
      if ("contentFile" in m) {
        multipart += "    ..files.add(await http.MultipartFile.";
        if (eq(m.contentFile, "-")) {
          if (request.stdinFile) {
            multipart += "fromPath(\n";
            multipart += "      " + name + ", " + repr4(request.stdinFile, imports);
            if (sentFilename && request.stdinFile !== sentFilename) {
              multipart += ",\n";
              multipart += "      filename: " + repr4(sentFilename, imports);
            }
            multipart += "))\n";
          } else if (request.stdin) {
            multipart += "fromString(\n";
            multipart += "      " + name + ", " + repr4(request.stdin, imports);
            if (sentFilename) {
              multipart += ",\n";
              multipart += "      filename: " + repr4(sentFilename, imports);
            }
            multipart += "))\n";
          } else {
            multipart += "fromString(\n";
            multipart += "      " + name + ", stdin.readLineSync(encoding: utf8)";
            if (sentFilename) {
              multipart += ",\n";
              multipart += "      filename: " + repr4(sentFilename, imports);
            }
            multipart += "))\n";
            imports.add("dart:io");
            imports.add("dart:convert");
          }
        } else {
          multipart += "fromPath(\n";
          multipart += "      " + name + ", " + repr4(m.contentFile, imports);
          if (sentFilename && m.contentFile !== sentFilename) {
            multipart += ",\n";
            multipart += "      filename: " + repr4(sentFilename, imports);
          }
          multipart += "))\n";
        }
      } else {
        multipart += "    ..fields[" + name + "] = " + repr4(m.content, imports) + "\n";
      }
    }
    if (hasHeaders || request.urls[0].auth) {
      s += "  var req = new " + multipart;
      for (const [hname, hval] of request.headers) {
        s += "  req.headers[" + repr4(hname, imports) + "] = " + repr4(hval || new Word(), imports) + ";\n";
      }
      if (request.urls[0].auth) {
        s += "  req.headers['Authorization'] = authn;\n";
      }
      s += "  var res = await req.send();\n";
    } else {
      s += "  var res = await " + multipart;
    }
    s += "  if (res.statusCode != 200) throw Exception('http.send error: statusCode= ${res.statusCode}');\n  print(res.body);\n}";
  } else {
    s += "  var res = await http." + request.urls[0].method.toLowerCase().toString() + "(url";
    if (hasHeaders)
      s += ", headers: headers";
    else if (request.urls[0].auth)
      s += ", headers: {'Authorization': authn}";
    if (hasData)
      s += ", body: data";
    s += ");\n";
    s += "  if (res.statusCode != 200) throw Exception('http." + request.urls[0].method.toLowerCase().toString() + " error: statusCode= ${res.statusCode}');\n  print(res.body);\n}";
  }
  let importString = "";
  for (const imp of Array.from(imports).sort()) {
    importString += "import '" + imp + "';\n";
  }
  importString += "import 'package:http/http.dart' as http;\n";
  return importString + "\n" + s + "\n";
}
function toDartWarn(curlCommand, warnings = []) {
  const requests = parseCurlCommand(curlCommand, supportedArgs6, warnings);
  const dart = _toDart(requests, warnings);
  return [dart, warnings];
}
function toDart(curlCommand) {
  return toDartWarn(curlCommand)[0];
}

// node_modules/curlconverter/dist/src/generators/elixir.js
var supportedArgs7 = /* @__PURE__ */ new Set([
  ...COMMON_SUPPORTED_ARGS,
  "form",
  "form-string",
  "insecure",
  "no-insecure",
  "next"
]);
var regexEscape3 = /"|\\|\p{C}|\p{Z}|#\{/gu;
function reprStr4(s) {
  return '"' + s.replace(regexEscape3, (c) => {
    switch (c[0]) {
      case " ":
        return " ";
      case "\0":
        return "\\0";
      case "\x07":
        return "\\a";
      case "\b":
        return "\\b";
      case "\f":
        return "\\f";
      case "\n":
        return "\\n";
      case "\r":
        return "\\r";
      case "	":
        return "\\t";
      case "\v":
        return "\\v";
      case "\x1B":
        return "\\e";
      case "\\":
        return "\\\\";
      case '"':
        return '\\"';
      case "#":
        return "\\" + c;
    }
    const hex = c.codePointAt(0).toString(16);
    if (hex.length <= 4) {
      return "\\u" + hex.padStart(4, "0");
    }
    return "\\u{" + hex + "}";
  }) + '"';
}
function repr5(w) {
  const args = [];
  for (const t of w.tokens) {
    if (typeof t === "string") {
      args.push(reprStr4(t));
    } else if (t.type === "variable") {
      args.push("System.get_env(" + reprStr4(t.value) + ', "")');
    } else {
      args.push("elem(System.shell(" + reprStr4(t.value) + "), 0)");
    }
  }
  return args.join(" <> ");
}
function addIndent(value) {
  return value.split("\n").map((line) => line ? "  " + line : line).join("\n");
}
function getCookies(request) {
  if (!request.cookies || !request.cookies.length) {
    return "";
  }
  const cookies = joinWords(request.cookies.map((c) => joinWords(c, "=")), "; ");
  return `cookie: [${repr5(cookies)}]`;
}
function getOptions(request, params) {
  const hackneyOptions = [];
  const auth = getBasicAuth(request);
  if (auth) {
    hackneyOptions.push(auth);
  }
  if (request.insecure) {
    hackneyOptions.push(":insecure");
  }
  const cookies = getCookies(request);
  if (cookies) {
    hackneyOptions.push(cookies);
  }
  let hackneyOptionsString = "";
  if (hackneyOptions.length > 1) {
    hackneyOptionsString = `hackney: [
    ${hackneyOptions.join(",\n    ")}
  ]`;
  } else if (hackneyOptions.length) {
    hackneyOptionsString = `hackney: [${hackneyOptions[0]}]`;
  }
  const optionsWithoutParams = `[${hackneyOptionsString}]`;
  let options = optionsWithoutParams;
  if (params !== "[]") {
    options = "";
    options += "[\n";
    options += "    params: " + addIndent(params).trim();
    if (hackneyOptionsString) {
      options += ",\n";
      options += "    " + addIndent(hackneyOptionsString).trim();
    }
    options += "\n";
    options += "  ]";
  }
  return [options, optionsWithoutParams];
}
function getBasicAuth(request) {
  if (!request.urls[0].auth) {
    return "";
  }
  const [user, password] = request.urls[0].auth;
  return `basic_auth: {${repr5(user)}, ${repr5(password)}}`;
}
function getQueryDict(request) {
  if (!request.urls[0].queryList || !request.urls[0].queryList.length) {
    return "[]";
  }
  let queryDict = "[\n";
  const queryDictLines = [];
  for (const [paramName, rawValue] of request.urls[0].queryList) {
    queryDictLines.push(`    {${repr5(paramName)}, ${repr5(rawValue)}}`);
  }
  queryDict += queryDictLines.join(",\n");
  queryDict += "\n  ]";
  return queryDict;
}
function getHeadersDict(request) {
  if (!request.headers.length) {
    return "[]";
  }
  let dict = "[\n";
  const dictLines = [];
  for (const [headerName, headerValue] of request.headers) {
    dictLines.push(`    {${repr5(headerName)}, ${repr5(headerValue !== null && headerValue !== void 0 ? headerValue : new Word())}}`);
  }
  dict += dictLines.join(",\n");
  dict += "\n  ]";
  return dict;
}
function getBody(request) {
  const formData = getFormDataString(request);
  return formData ? formData : '""';
}
function getFormDataString(request) {
  var _a;
  if (request.data) {
    return getDataString4(request);
  }
  if (!request.multipartUploads) {
    return "";
  }
  if (!request.multipartUploads.length) {
    return `{:multipart, []}`;
  }
  const formParams = [];
  for (const m of request.multipartUploads) {
    if ("contentFile" in m) {
      formParams.push(`    {:file, ${repr5(m.contentFile)}, {"form-data", [{:name, ${repr5(m.name)}}, {:filename, Path.basename(${repr5((_a = m.filename) !== null && _a !== void 0 ? _a : m.contentFile)})}]}, []}`);
    } else {
      formParams.push(`    {${repr5(m.name)}, ${repr5(m.content)}}`);
    }
  }
  const formStr = formParams.join(",\n");
  if (formStr) {
    return `{:multipart, [
${formStr}
  ]}`;
  }
  return "";
}
function getDataString4(request) {
  if (!request.data) {
    return "";
  }
  if (!request.isDataRaw && request.data.startsWith("@")) {
    const filePath = request.data.slice(1);
    if (request.isDataBinary) {
      return `File.read!(${repr5(filePath)})`;
    } else {
      return `{:file, ${repr5(filePath)}}`;
    }
  }
  const [parsedQuery] = parseQueryString(request.data);
  if (parsedQuery && parsedQuery.length) {
    const data = parsedQuery.map((p) => {
      const [key, value] = p;
      return `    {${repr5(key)}, ${repr5(value)}}`;
    });
    return `{:form, [
${data.join(",\n")}
  ]}`;
  }
  if (request.data.isString() && !request.data.includes("|") && request.data.split("\n", 4).length > 3 && !request.data.match(/[^\S\r\n]\n/)) {
    return "~s|" + request.data.toString() + "|";
  }
  return repr5(request.data);
}
function requestToElixir(request, warnings = []) {
  warnIfPartsIgnored(request, warnings);
  if (request.cookies) {
    request.headers.delete("cookie");
  }
  const methods = ["DELETE", "GET", "HEAD", "OPTIONS", "PATCH", "POST", "PUT"];
  const bodyMethods = ["PATCH", "POST", "PUT"];
  const method = request.urls[0].method;
  const methodStr = method.toString();
  if (!methods.includes(methodStr)) {
    warnings.push([
      "bad-method",
      "Unsupported method " + JSON.stringify(methodStr)
    ]);
  }
  const isBodyMethod = bodyMethods.includes(methodStr);
  const body = getBody(request);
  const headers = getHeadersDict(request);
  const params = getQueryDict(request);
  const [options, optionsWithoutParams] = getOptions(request, params);
  if (isBodyMethod || body === '""' && methods.includes(methodStr)) {
    let args = [];
    let keepArgs = false;
    keepArgs || (keepArgs = options !== "[]");
    if (keepArgs) {
      args.push(options);
    }
    keepArgs || (keepArgs = headers !== "[]");
    if (keepArgs) {
      args.push(headers);
    }
    keepArgs || (keepArgs = body !== '""');
    if (keepArgs && isBodyMethod) {
      args.push(body);
    }
    args.push(repr5(request.urls[0].urlWithoutQueryList));
    args = args.reverse();
    let s = "response = HTTPoison." + methodStr.toLowerCase() + "!(";
    if (args.length === 1) {
      s += args[0];
    } else {
      s += "\n";
      s += "  " + args.join(",\n  ");
      s += "\n";
    }
    return s + ")\n";
  }
  return `request = %HTTPoison.Request{
  method: :${method.toLowerCase().toString()},
  url: ${repr5(request.urls[0].urlWithoutQueryList)},
  body: ${body},
  headers: ${headers},
  options: ${optionsWithoutParams},
  params: ${params}
}

response = HTTPoison.request(request)
`;
}
function _toElixir(requests, warnings = []) {
  return requests.map((r) => requestToElixir(r, warnings)).join("\n");
}
function toElixirWarn(curlCommand, warnings = []) {
  const requests = parseCurlCommand(curlCommand, supportedArgs7, warnings);
  const elixir = _toElixir(requests, warnings);
  return [elixir, warnings];
}
function toElixir(curlCommand) {
  return toElixirWarn(curlCommand)[0];
}

// node_modules/lossless-json/lib/esm/utils.js
function isInteger(value) {
  return INTEGER_REGEX.test(value);
}
var INTEGER_REGEX = /^-?[0-9]+$/;
function isNumber(value) {
  return NUMBER_REGEX.test(value);
}
var NUMBER_REGEX = /^-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?$/;
function isSafeNumber(value, config2) {
  var num = parseFloat(value);
  var str = String(num);
  var v = extractSignificantDigits(value);
  var s = extractSignificantDigits(str);
  if (v === s) {
    return true;
  }
  if ((config2 === null || config2 === void 0 ? void 0 : config2.approx) === true) {
    var requiredDigits = 14;
    if (!isInteger(value) && s.length >= requiredDigits && v.startsWith(s.substring(0, requiredDigits))) {
      return true;
    }
  }
  return false;
}
var UnsafeNumberReason;
(function(UnsafeNumberReason2) {
  UnsafeNumberReason2["underflow"] = "underflow";
  UnsafeNumberReason2["overflow"] = "overflow";
  UnsafeNumberReason2["truncate_integer"] = "truncate_integer";
  UnsafeNumberReason2["truncate_float"] = "truncate_float";
})(UnsafeNumberReason || (UnsafeNumberReason = {}));
function getUnsafeNumberReason(value) {
  if (isSafeNumber(value, {
    approx: false
  })) {
    return void 0;
  }
  if (isInteger(value)) {
    return UnsafeNumberReason.truncate_integer;
  }
  var num = parseFloat(value);
  if (!isFinite(num)) {
    return UnsafeNumberReason.overflow;
  }
  if (num === 0) {
    return UnsafeNumberReason.underflow;
  }
  return UnsafeNumberReason.truncate_float;
}
function extractSignificantDigits(value) {
  return value.replace(EXPONENTIAL_PART_REGEX, "").replace(DOT_REGEX, "").replace(TRAILING_ZEROS_REGEX, "").replace(LEADING_MINUS_AND_ZEROS_REGEX, "");
}
var EXPONENTIAL_PART_REGEX = /[eE][+-]?\d+$/;
var LEADING_MINUS_AND_ZEROS_REGEX = /^-?(0*)?/;
var DOT_REGEX = /\./;
var TRAILING_ZEROS_REGEX = /0+$/;

// node_modules/lossless-json/lib/esm/LosslessNumber.js
function _typeof(obj) {
  "@babel/helpers - typeof";
  return _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof(obj);
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return _typeof(key) === "symbol" ? key : String(key);
}
function _toPrimitive(input, hint) {
  if (_typeof(input) !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (_typeof(res) !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
var LosslessNumber = function() {
  function LosslessNumber2(value) {
    _classCallCheck(this, LosslessNumber2);
    _defineProperty(this, "isLosslessNumber", true);
    if (!isNumber(value)) {
      throw new Error('Invalid number (value: "' + value + '")');
    }
    this.value = value;
  }
  _createClass(LosslessNumber2, [{
    key: "valueOf",
    value: function valueOf() {
      var unsafeReason = getUnsafeNumberReason(this.value);
      if (unsafeReason === void 0 || unsafeReason === UnsafeNumberReason.truncate_float) {
        return parseFloat(this.value);
      }
      if (isInteger(this.value)) {
        return BigInt(this.value);
      }
      throw new Error("Cannot safely convert to number: " + "the value '".concat(this.value, "' would ").concat(unsafeReason, " and become ").concat(parseFloat(this.value)));
    }
  }, {
    key: "toString",
    value: function toString() {
      return this.value;
    }
  }]);
  return LosslessNumber2;
}();
function isLosslessNumber(value) {
  return value && _typeof(value) === "object" && value.isLosslessNumber === true || false;
}

// node_modules/lossless-json/lib/esm/numberParsers.js
function parseLosslessNumber(value) {
  return new LosslessNumber(value);
}

// node_modules/lossless-json/lib/esm/revive.js
function _typeof2(obj) {
  "@babel/helpers - typeof";
  return _typeof2 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof2(obj);
}
function revive(json, reviver) {
  return reviveValue({
    "": json
  }, "", json, reviver);
}
function reviveValue(context, key, value, reviver) {
  if (Array.isArray(value)) {
    return reviver.call(context, key, reviveArray(value, reviver));
  } else if (value && _typeof2(value) === "object" && !isLosslessNumber(value)) {
    return reviver.call(context, key, reviveObject(value, reviver));
  } else {
    return reviver.call(context, key, value);
  }
}
function reviveObject(object, reviver) {
  Object.keys(object).forEach(function(key) {
    var value = reviveValue(object, key, object[key], reviver);
    if (value !== void 0) {
      object[key] = value;
    } else {
      delete object[key];
    }
  });
  return object;
}
function reviveArray(array, reviver) {
  for (var i = 0; i < array.length; i++) {
    array[i] = reviveValue(array, i + "", array[i], reviver);
  }
  return array;
}

// node_modules/lossless-json/lib/esm/parse.js
function parse(text, reviver) {
  var parseNumber = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : parseLosslessNumber;
  var i = 0;
  var value = parseValue();
  expectValue(value);
  expectEndOfInput();
  return reviver ? revive(value, reviver) : value;
  function parseObject() {
    if (text.charCodeAt(i) === codeOpeningBrace) {
      i++;
      skipWhitespace();
      var object = {};
      var initial = true;
      while (i < text.length && text.charCodeAt(i) !== codeClosingBrace) {
        if (!initial) {
          eatComma();
          skipWhitespace();
        } else {
          initial = false;
        }
        var key = parseString();
        if (key === void 0) {
          throwObjectKeyExpected();
        }
        if (Object.prototype.hasOwnProperty.call(object, key)) {
          throwDuplicateKey(key);
        }
        skipWhitespace();
        eatColon();
        object[key] = parseValue();
      }
      if (text.charCodeAt(i) !== codeClosingBrace) {
        throwObjectKeyOrEndExpected();
      }
      i++;
      return object;
    }
  }
  function parseArray() {
    if (text.charCodeAt(i) === codeOpeningBracket) {
      i++;
      skipWhitespace();
      var array = [];
      var initial = true;
      while (i < text.length && text.charCodeAt(i) !== codeClosingBracket) {
        if (!initial) {
          eatComma();
        } else {
          initial = false;
        }
        var _value = parseValue();
        expectArrayItem(_value);
        array.push(_value);
      }
      if (text.charCodeAt(i) !== codeClosingBracket) {
        throwArrayItemOrEndExpected();
      }
      i++;
      return array;
    }
  }
  function parseValue() {
    var _ref, _ref2, _ref3, _ref4, _ref5, _parseString;
    skipWhitespace();
    var value2 = (_ref = (_ref2 = (_ref3 = (_ref4 = (_ref5 = (_parseString = parseString()) !== null && _parseString !== void 0 ? _parseString : parseNumeric()) !== null && _ref5 !== void 0 ? _ref5 : parseObject()) !== null && _ref4 !== void 0 ? _ref4 : parseArray()) !== null && _ref3 !== void 0 ? _ref3 : parseKeyword("true", true)) !== null && _ref2 !== void 0 ? _ref2 : parseKeyword("false", false)) !== null && _ref !== void 0 ? _ref : parseKeyword("null", null);
    skipWhitespace();
    return value2;
  }
  function parseKeyword(name, value2) {
    if (text.slice(i, i + name.length) === name) {
      i += name.length;
      return value2;
    }
  }
  function skipWhitespace() {
    while (isWhitespace(text.charCodeAt(i))) {
      i++;
    }
  }
  function parseString() {
    if (text.charCodeAt(i) === codeDoubleQuote) {
      i++;
      var result = "";
      while (i < text.length && text.charCodeAt(i) !== codeDoubleQuote) {
        if (text.charCodeAt(i) === codeBackslash) {
          var char = text[i + 1];
          var escapeChar = escapeCharacters[char];
          if (escapeChar !== void 0) {
            result += escapeChar;
            i++;
          } else if (char === "u") {
            if (isHex(text.charCodeAt(i + 2)) && isHex(text.charCodeAt(i + 3)) && isHex(text.charCodeAt(i + 4)) && isHex(text.charCodeAt(i + 5))) {
              result += String.fromCharCode(parseInt(text.slice(i + 2, i + 6), 16));
              i += 5;
            } else {
              throwInvalidUnicodeCharacter(i);
            }
          } else {
            throwInvalidEscapeCharacter(i);
          }
        } else {
          if (isValidStringCharacter(text.charCodeAt(i))) {
            result += text[i];
          } else {
            throwInvalidCharacter(text[i]);
          }
        }
        i++;
      }
      expectEndOfString();
      i++;
      return result;
    }
  }
  function parseNumeric() {
    var start = i;
    if (text.charCodeAt(i) === codeMinus) {
      i++;
      expectDigit(start);
    }
    if (text.charCodeAt(i) === codeZero) {
      i++;
    } else if (isNonZeroDigit(text.charCodeAt(i))) {
      i++;
      while (isDigit(text.charCodeAt(i))) {
        i++;
      }
    }
    if (text.charCodeAt(i) === codeDot) {
      i++;
      expectDigit(start);
      while (isDigit(text.charCodeAt(i))) {
        i++;
      }
    }
    if (text.charCodeAt(i) === codeLowercaseE || text.charCodeAt(i) === codeUppercaseE) {
      i++;
      if (text.charCodeAt(i) === codeMinus || text.charCodeAt(i) === codePlus) {
        i++;
      }
      expectDigit(start);
      while (isDigit(text.charCodeAt(i))) {
        i++;
      }
    }
    if (i > start) {
      return parseNumber(text.slice(start, i));
    }
  }
  function eatComma() {
    if (text.charCodeAt(i) !== codeComma) {
      throw new SyntaxError("Comma ',' expected after value ".concat(gotAt()));
    }
    i++;
  }
  function eatColon() {
    if (text.charCodeAt(i) !== codeColon) {
      throw new SyntaxError("Colon ':' expected after property name ".concat(gotAt()));
    }
    i++;
  }
  function expectValue(value2) {
    if (value2 === void 0) {
      throw new SyntaxError("JSON value expected ".concat(gotAt()));
    }
  }
  function expectArrayItem(value2) {
    if (value2 === void 0) {
      throw new SyntaxError("Array item expected ".concat(gotAt()));
    }
  }
  function expectEndOfInput() {
    if (i < text.length) {
      throw new SyntaxError("Expected end of input ".concat(gotAt()));
    }
  }
  function expectDigit(start) {
    if (!isDigit(text.charCodeAt(i))) {
      var numSoFar = text.slice(start, i);
      throw new SyntaxError("Invalid number '".concat(numSoFar, "', expecting a digit ").concat(gotAt()));
    }
  }
  function expectEndOfString() {
    if (text.charCodeAt(i) !== codeDoubleQuote) {
      throw new SyntaxError(`End of string '"' expected `.concat(gotAt()));
    }
  }
  function throwObjectKeyExpected() {
    throw new SyntaxError("Quoted object key expected ".concat(gotAt()));
  }
  function throwDuplicateKey(key) {
    throw new SyntaxError("Duplicate key '".concat(key, "' encountered at position ").concat(i - key.length - 1));
  }
  function throwObjectKeyOrEndExpected() {
    throw new SyntaxError("Quoted object key or end of object '}' expected ".concat(gotAt()));
  }
  function throwArrayItemOrEndExpected() {
    throw new SyntaxError("Array item or end of array ']' expected ".concat(gotAt()));
  }
  function throwInvalidCharacter(char) {
    throw new SyntaxError("Invalid character '".concat(char, "' ").concat(pos()));
  }
  function throwInvalidEscapeCharacter(start) {
    var chars = text.slice(start, start + 2);
    throw new SyntaxError("Invalid escape character '".concat(chars, "' ").concat(pos()));
  }
  function throwInvalidUnicodeCharacter(start) {
    var end = start + 2;
    while (/\w/.test(text[end])) {
      end++;
    }
    var chars = text.slice(start, end);
    throw new SyntaxError("Invalid unicode character '".concat(chars, "' ").concat(pos()));
  }
  function pos() {
    return "at position ".concat(i);
  }
  function got() {
    return i < text.length ? "but got '".concat(text[i], "'") : "but reached end of input";
  }
  function gotAt() {
    return got() + " " + pos();
  }
}
function isWhitespace(code) {
  return code === codeSpace || code === codeNewline || code === codeTab || code === codeReturn;
}
function isHex(code) {
  return code >= codeZero && code <= codeNine || code >= codeUppercaseA && code <= codeUppercaseF || code >= codeLowercaseA && code <= codeLowercaseF;
}
function isDigit(code) {
  return code >= codeZero && code <= codeNine;
}
function isNonZeroDigit(code) {
  return code >= codeOne && code <= codeNine;
}
function isValidStringCharacter(code) {
  return code >= 32 && code <= 1114111;
}
var escapeCharacters = {
  '"': '"',
  "\\": "\\",
  "/": "/",
  b: "\b",
  f: "\f",
  n: "\n",
  r: "\r",
  t: "	"
};
var codeBackslash = 92;
var codeOpeningBrace = 123;
var codeClosingBrace = 125;
var codeOpeningBracket = 91;
var codeClosingBracket = 93;
var codeSpace = 32;
var codeNewline = 10;
var codeTab = 9;
var codeReturn = 13;
var codeDoubleQuote = 34;
var codePlus = 43;
var codeMinus = 45;
var codeZero = 48;
var codeOne = 49;
var codeNine = 57;
var codeComma = 44;
var codeDot = 46;
var codeColon = 58;
var codeUppercaseA = 65;
var codeLowercaseA = 97;
var codeUppercaseE = 69;
var codeLowercaseE = 101;
var codeUppercaseF = 70;
var codeLowercaseF = 102;

// node_modules/lossless-json/lib/esm/stringify.js
function _typeof3(obj) {
  "@babel/helpers - typeof";
  return _typeof3 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof3(obj);
}
function stringify(value, replacer, space, numberStringifiers) {
  var resolvedSpace = resolveSpace(space);
  var replacedValue = typeof replacer === "function" ? replacer.call({
    "": value
  }, "", value) : value;
  return stringifyValue(replacedValue, "");
  function stringifyValue(value2, indent3) {
    if (Array.isArray(numberStringifiers)) {
      var stringifier = numberStringifiers.find(function(item) {
        return item.test(value2);
      });
      if (stringifier) {
        var str = stringifier.stringify(value2);
        if (typeof str !== "string" || !isNumber(str)) {
          throw new Error("Invalid JSON number: output of a number stringifier must be a string containing a JSON number " + "(output: ".concat(str, ")"));
        }
        return str;
      }
    }
    if (typeof value2 === "boolean" || typeof value2 === "number" || typeof value2 === "string" || value2 === null || value2 instanceof Date || value2 instanceof Boolean || value2 instanceof Number || value2 instanceof String) {
      return JSON.stringify(value2);
    }
    if (value2 && value2.isLosslessNumber) {
      return value2.toString();
    }
    if (typeof value2 === "bigint") {
      return value2.toString();
    }
    if (Array.isArray(value2)) {
      return stringifyArray(value2, indent3);
    }
    if (value2 && _typeof3(value2) === "object") {
      return stringifyObject(value2, indent3);
    }
    return void 0;
  }
  function stringifyArray(array, indent3) {
    if (array.length === 0) {
      return "[]";
    }
    var childIndent = resolvedSpace ? indent3 + resolvedSpace : void 0;
    var str = resolvedSpace ? "[\n" : "[";
    for (var i = 0; i < array.length; i++) {
      var item = typeof replacer === "function" ? replacer.call(array, String(i), array[i]) : array[i];
      if (resolvedSpace) {
        str += childIndent;
      }
      if (typeof item !== "undefined" && typeof item !== "function") {
        str += stringifyValue(item, childIndent);
      } else {
        str += "null";
      }
      if (i < array.length - 1) {
        str += resolvedSpace ? ",\n" : ",";
      }
    }
    str += resolvedSpace ? "\n" + indent3 + "]" : "]";
    return str;
  }
  function stringifyObject(object, indent3) {
    if (typeof object.toJSON === "function") {
      return stringify(object.toJSON(), replacer, space, void 0);
    }
    var keys = Array.isArray(replacer) ? replacer.map(String) : Object.keys(object);
    if (keys.length === 0) {
      return "{}";
    }
    var childIndent = resolvedSpace ? indent3 + resolvedSpace : void 0;
    var first = true;
    var str = resolvedSpace ? "{\n" : "{";
    keys.forEach(function(key) {
      var value2 = typeof replacer === "function" ? replacer.call(object, key, object[key]) : object[key];
      if (includeProperty(key, value2)) {
        if (first) {
          first = false;
        } else {
          str += resolvedSpace ? ",\n" : ",";
        }
        var keyStr = JSON.stringify(key);
        str += resolvedSpace ? childIndent + keyStr + ": " : keyStr + ":";
        str += stringifyValue(value2, childIndent);
      }
    });
    str += resolvedSpace ? "\n" + indent3 + "}" : "}";
    return str;
  }
  function includeProperty(key, value2) {
    return typeof value2 !== "undefined" && typeof value2 !== "function" && _typeof3(value2) !== "symbol";
  }
}
function resolveSpace(space) {
  if (typeof space === "number") {
    return " ".repeat(space);
  }
  if (typeof space === "string" && space !== "") {
    return space;
  }
  return void 0;
}

// node_modules/curlconverter/dist/src/generators/python.js
var supportedArgs8 = /* @__PURE__ */ new Set([
  ...COMMON_SUPPORTED_ARGS,
  "compressed",
  "digest",
  "no-digest",
  "aws-sigv4",
  "negotiate",
  "no-negotiate",
  "delegation",
  "ntlm",
  "no-ntlm",
  "ntlm-wb",
  "no-ntlm-wb",
  "http1.1",
  "http2",
  "http2-prior-knowledge",
  "http3",
  "http3-only",
  "cookie-jar",
  "cert",
  "cacert",
  "key",
  "capath",
  "form",
  "form-string",
  "location",
  "no-location",
  "location-trusted",
  "no-location-trusted",
  "max-redirs",
  "max-time",
  "connect-timeout",
  "insecure",
  "no-insecure",
  "output",
  "upload-file",
  "next",
  "proxy",
  "proxy-user"
]);
var regexSingleEscape = /'|\\|\p{C}|\p{Z}/gu;
var regexDoubleEscape = /"|\\|\p{C}|\p{Z}/gu;
function reprStr5(s, quote) {
  if (quote === void 0) {
    quote = "'";
    if (s.includes("'") && !s.includes('"')) {
      quote = '"';
    }
  }
  const regex = quote === "'" ? regexSingleEscape : regexDoubleEscape;
  return quote + s.replace(regex, (c) => {
    switch (c) {
      case " ":
        return " ";
      case "\x07":
        return "\\a";
      case "\b":
        return "\\b";
      case "\f":
        return "\\f";
      case "\n":
        return "\\n";
      case "\r":
        return "\\r";
      case "	":
        return "\\t";
      case "\v":
        return "\\v";
      case "\\":
        return "\\\\";
      case "'":
        return "\\'";
      case '"':
        return '\\"';
    }
    const hex = c.codePointAt(0).toString(16);
    if (hex.length <= 2) {
      return "\\x" + hex.padStart(2, "0");
    }
    if (hex.length <= 4) {
      return "\\u" + hex.padStart(4, "0");
    }
    return "\\U" + hex.padStart(8, "0");
  }) + quote;
}
function reprStrBinary(s) {
  const sEsc = reprStr5(s);
  if (/^[\x00-\x7f]*$/.test(s)) {
    return "b" + sEsc;
  }
  return sEsc + ".encode()";
}
function repr6(word, osVars, imports, binary = false, errorOk = false) {
  const reprs = [];
  for (const t of word.tokens) {
    if (typeof t === "string") {
      reprs.push(reprStr5(t));
    } else if (t.type === "variable") {
      const fn = binary ? "os.getenvb" : "os.getenv";
      const reprFn = binary ? reprStrBinary : reprStr5;
      let getEnvCall = fn + "(" + reprFn(t.value);
      if (!errorOk || word.tokens.length > 1) {
        getEnvCall += ", " + reprFn("");
      }
      getEnvCall += ")";
      reprs.push(getEnvCall);
      imports.add("os");
    } else if (t.type === "command") {
      let subprocessCall = "subprocess.run(" + reprStr5(t.value) + ", shell=True, capture_output=True";
      if (!binary) {
        subprocessCall += ", text=True";
      }
      subprocessCall += ").stdout";
      let i = 1;
      let pyVar = "command" + i;
      while (pyVar in osVars && osVars[pyVar] !== subprocessCall) {
        i++;
        pyVar = "command" + i;
        if (i > Number.MAX_SAFE_INTEGER) {
          throw new CCError("lol");
        }
      }
      osVars[pyVar] = subprocessCall;
      reprs.push(pyVar);
      imports.add("subprocess");
    }
  }
  return reprs.join(" + ");
}
function reprb(word, osVars, imports) {
  return repr6(word, osVars, imports, true);
}
var pythonJsonEscape = /"|\\|[^\x20-\x7E]/g;
function jsonRepr(s) {
  return '"' + s.replace(pythonJsonEscape, (c) => {
    switch (c) {
      case "\b":
        return "\\b";
      case "	":
        return "\\t";
      case "\n":
        return "\\n";
      case "\f":
        return "\\f";
      case "\r":
        return "\\r";
      case "\\":
        return "\\\\";
      case '"':
        return '\\"';
    }
    const hex = c.charCodeAt(0).toString(16);
    return "\\u" + hex.padStart(4, "0");
  }) + '"';
}
function ensure_minimum_exponent_length(n) {
  const [mantissa, exponent] = n.split("e");
  const exponentSign = exponent[0];
  const exponentValue = exponent.slice(1);
  if (exponentValue.length === 1) {
    return mantissa + "e" + exponentSign + "0" + exponentValue;
  }
  return n;
}
function floatAsPython(value) {
  let asJsStr = value.toString();
  if (asJsStr.includes("e")) {
    asJsStr = ensure_minimum_exponent_length(asJsStr);
  } else {
    if (isInteger(asJsStr)) {
      asJsStr += ".0";
    }
    const significantDigits = asJsStr.replace(/^-/, "").replace(".", "").replace(/^0+/, "");
    const asExponential = ensure_minimum_exponent_length(value.toExponential());
    if (significantDigits.length > 17 || asExponential.length < asJsStr.length && asJsStr.split(".")[1].length > 4) {
      asJsStr = asExponential;
    }
  }
  return asJsStr;
}
function jsonDumps(obj) {
  if (isLosslessNumber(obj)) {
    const numAsStr = stringify(obj);
    if (isInteger(numAsStr)) {
      return numAsStr;
    }
    if (!isSafeNumber(numAsStr)) {
      throw new CCError("float unrepresentable in Python: " + numAsStr);
    }
    return floatAsPython(obj.valueOf());
  }
  switch (typeof obj) {
    case "string":
      return jsonRepr(obj);
    case "number":
      if (!isFinite(obj)) {
        throw new CCError("found Infitiny in JSON");
      }
      return obj.toString();
    case "boolean":
      return obj.toString();
    case "object":
      if (obj === null) {
        return "null";
      }
      if (Array.isArray(obj)) {
        return "[" + obj.map(jsonDumps).join(", ") + "]";
      }
      return "{" + Object.entries(obj).map((e) => jsonRepr(e[0]) + ": " + jsonDumps(e[1])).join(", ") + "}";
    default:
      throw new CCError("unexpected object type that shouldn't appear in JSON: " + typeof obj);
  }
}
function objToPython(obj, indent3 = 0) {
  if (isLosslessNumber(obj)) {
    const numAsStr = stringify(obj);
    if (!isInteger(numAsStr) && !isSafeNumber(numAsStr)) {
      throw new CCError("float unrepresentable in Python: " + numAsStr);
    }
    return numAsStr;
  }
  switch (typeof obj) {
    case "string":
      return reprStr5(obj);
    case "number":
      return obj.toString();
    case "boolean":
      return obj ? "True" : "False";
    case "object":
      if (obj === null) {
        return "None";
      }
      if (Array.isArray(obj)) {
        if (obj.length === 0) {
          return "[]";
        }
        let s = "[\n";
        for (const item of obj) {
          s += " ".repeat(indent3 + 4) + objToPython(item, indent3 + 4) + ",\n";
        }
        s += " ".repeat(indent3) + "]";
        return s;
      }
      if (Object.keys(obj).length === 0) {
        return "{}";
      }
      {
        let s = "{\n";
        for (const [k, v] of Object.entries(obj)) {
          s += " ".repeat(indent3 + 4) + reprStr5(k) + ": " + objToPython(v, indent3 + 4) + ",\n";
        }
        s += " ".repeat(indent3) + "}";
        return s;
      }
    default:
      throw new CCError("unexpected object type that shouldn't appear in JSON: " + typeof obj);
  }
}
function decodePercentEncoding(s) {
  let decoded;
  try {
    decoded = wordDecodeURIComponent(s.replace(/\+/g, " "));
  } catch (e) {
    if (e instanceof URIError) {
      return null;
    }
    throw e;
  }
  const roundTripKey = percentEncode(decoded);
  if (!eq(roundTripKey, s) && !eq(roundTripKey.replace(/%20/g, "+"), s)) {
    return null;
  }
  return decoded;
}
function dataEntriesToDict(dataEntries) {
  const asDict = {};
  let prevKey = null;
  for (const [key, val] of dataEntries) {
    if (prevKey === key) {
      asDict[key].push(val);
    } else {
      if (!Object.prototype.hasOwnProperty.call(asDict, key)) {
        asDict[key] = [val];
      } else {
        return null;
      }
    }
    prevKey = key;
  }
  return asDict;
}
function dataEntriesToPython(dataEntries) {
  if (dataEntries.length === 0) {
    return "''";
  }
  const entriesDict = dataEntriesToDict(dataEntries);
  if (entriesDict !== null) {
    if (Object.keys(entriesDict).length === 0) {
      return "''";
    }
    let s2 = "{\n";
    for (const [key, vals] of Object.entries(entriesDict)) {
      s2 += "    " + key + ": ";
      if (vals.length === 0) {
        s2 += "''";
      } else if (vals.length === 1) {
        s2 += vals[0];
      } else {
        s2 += "[\n";
        for (const val of vals) {
          s2 += "        " + val + ",\n";
        }
        s2 += "    ]";
      }
      s2 += ",\n";
    }
    s2 += "}";
    return s2;
  }
  let s = "[\n";
  for (const entry of dataEntries) {
    const [key, val] = entry;
    s += "    (" + key + ", " + val + "),\n";
  }
  s += "]";
  return s;
}
function formatDataAsEntries(dataArray, osVars, imports, variableName = "data") {
  for (const d of dataArray) {
    if (Array.isArray(d) && d[0] !== "urlencode") {
      return null;
    }
  }
  const dataEntries = [];
  let percentWarn = new Word();
  for (const [i, d] of dataArray.entries()) {
    if (d instanceof Word) {
      let newEntries = d.split("&");
      const prevEntry = i > 0 ? dataEntries[dataEntries.length - 1] : null;
      if (prevEntry !== null) {
        const [first, ...rest] = newEntries;
        if (first.includes("=") && prevEntry[1] === null) {
          const [key, val] = first.split("=", 2);
          const decodedKey = decodePercentEncoding(key);
          if (decodedKey === null) {
            return null;
          }
          const decodedVal = decodePercentEncoding(val);
          if (decodedVal === null) {
            return null;
          }
          if (key.toBool()) {
            prevEntry[0] += " + " + repr6(decodedKey, osVars, imports);
          }
          prevEntry[1] = repr6(decodedVal, osVars, imports);
          if (!percentWarn.toBool()) {
            if (key.includes("%20")) {
              percentWarn = key;
            }
            if (val.includes("%20")) {
              percentWarn = val;
            }
          }
        } else if (!first.includes("=") && prevEntry[1] !== null) {
          if (first.toBool()) {
            const decodedVal = decodePercentEncoding(first);
            if (decodedVal === null) {
              return null;
            }
            prevEntry[1] += " + " + repr6(decodedVal, osVars, imports);
            if (!percentWarn.toBool() && first.includes("%20")) {
              percentWarn = first;
            }
          }
        } else {
          return null;
        }
        newEntries = rest;
      }
      for (const [j, entry] of newEntries.entries()) {
        if (entry.isEmpty() && j === newEntries.length - 1 && i !== dataArray.length - 1) {
          continue;
        }
        if (!entry.includes("=")) {
          return null;
        }
        const [key, val] = entry.split("=", 2);
        const decodedKey = decodePercentEncoding(key);
        if (decodedKey === null) {
          return null;
        }
        const decodedVal = decodePercentEncoding(val);
        if (decodedVal === null) {
          return null;
        }
        dataEntries.push([
          repr6(decodedKey, osVars, imports),
          repr6(decodedVal, osVars, imports)
        ]);
        if (!percentWarn.toBool()) {
          if (key.includes("%20")) {
            percentWarn = key;
          }
          if (val.includes("%20")) {
            percentWarn = val;
          }
        }
      }
      continue;
    }
    const name = d[1];
    const filename = d[2];
    const readFile = eq(filename, "-") ? "sys.stdin.read()" : "open(" + repr6(filename, osVars, imports, false, true) + ").read()";
    if (!name) {
      dataEntries.push([readFile, null]);
    } else {
      if (!eq(name, percentEncode(name))) {
        return null;
      }
      dataEntries.push([repr6(name, osVars, imports), readFile]);
    }
  }
  if (dataEntries.some((e) => e[1] === null)) {
    return null;
  }
  return [
    variableName + " = " + dataEntriesToPython(dataEntries) + "\n",
    percentWarn.toString()
  ];
}
function formatDataAsStr(dataArray, imports, osVars, variableName = "data") {
  const binary = dataArray.some((d2) => Array.isArray(d2) && d2[0] === "binary");
  const reprFunc = binary ? reprb : repr6;
  const prefix = binary ? "b" : "";
  const mode = binary ? ", 'rb'" : "";
  let encode = false;
  let encodeOnSeparateLine = false;
  const lines = [];
  let extra = new Word();
  let i, d;
  for ([i, d] of dataArray.entries()) {
    const op = i === 0 ? "=" : "+=";
    let line = variableName + " " + op + " ";
    if (i < dataArray.length - 1 && d instanceof Word && d.endsWith("&")) {
      extra = new Word("&");
      d = d.slice(0, -1);
    }
    if (d instanceof Word) {
      if (d.length) {
        line += reprFunc(d, osVars, imports);
        lines.push(line);
        encode || (encode = d.test(/[^\x00-\x7F]/));
      }
      continue;
    }
    const [type, name, filename] = d;
    if (type === "urlencode" && name) {
      line += reprFunc(extra.add(name).append("="), osVars, imports) + " + ";
      encodeOnSeparateLine = true;
    } else if (extra.toBool()) {
      line += reprFunc(extra, osVars, imports) + " + ";
      encodeOnSeparateLine = true;
    }
    if (extra.toBool()) {
      encodeOnSeparateLine = true;
    }
    let readFile = "";
    if (eq(filename, "-")) {
      readFile += binary ? "sys.stdin.buffer" : "sys.stdin";
      imports.add("sys");
    } else {
      line = "with open(" + repr6(filename, osVars, imports, false, true) + mode + ") as f:\n    " + line;
      readFile += "f";
    }
    readFile += ".read()";
    if (!["binary", "json", "urlencode"].includes(type)) {
      readFile += `.replace(${prefix}'\\n', ${prefix}'').replace(${prefix}'\\r', ${prefix}'')`;
    }
    if (type === "urlencode") {
      readFile = "quote_plus(" + readFile + ")";
      if (binary) {
        readFile += ".encode()";
      }
      imports.add("urllib.parse.quote_plus");
    } else {
      encode = true;
    }
    line += readFile;
    lines.push(line);
    extra = new Word();
  }
  if (binary) {
    encode = false;
  } else if (encode && lines.length === 1 && !encodeOnSeparateLine) {
    lines[lines.length - 1] += ".encode()";
    encode = false;
  }
  return [lines.join("\n") + "\n", encode];
}
function formatDataAsJson(d, imports, osVars) {
  if (d instanceof Word) {
    if (!d.isString()) {
      return [null, false];
    }
    let dataAsJson;
    try {
      dataAsJson = parse(d.toString());
    } catch (_a) {
      try {
        dataAsJson = JSON.parse(d.toString());
      } catch (_b) {
        return [null, false];
      }
    }
    try {
      const jsonDataString = "json_data = " + objToPython(dataAsJson) + "\n";
      let jsonRoundtrips = false;
      try {
        jsonRoundtrips = jsonDumps(dataAsJson) === d.tokens[0];
      } catch (_c) {
      }
      return [jsonDataString, jsonRoundtrips];
    } catch (_d) {
    }
  } else if (d[0] === "json") {
    let jsonDataString = "";
    jsonDataString += "with open(" + repr6(d[2], osVars, imports, false, true) + ") as f:\n";
    jsonDataString += "    json_data = json.load(f)\n";
    imports.add("json");
    return [jsonDataString, false];
  }
  return [null, false];
}
function getDataString5(request, osVars, warnings) {
  const imports = /* @__PURE__ */ new Set();
  if (!request.data || !request.dataArray) {
    return [null, false, null, imports];
  }
  const contentType = request.headers.get("content-type");
  let dataAsJson = null;
  let jsonRoundtrips = false;
  if (request.dataArray.length === 1 && contentType && contentType.split(";")[0].toString().trim() === "application/json") {
    [dataAsJson, jsonRoundtrips] = formatDataAsJson(request.dataArray[0], imports, osVars);
  }
  if (jsonRoundtrips) {
    return [null, false, dataAsJson, imports];
  }
  const dataAsEntries = formatDataAsEntries(request.dataArray, osVars, imports);
  if (dataAsEntries !== null) {
    const [dataEntries, percentWarn] = dataAsEntries;
    if (eq(request.headers.get("content-type"), "application/x-www-form-urlencoded")) {
      request.headers.delete("content-type");
    }
    if (percentWarn) {
      warnings.push([
        "percent-encoded-spaces-in-data",
        'data contains spaces encoded by curl as "%20" which will be sent as "+" instead: ' + JSON.stringify(percentWarn)
      ]);
    }
    return [dataEntries, false, dataAsJson, imports];
  }
  const [dataAsString, shouldEncode] = formatDataAsStr(request.dataArray, imports, osVars);
  return [dataAsString, shouldEncode, dataAsJson, imports];
}
function getFilesString(request, osVars, imports) {
  let usesStdin = false;
  if (!request.multipartUploads) {
    return ["", usesStdin];
  }
  const multipartUploads = request.multipartUploads.map((m) => {
    const name = m.name ? repr6(m.name, osVars, imports) : "None";
    const sentFilename = "filename" in m && m.filename ? repr6(m.filename, osVars, imports) : "None";
    if ("contentFile" in m) {
      if (eq(m.contentFile, "-")) {
        usesStdin = true;
        return [name, "(" + sentFilename + ", sys.stdin.buffer.read())"];
      } else if (eq(m.contentFile, m.filename)) {
        return [
          name,
          "open(" + repr6(m.contentFile, osVars, imports, false, true) + ", 'rb')"
        ];
      }
      return [
        name,
        "(" + sentFilename + ", open(" + repr6(m.contentFile, osVars, imports, false, true) + ", 'rb'))"
      ];
    }
    return [
      name,
      "(" + sentFilename + ", " + repr6(m.content, osVars, imports) + ")"
    ];
  });
  const multipartUploadsAsDict = Object.fromEntries(multipartUploads);
  let filesString = "files = ";
  if (Object.keys(multipartUploadsAsDict).length === multipartUploads.length) {
    filesString += "{\n";
    for (const [multipartKey, multipartValue] of multipartUploads) {
      filesString += "    " + multipartKey + ": " + multipartValue + ",\n";
    }
    filesString += "}\n";
  } else {
    filesString += "[\n";
    for (const [multipartKey, multipartValue] of multipartUploads) {
      filesString += "    (" + multipartKey + ", " + multipartValue + "),\n";
    }
    filesString += "]\n";
  }
  return [filesString, usesStdin];
}
function indent(s, level) {
  if (level === 0) {
    return s;
  }
  const begin = "    ".repeat(level);
  return s.split("\n").map((l) => l.trim() ? begin + l : l).join("\n");
}
function commentOut(s) {
  return s.split("\n").map((l) => l.trim() ? "#" + l : l).join("\n");
}
function uniqueWarn(seenWarnings, warnings, warning) {
  if (!seenWarnings.has(warning[0])) {
    seenWarnings.add(warning[0]);
    warnings.push(warning);
  }
}
function joinArgs(args) {
  let s = "(";
  if (args.join("").length < 100) {
    s += args.join(", ");
  } else {
    s += "\n";
    for (const arg of args) {
      s += "    " + arg + ",\n";
    }
  }
  return s + ")";
}
function requestToPython(request, warnings = [], imports, thirdPartyImports) {
  const osVars = {};
  const commentedOutHeaders = {
    "accept-encoding": "",
    "content-length": ""
  };
  if (eq(request.headers.get("te"), "trailers")) {
    commentedOutHeaders.te = "Requests doesn't support trailers";
  }
  let cookieStr;
  let cookieFile = null;
  if (request.cookies) {
    cookieStr = "cookies = {\n";
    for (const [cookieName, cookieValue] of request.cookies) {
      cookieStr += "    " + repr6(cookieName, osVars, imports) + ": " + repr6(cookieValue, osVars, imports) + ",\n";
    }
    cookieStr += "}\n";
    commentedOutHeaders.cookie = "";
    if (request.cookieFiles) {
      warnings.push([
        "cookie-files",
        "passing both cookies and cookie files with --cookie/-b is not supported"
      ]);
    }
    if (request.cookieJar) {
      warnings.push([
        "cookie-files",
        "passing both cookies and --cookie-jar/-c is not supported"
      ]);
    }
  } else if (request.cookieFiles && request.cookieFiles.length || request.cookieJar) {
    imports.add("http.cookiejar.MozillaCookieJar");
    if (request.cookieFiles && request.cookieFiles.length) {
      cookieFile = request.cookieFiles[request.cookieFiles.length - 1];
      if (request.cookieFiles.length > 1) {
        warnings.push([
          "cookie-files",
          "multiple cookie files are not supported, using the last one: " + JSON.stringify(cookieFile.toString())
        ]);
      }
      cookieStr = "cookies = MozillaCookieJar(" + repr6(cookieFile, osVars, imports) + ")\n";
    } else if (request.cookieJar) {
      cookieStr = "cookies = MozillaCookieJar()\n";
    }
  }
  let proxyDict;
  if (request.proxy) {
    let proxy = request.proxy.includes("://") ? request.proxy : request.proxy.prepend("http://");
    const protocol = proxy.split("://")[0].toLowerCase();
    if (eq(protocol, "socks")) {
      proxy = proxy.replace("socks", "socks4");
    }
    proxyDict = "proxies = {\n";
    proxyDict += "    'http': " + repr6(proxy, osVars, imports) + ",\n";
    proxyDict += "    'https': " + repr6(proxy, osVars, imports) + ",\n";
    proxyDict += "}\n";
  }
  let certStr;
  if (request.cert) {
    certStr = "cert = ";
    if (Array.isArray(request.cert)) {
      certStr += "(" + repr6(request.cert[0], osVars, imports) + ", " + repr6(request.cert[1], osVars, imports) + ")";
    } else {
      certStr += repr6(request.cert, osVars, imports);
    }
    certStr += "\n";
  }
  let paramsStr;
  let shouldEncodeParams;
  function readsFile(paramArray2) {
    return paramArray2.some((p) => !(p instanceof Word));
  }
  const paramArray = request.urls.length === 1 ? request.urls[0].queryArray : request.queryArray;
  if (paramArray && (request.urls.length === 1 || request.urls.length > 1 && readsFile(paramArray))) {
    const queryAsEntries = formatDataAsEntries(paramArray, osVars, imports, "params");
    if (queryAsEntries !== null) {
      let percentWarn;
      [paramsStr, percentWarn] = queryAsEntries;
      if (percentWarn) {
        warnings.push([
          "percent-encoded-spaces-in-query",
          'URL querystring contains spaces encoded as "%20" which will be sent by Requests as "+" instead: ' + JSON.stringify(percentWarn)
        ]);
      }
    } else if (readsFile(paramArray)) {
      [paramsStr, shouldEncodeParams] = formatDataAsStr(paramArray, imports, osVars, "params");
    }
  }
  const contentType = request.headers.get("content-type");
  let dataString;
  let jsonDataString;
  let filesString;
  let shouldEncode;
  if (request.urls[0].uploadFile && request.urls.length === 1) {
    if (eq(request.urls[0].uploadFile, "-") || eq(request.urls[0].uploadFile, ".")) {
      dataString = "data = sys.stdin.buffer.read()\n";
      imports.add("sys");
    } else {
      dataString = "with open(" + repr6(request.urls[0].uploadFile, osVars, imports, false, true) + ", 'rb') as f:\n";
      dataString += "    data = f.read()\n";
    }
  } else if (request.data && !request.data.isEmpty()) {
    let dataImports;
    [dataString, shouldEncode, jsonDataString, dataImports] = getDataString5(request, osVars, warnings);
    dataImports.forEach(imports.add, imports);
    if (jsonDataString && !dataString && contentType && eq(contentType.trim(), "application/json")) {
      commentedOutHeaders["content-type"] = "Already added when you pass json=";
    }
  } else if (request.multipartUploads) {
    let usesStdin = false;
    [filesString, usesStdin] = getFilesString(request, osVars, imports);
    if (usesStdin) {
      imports.add("sys");
    }
    if (filesString && contentType && eq(contentType.trim(), "multipart/form-data") && !contentType.includes("boundary=")) {
      commentedOutHeaders["content-type"] = "requests won't add a boundary if this header is set when you pass files=";
    }
  }
  let headerDict;
  if (request.headers.length) {
    headerDict = "headers = {\n";
    for (const [headerName, headerValue] of request.headers) {
      if (headerValue === null) {
        continue;
      }
      let lineStart;
      const headerNameLower = headerName.toLowerCase().toString();
      if (has(commentedOutHeaders, headerNameLower)) {
        if (commentedOutHeaders[headerNameLower]) {
          headerDict += "    # " + commentedOutHeaders[headerNameLower] + "\n";
        }
        lineStart = "    # ";
      } else {
        lineStart = "    ";
      }
      headerDict += lineStart + repr6(headerName, osVars, imports) + ": " + repr6(headerValue, osVars, imports) + ",\n";
    }
    headerDict += "}\n";
  }
  let pythonCode = "";
  if (proxyDict) {
    pythonCode += proxyDict + "\n";
  }
  if (cookieStr) {
    pythonCode += cookieStr + "\n";
  }
  if (headerDict) {
    pythonCode += headerDict + "\n";
  }
  if (paramsStr) {
    pythonCode += paramsStr + "\n";
  }
  if (certStr) {
    pythonCode += certStr + "\n";
  }
  if (jsonDataString) {
    pythonCode += jsonDataString + "\n";
  } else if (dataString) {
    pythonCode += dataString + "\n";
  } else if (filesString) {
    pythonCode += filesString + "\n";
  }
  let followRedirects = request.followRedirects;
  let maxRedirects = void 0;
  if (request.maxRedirects !== void 0) {
    if (request.maxRedirects.isString()) {
      maxRedirects = request.maxRedirects.toString();
    } else {
      maxRedirects = "int(" + repr6(request.maxRedirects, osVars, imports) + ")";
    }
  }
  if (followRedirects === void 0) {
    followRedirects = true;
  }
  const hasMaxRedirects = followRedirects && maxRedirects && maxRedirects !== "0" && maxRedirects !== "30";
  const seenWarnings = /* @__PURE__ */ new Set();
  const requestLines = [];
  let extraEmptyLine = false;
  for (const [urlObjIndex, urlObj] of request.urls.entries()) {
    const requestsMethods = [
      "GET",
      "HEAD",
      "POST",
      "PATCH",
      "PUT",
      "DELETE",
      "OPTIONS"
    ];
    let fn;
    const args = [];
    const methodAsString = urlObj.method.toString();
    if (urlObj.method.isString() && requestsMethods.includes(methodAsString)) {
      fn = methodAsString.toLowerCase();
    } else {
      fn = "request";
      args.push(repr6(urlObj.method, osVars, imports));
      if (urlObj.method.isString() && methodAsString !== methodAsString.toUpperCase()) {
        warnings.push([
          "method",
          "Requests will uppercase the HTTP method: " + JSON.stringify(methodAsString)
        ]);
      }
    }
    let urlParamsStr;
    let url = urlObj.url;
    if (request.urls.length === 1) {
      if (paramsStr) {
        url = urlObj.urlWithoutQueryArray;
      } else {
        url = urlObj.url;
      }
    } else {
      if (paramsStr) {
        url = urlObj.urlWithOriginalQuery;
      } else {
        if (urlObj.queryArray && urlObj.queryArray.length > 0) {
          const urlQueryAsEntries = formatDataAsEntries(urlObj.queryArray, osVars, imports, "params");
          if (urlQueryAsEntries !== null) {
            let percentWarn;
            [urlParamsStr, percentWarn] = urlQueryAsEntries;
            url = urlObj.urlWithoutQueryArray;
            if (percentWarn) {
              warnings.push([
                "percent-encoded-spaces-in-query",
                'query contains spaces encoded by curl as "%20" which will be sent as "+" instead: ' + JSON.stringify(percentWarn)
              ]);
            }
          } else if (readsFile(urlObj.queryArray)) {
            [urlParamsStr, shouldEncodeParams] = formatDataAsStr(urlObj.queryArray, imports, osVars, "params");
            url = urlObj.urlWithoutQueryArray;
          }
        }
      }
    }
    args.push(repr6(url, osVars, imports));
    if (paramsStr || urlParamsStr) {
      args.push("params=params" + (shouldEncodeParams ? ".encode()" : ""));
    }
    if (cookieStr && !request.cookieJar) {
      args.push("cookies=cookies");
    }
    if (headerDict) {
      args.push("headers=headers");
    }
    if (urlObj.uploadFile) {
      if (request.urls.length > 1) {
        args.push("data=file_contents");
      } else {
        args.push("data=data");
      }
    } else if (request.data && !request.data.isEmpty()) {
      if (jsonDataString) {
        args.push("json=json_data");
      } else {
        args.push("data=data" + (shouldEncode ? ".encode()" : ""));
      }
    } else if (filesString) {
      args.push("files=files");
    }
    if (proxyDict) {
      args.push("proxies=proxies");
    }
    if (certStr) {
      args.push("cert=cert");
    }
    const certOrPath = request.cacert || request.capath;
    if (request.insecure) {
      args.push("verify=False");
    } else if (certOrPath) {
      args.push("verify=" + repr6(certOrPath, osVars, imports));
    }
    if (urlObj.auth && !request.headers.has("Authorization")) {
      const [user, password] = urlObj.auth;
      let auth = "(" + repr6(user, osVars, imports) + ", " + repr6(password, osVars, imports) + ")";
      switch (request.authType) {
        case "basic":
          break;
        case "digest":
          thirdPartyImports.add("requests.auth.HTTPDigestAuth");
          auth = "HTTPDigestAuth" + auth;
          break;
        case "ntlm":
        case "ntlm-wb":
          thirdPartyImports.add("requests_ntlm.HttpNtlmAuth");
          auth = "HttpNtlmAuth" + auth;
          uniqueWarn(seenWarnings, warnings, [
            "ntlm",
            "requests-ntlm is unmaintained"
          ]);
          break;
        case "negotiate":
          thirdPartyImports.add("requests_gssapi.HTTPSPNEGOAuth");
          auth = "HTTPSPNEGOAuth(";
          if (request.delegation) {
            if (eq(request.delegation, "always")) {
              auth += "delegate=True";
            } else if (eq(request.delegation, "none")) {
              auth += "delegate=False";
            } else {
              uniqueWarn(seenWarnings, warnings, [
                "delegation",
                "--delegation value not supported: " + JSON.stringify(request.delegation.toString())
              ]);
            }
          }
          auth += ")";
          uniqueWarn(seenWarnings, warnings, [
            "negotiate",
            "requests-gssapi is a fork of requests-kerberos"
          ]);
          break;
        case "aws-sigv4":
          thirdPartyImports.add("aws_requests_auth.aws_auth.AWSRequestsAuth");
          auth = "AWSRequestsAuth(aws_access_key=" + repr6(user, osVars, imports) + ", aws_secret_access_key=" + repr6(password, osVars, imports) + ", aws_host=" + repr6(request.awsSigV4 || new Word(), osVars, imports) + ", aws_region=" + repr6(request.awsSigV4 || new Word(), osVars, imports) + ", aws_service=" + repr6(request.awsSigV4 || new Word(), osVars, imports) + ")";
          uniqueWarn(seenWarnings, warnings, [
            "--aws-sigv4",
            "--aws-sigv4 value isn't parsed: " + JSON.stringify(request.awsSigV4 ? request.awsSigV4.toString() : "")
          ]);
          break;
        case "bearer":
          break;
      }
      args.push("auth=" + auth);
    }
    if (request.timeout || request.connectTimeout) {
      let connectTimeout = null;
      if (request.connectTimeout) {
        if (request.connectTimeout.isString()) {
          connectTimeout = request.connectTimeout.toString();
        } else {
          connectTimeout = "float(" + repr6(request.connectTimeout, osVars, imports, false, true) + ")";
        }
      }
      let timeout = null;
      if (request.timeout) {
        if (request.timeout.isString()) {
          timeout = request.timeout.toString();
        } else {
          timeout = "float(" + repr6(request.timeout, osVars, imports, false, true) + ")";
        }
      }
      if (timeout && connectTimeout && timeout !== connectTimeout) {
        args.push("timeout=(" + connectTimeout + ", " + timeout + ")");
      } else if (timeout) {
        args.push("timeout=" + timeout);
      } else if (connectTimeout) {
        args.push("timeout=(" + connectTimeout + ", None)");
      }
      if (timeout) {
        uniqueWarn(seenWarnings, warnings, [
          "--max-time",
          "unlike --max-time, Requests doesn't have a timeout for the whole request, only for the connect and the read"
        ]);
      }
    }
    if (!followRedirects || maxRedirects === "0") {
      args.push("allow_redirects=False");
    } else if (maxRedirects) {
      if (maxRedirects === "-1") {
        imports.add("math");
        maxRedirects = "math.inf";
      }
    }
    if (followRedirects && request.followRedirectsTrusted) {
      uniqueWarn(seenWarnings, warnings, [
        "--location-trusted",
        "Requests doesn't have an easy way to disable removing the Authorization: header on redirect"
      ]);
    }
    let requestLine = "";
    const isSession = hasMaxRedirects || request.cookieJar;
    const indentLevel = isSession ? 1 : 0;
    if (isSession && urlObjIndex === 0) {
      requestLine += "with requests.Session() as session:\n";
      if (hasMaxRedirects) {
        requestLine += `    session.max_redirects = ${maxRedirects}
`;
      }
      if (request.cookieJar) {
        requestLine += `    session.cookies = cookies
`;
      }
    }
    if (request.urls.length > 1) {
      if (urlParamsStr) {
        requestLine += indent(urlParamsStr, indentLevel);
      }
      if (urlObj.uploadFile) {
        let uploadFileLine = "";
        if (eq(urlObj.uploadFile, "-") || eq(urlObj.uploadFile, ".")) {
          uploadFileLine += "file_contents = sys.stdin.buffer.read()\n";
          imports.add("sys");
        } else {
          uploadFileLine += "with open(" + repr6(urlObj.uploadFile, osVars, imports, false, true) + ", 'rb') as f:\n";
          uploadFileLine += "    file_contents = f.read()\n";
        }
        requestLine += indent(uploadFileLine, indentLevel);
      }
    }
    const fnToCall = "response = " + (isSession ? "session" : "requests") + "." + fn;
    requestLine += indent(fnToCall + joinArgs(args) + "\n", indentLevel);
    if (jsonDataString && dataString && !urlObj.uploadFile) {
      requestLine += isSession || request.urls.length > 1 ? "" : "\n";
      args[args.indexOf("json=json_data")] = shouldEncode ? "data=data.encode()" : "data=data";
      let dataAlternative = "# Note: json_data will not be serialized by requests\n# exactly as it was in the original request.\n";
      dataAlternative += commentOut(dataString);
      dataAlternative += commentOut(fnToCall + joinArgs(args) + "\n");
      requestLine += indent(dataAlternative, indentLevel);
    }
    if (urlObj.output && !eq(urlObj.output, "/dev/null")) {
      let outputLine = "";
      if (eq(request.urls[0].output, "-")) {
        outputLine += "print(response.text)\n";
      } else {
        outputLine += isSession || request.urls.length > 1 ? "" : "\n";
        outputLine += "with open(" + repr6(urlObj.output, osVars, imports, false, true) + ", 'wb') as f:\n";
        outputLine += "    f.write(response.content)\n";
      }
      requestLine += indent(outputLine, indentLevel);
    }
    if (!isSession && (urlParamsStr || dataString && jsonDataString || urlObj.uploadFile || urlObj.output && !eq(urlObj.output, "/dev/null"))) {
      extraEmptyLine = true;
    }
    requestLines.push(requestLine);
  }
  pythonCode += requestLines.join(extraEmptyLine ? "\n" : "");
  if (request.cookieJar) {
    let cookieSaveLine = "cookies.save(";
    if (!eq(request.cookieJar, cookieFile)) {
      cookieSaveLine += repr6(request.cookieJar, osVars, imports) + ", ";
    }
    cookieSaveLine += "ignore_discard=True, ignore_expires=True)\n";
    pythonCode += indent(cookieSaveLine, 1);
  }
  if (request.http3) {
    warnings.push([
      "http3",
      "this was an HTTP/3 request but requests only supports HTTP/1.1"
    ]);
  } else if (request.http2) {
    warnings.push([
      "http2",
      "this was an HTTP/2 request but requests only supports HTTP/1.1"
    ]);
  } else if (request.headers.lowercase && request.headers.length > 1) {
    warnings.push([
      "--header",
      "all the --header/-H names are lowercase, which means this may have been an HTTP/2 or HTTP/3 request. Requests only sends HTTP/1.1"
    ]);
  }
  let variableCode = "";
  if (Object.keys(osVars).length) {
    for (const [varName, expr] of Object.entries(osVars)) {
      variableCode += `${varName} = ${expr}
`;
    }
    variableCode += "\n";
  }
  return variableCode + pythonCode;
}
function printImports(imps) {
  let s = "";
  for (const imp of Array.from(imps).sort()) {
    if (imp.includes(".")) {
      const pos = imp.lastIndexOf(".");
      const module = imp.slice(0, pos);
      const name = imp.slice(pos + 1);
      s += "from " + module + " import " + name + "\n";
    } else {
      s += "import " + imp + "\n";
    }
  }
  return s;
}
function _toPython(requests, warnings = []) {
  const code = [];
  let joinTwoLines = false;
  const imports = /* @__PURE__ */ new Set();
  const thirdPartyImports = /* @__PURE__ */ new Set();
  for (const request of requests) {
    const requestCode = requestToPython(request, warnings, imports, thirdPartyImports);
    code.push(requestCode);
    joinTwoLines || (joinTwoLines = requestCode.split("\n").length > request.urls.length + 1);
  }
  let importCode = "";
  importCode += printImports(imports);
  if (imports.size > 1) {
    importCode += "\n";
  }
  importCode += "import requests\n";
  importCode += printImports(thirdPartyImports);
  importCode += "\n";
  return importCode + code.join(joinTwoLines ? "\n\n" : "\n");
}
function toPythonWarn(curlCommand, warnings = []) {
  const requests = parseCurlCommand(curlCommand, supportedArgs8, warnings);
  const python = _toPython(requests, warnings);
  return [python, warnings];
}
function toPython(curlCommand) {
  return toPythonWarn(curlCommand)[0];
}

// node_modules/curlconverter/dist/src/generators/go.js
var supportedArgs9 = /* @__PURE__ */ new Set([
  ...COMMON_SUPPORTED_ARGS,
  "insecure",
  "no-insecure",
  "compressed",
  "no-compressed",
  "max-time",
  "form",
  "form-string"
]);
var IF_ERR = "	if err != nil {\n		log.Fatal(err)\n	}\n";
function reprMaybeBacktick(s, vars, imports) {
  return s.isString() && s.includes('"') ? reprBacktick(s, vars, imports) : repr7(s, vars, imports);
}
function reprBacktick(s, vars, imports) {
  return s.isString() && !s.includes("`") && !s.includes("\r") ? "`" + s.toString() + "`" : repr7(s, vars, imports);
}
function reprStr6(s) {
  return reprStr5(s, '"');
}
function repr7(w, vars, imports) {
  const args = [];
  for (const t of w.tokens) {
    if (typeof t === "string") {
      args.push(reprStr6(t));
    } else if (t.type === "variable") {
      args.push("os.Getenv(" + reprStr6(t.value) + ")");
      imports.add("os");
    } else {
      const execCall = "exec.Command(" + reprStr6(t.value) + ").Output()";
      let i = 1;
      let varName = "cmd" + i;
      while (varName in vars && vars[varName] !== execCall) {
        i++;
        varName = "cmd" + i;
        if (i > Number.MAX_SAFE_INTEGER) {
          throw new CCError("lol");
        }
      }
      vars[varName] = execCall;
      args.push(varName);
      imports.add("os/exec");
    }
  }
  return args.join(" + ");
}
function timeoutAtoi(w, vars, imports) {
  if (w.isString()) {
    const asStr = w.toString();
    if (/^\d+\.?\d*$/.test(asStr)) {
      return asStr;
    }
  }
  vars["timeout"] = "strconv.Atoi(" + repr7(w, vars, imports) + ")";
  imports.add("strconv");
  return "timeout";
}
function _toGo(requests, warnings = []) {
  var _a;
  const request = getFirst(requests, warnings);
  const imports = /* @__PURE__ */ new Set(["fmt", "io", "log", "net/http"]);
  const vars = {};
  let goCode = "";
  if (request.multipartUploads) {
    goCode += "	form := new(bytes.Buffer)\n";
    goCode += "	writer := multipart.NewWriter(form)\n";
    imports.add("bytes");
    imports.add("mime/multipart");
    let firstFile = true;
    let firstField = true;
    for (const m of request.multipartUploads) {
      if ("contentFile" in m) {
        const op = firstFile ? ":=" : "=";
        firstFile = false;
        goCode += `	fw, err ${op} writer.CreateFormFile(${repr7(m.contentFile, vars, imports)}, filepath.Base(${repr7((_a = m.filename) !== null && _a !== void 0 ? _a : m.contentFile, vars, imports)}))
`;
        goCode += IF_ERR;
        imports.add("path/filepath");
        goCode += `	fd, err ${op} os.Open(${repr7(m.contentFile, vars, imports)})
`;
        goCode += IF_ERR;
        imports.add("os");
        goCode += "	defer fd.Close()\n";
        goCode += "	_, err = io.Copy(fw, fd)\n";
        goCode += IF_ERR;
      } else {
        const op = firstField ? ":=" : "=";
        firstField = false;
        goCode += `	formField, err ${op} writer.CreateFormField(${repr7(m.name, vars, imports)})
`;
        goCode += IF_ERR;
        goCode += `	_, err = formField.Write([]byte(${reprMaybeBacktick(m.content, vars, imports)}))
`;
      }
      goCode += "\n";
    }
    goCode += "	writer.Close()\n";
    goCode += "\n";
    request.headers.delete("content-type");
  }
  if (request.insecure || request.compressed === false) {
    goCode += "	tr := &http.Transport{\n";
    if (request.insecure) {
      goCode += "		TLSClientConfig: &tls.Config{InsecureSkipVerify: true},\n";
      imports.add("crypto/tls");
    }
    if (request.compressed === false) {
      goCode += "		DisableCompression: true,\n";
    }
    goCode += "	}\n";
  }
  goCode += "	client := &http.Client{";
  if (request.timeout) {
    goCode += "\n";
    if (request.insecure || request.compressed === false) {
      goCode += "		Transport: tr,\n";
    }
    goCode += "		Timeout: " + timeoutAtoi(request.timeout, vars, imports) + " * time.Second,\n";
    goCode += "	";
    imports.add("time");
  } else if (request.insecure || request.compressed === false) {
    goCode += "Transport: tr";
  }
  goCode += "}\n";
  if (request.data) {
    goCode += "	var data = strings.NewReader(" + reprBacktick(request.data, vars, imports) + ")\n";
    imports.add("strings");
  }
  goCode += "	req, err := http.NewRequest(" + repr7(request.urls[0].method, vars, imports) + ", " + repr7(request.urls[0].url, vars, imports);
  goCode += ", " + (request.data ? "data" : request.multipartUploads ? "form" : "nil") + ")\n";
  goCode += IF_ERR;
  if (request.headers.length) {
    for (const [headerName, headerValue] of request.headers) {
      let start = "	";
      if (headerName.toLowerCase().toString() === "accept-encoding" && request.compressed !== false) {
        start += "// ";
      }
      goCode += start + "req.Header.Set(" + repr7(headerName, vars, imports) + ", " + reprMaybeBacktick(headerValue || new Word(), vars, imports) + ")\n";
    }
  }
  if (request.multipartUploads) {
    goCode += '	req.Header.Set("Content-Type", writer.FormDataContentType())\n';
  }
  if (request.urls[0].auth && request.authType === "basic") {
    const [user, password] = request.urls[0].auth;
    goCode += "	req.SetBasicAuth(" + repr7(user, vars, imports) + ", " + repr7(password, vars, imports) + ")\n";
  }
  goCode += "	resp, err := client.Do(req)\n";
  goCode += IF_ERR;
  goCode += "	defer resp.Body.Close()\n";
  goCode += "	bodyText, err := io.ReadAll(resp.Body)\n";
  goCode += IF_ERR;
  goCode += '	fmt.Printf("%s\\n", bodyText)\n';
  goCode += "}";
  let preamble = "package main\n\n";
  preamble += "import (\n";
  for (const imp of Array.from(imports).sort()) {
    preamble += '	"' + imp + '"\n';
  }
  preamble += ")\n\n";
  preamble += "func main() {\n";
  for (const [name, expr] of Array.from(Object.entries(vars)).sort()) {
    preamble += "	" + name + ", err := " + expr + "\n";
    preamble += IF_ERR;
  }
  if (Object.values(vars).length) {
    preamble += "\n";
  }
  return preamble + goCode + "\n";
}
function toGoWarn(curlCommand, warnings = []) {
  const requests = parseCurlCommand(curlCommand, supportedArgs9, warnings);
  const go = _toGo(requests, warnings);
  return [go, warnings];
}
function toGo(curlCommand) {
  return toGoWarn(curlCommand)[0];
}

// node_modules/curlconverter/dist/src/generators/java.js
var supportedArgs10 = /* @__PURE__ */ new Set([
  ...COMMON_SUPPORTED_ARGS
]);
var regexEscape4 = /"|\\|\p{C}|\p{Z}/gu;
var regexDigit2 = /[0-9]/;
function reprStr7(s) {
  return '"' + s.replace(regexEscape4, (c, index, string) => {
    switch (c) {
      case " ":
        return " ";
      case "\\":
        return "\\\\";
      case "\b":
        return "\\b";
      case "\f":
        return "\\f";
      case "\n":
        return "\\n";
      case "\r":
        return "\\r";
      case "	":
        return "\\t";
      case '"':
        return '\\"';
    }
    if (c.length === 2) {
      const first = c.charCodeAt(0);
      const second = c.charCodeAt(1);
      return "\\u" + first.toString(16).padStart(4, "0") + "\\u" + second.toString(16).padStart(4, "0");
    }
    if (c === "\0" && !regexDigit2.test(string.charAt(index + 1))) {
      return "\\0";
    }
    return "\\u" + c.charCodeAt(0).toString(16).padStart(4, "0");
  }) + '"';
}
function repr8(w, imports) {
  const args = [];
  for (const t of w.tokens) {
    if (typeof t === "string") {
      args.push(reprStr7(t));
    } else if (t.type === "variable") {
      args.push("System.getenv(" + reprStr7(t.value) + ")");
      imports.add("java.lang.System");
    } else {
      args.push("exec(" + reprStr7(t.value) + ")");
      imports.add("java.lang.Runtime");
      imports.add("java.util.Scanner");
    }
  }
  return args.join(" + ");
}
function _toJava(requests, warnings = []) {
  const request = getFirst(requests, warnings);
  const imports = /* @__PURE__ */ new Set([
    "java.io.IOException",
    "java.io.InputStream",
    "java.net.HttpURLConnection",
    "java.net.URL",
    "java.util.Scanner"
  ]);
  const vars = {};
  let javaCode = "";
  javaCode += "		URL url = new URL(" + repr8(request.urls[0].url, imports) + ");\n";
  javaCode += "		HttpURLConnection httpConn = (HttpURLConnection) url.openConnection();\n";
  javaCode += "		httpConn.setRequestMethod(" + repr8(request.urls[0].method, imports) + ");\n\n";
  let gzip = false;
  if (request.headers.length) {
    for (const [headerName, headerValue] of request.headers) {
      if (headerValue === null) {
        continue;
      }
      javaCode += "		httpConn.setRequestProperty(" + repr8(headerName, imports) + ", " + repr8(headerValue, imports) + ");\n";
      if (headerName.toLowerCase().toString() === "accept-encoding" && headerValue) {
        gzip = headerValue.indexOf("gzip") !== -1;
      }
    }
    javaCode += "\n";
  }
  if (request.urls[0].auth) {
    javaCode += "		byte[] message = (" + repr8(joinWords(request.urls[0].auth, ":"), imports) + ').getBytes("UTF-8");\n';
    javaCode += "		String basicAuth = DatatypeConverter.printBase64Binary(message);\n";
    javaCode += '		httpConn.setRequestProperty("Authorization", "Basic " + basicAuth);\n';
    javaCode += "\n";
    imports.add("javax.xml.bind.DatatypeConverter");
  }
  if (request.data) {
    javaCode += "		httpConn.setDoOutput(true);\n";
    javaCode += "		OutputStreamWriter writer = new OutputStreamWriter(httpConn.getOutputStream());\n";
    javaCode += "		writer.write(" + repr8(request.data, imports) + ");\n";
    javaCode += "		writer.flush();\n";
    javaCode += "		writer.close();\n";
    javaCode += "		httpConn.getOutputStream().close();\n";
    javaCode += "\n";
    imports.add("java.io.OutputStreamWriter");
  }
  javaCode += "		InputStream responseStream = httpConn.getResponseCode() / 100 == 2\n";
  javaCode += "				? httpConn.getInputStream()\n";
  javaCode += "				: httpConn.getErrorStream();\n";
  if (gzip) {
    javaCode += '		if ("gzip".equals(httpConn.getContentEncoding())) {\n';
    javaCode += "			responseStream = new GZIPInputStream(responseStream);\n";
    javaCode += "		}\n";
  }
  javaCode += '		Scanner s = new Scanner(responseStream).useDelimiter("\\\\A");\n';
  javaCode += '		String response = s.hasNext() ? s.next() : "";\n';
  javaCode += "		System.out.println(response);\n";
  javaCode += "	}\n";
  javaCode += "}";
  let preambleCode = "";
  for (const imp of Array.from(imports).sort()) {
    preambleCode += "import " + imp + ";\n";
  }
  if (imports.size) {
    preambleCode += "\n";
  }
  for (const [name, expr] of Array.from(Object.entries(vars)).sort()) {
    preambleCode += "	" + name + ", err := " + expr + "\n";
  }
  for (const varExpr of Array.from(Object.values(vars)).sort()) {
    preambleCode += "	" + varExpr + "\n";
  }
  if (Object.values(vars).length) {
    preambleCode += "\n";
  }
  preambleCode += "class Main {\n";
  preambleCode += "\n";
  if (imports.has("java.lang.Runtime")) {
    preambleCode += "	public static String exec(String cmd) {\n";
    preambleCode += "		try {\n";
    preambleCode += "			Process p = Runtime.getRuntime().exec(cmd);\n";
    preambleCode += "			p.waitFor();\n";
    preambleCode += '			Scanner s = new Scanner(p.getInputStream()).useDelimiter("\\\\A");\n';
    preambleCode += '			return s.hasNext() ? s.next() : "";\n';
    preambleCode += "		} catch (Exception e) {\n";
    preambleCode += '			return "";\n';
    preambleCode += "		}\n";
    preambleCode += "	}\n";
    preambleCode += "\n";
  }
  preambleCode += "	public static void main(String[] args) throws IOException {\n";
  return preambleCode + javaCode + "\n";
}
function toJavaWarn(curlCommand, warnings = []) {
  const requests = parseCurlCommand(curlCommand, supportedArgs10, warnings);
  const java = _toJava(requests, warnings);
  return [java, warnings];
}
function toJava(curlCommand) {
  return toJavaWarn(curlCommand)[0];
}

// node_modules/curlconverter/dist/src/generators/json.js
var supportedArgs11 = /* @__PURE__ */ new Set([
  ...COMMON_SUPPORTED_ARGS,
  "insecure",
  "no-insecure",
  "form",
  "form-string",
  "location",
  "max-time",
  "connect-timeout",
  "anyauth",
  "no-anyauth",
  "digest",
  "no-digest",
  "aws-sigv4",
  "negotiate",
  "no-negotiate",
  "delegation",
  "ntlm",
  "no-ntlm",
  "ntlm-wb",
  "no-ntlm-wb"
]);
function getDataString6(request) {
  if (!request.data) {
    return {};
  }
  const contentType = request.headers.getContentType();
  if (contentType === "application/json") {
    try {
      const json = JSON.parse(request.data.toString());
      return { data: json };
    } catch (e) {
    }
  }
  const [parsedQuery, parsedQueryDict] = parseQueryString(request.data);
  if (!parsedQuery || !parsedQuery.length) {
    return {
      data: {
        [request.data.toString()]: ""
      }
    };
  }
  if (parsedQueryDict) {
    const data = Object.fromEntries(parsedQueryDict.map((param) => [
      param[0].toString(),
      Array.isArray(param[1]) ? param[1].map((v) => v.toString()) : param[1].toString()
    ]));
    return { data };
  } else {
    return {
      data: Object.fromEntries(parsedQuery.map((param) => [param[0].toString(), param[1].toString()]))
    };
  }
}
function getFilesString2(request) {
  if (!request.multipartUploads) {
    return void 0;
  }
  const data = {
    files: {},
    data: {}
  };
  for (const m of request.multipartUploads) {
    if ("contentFile" in m) {
      data.files[m.name.toString()] = m.contentFile.toString();
    } else {
      data.data[m.name.toString()] = m.content.toString();
    }
  }
  return {
    files: Object.keys(data.files).length ? data.files : void 0,
    data: Object.keys(data.data).length ? data.data : void 0
  };
}
function _toJsonString(requests, warnings = []) {
  const request = getFirst(requests, warnings);
  const requestJson = {
    url: (request.urls[0].queryDict ? request.urls[0].urlWithoutQueryList : request.urls[0].url).toString().replace(/\/$/, ""),
    raw_url: request.urls[0].url.toString(),
    method: request.urls[0].method.toLowerCase().toString()
  };
  if (request.cookies) {
    requestJson.cookies = Object.fromEntries(request.cookies.map((c) => [c[0].toString(), c[1].toString()]));
  }
  if (request.headers.length) {
    const headers = request.headers.headers.filter((h) => h[1] !== null).map((h) => [h[0].toString(), h[1].toString()]);
    requestJson.headers = Object.fromEntries(headers);
  }
  if (request.urls[0].queryDict) {
    requestJson.queries = Object.fromEntries(request.urls[0].queryDict.map((q) => [
      q[0].toString(),
      Array.isArray(q[1]) ? q[1].map((qq) => qq.toString()) : q[1].toString()
    ]));
  }
  if (request.data) {
    Object.assign(requestJson, getDataString6(request));
  } else if (request.multipartUploads) {
    Object.assign(requestJson, getFilesString2(request));
  }
  if (request.insecure) {
    requestJson.insecure = false;
  }
  if (request.urls[0].auth) {
    const [user, password] = request.urls[0].auth;
    requestJson.auth = {
      user: user.toString(),
      password: password.toString()
    };
    if (request.authType) {
      requestJson.auth_type = request.authType;
    }
  }
  if (request.awsSigV4) {
    requestJson.aws_sigv4 = request.awsSigV4.toString();
  }
  if (request.delegation) {
    requestJson.delegation = request.delegation.toString();
  }
  if (Object.prototype.hasOwnProperty.call(request, "followRedirects")) {
    requestJson.follow_redirects = request.followRedirects;
  }
  if (request.timeout) {
    requestJson.timeout = parseFloat(request.timeout.toString());
  }
  if (request.connectTimeout) {
    requestJson.connect_timeout = parseFloat(request.connectTimeout.toString());
  }
  return JSON.stringify(Object.keys(requestJson).length ? requestJson : "{}", null, 4) + "\n";
}
function toJsonStringWarn(curlCommand, warnings = []) {
  const requests = parseCurlCommand(curlCommand, supportedArgs11, warnings);
  const json = _toJsonString(requests, warnings);
  return [json, warnings];
}
function toJsonString(curlCommand) {
  return toJsonStringWarn(curlCommand)[0];
}

// node_modules/curlconverter/dist/src/generators/matlab/common.js
var regexEscape5 = /(?! )(\p{C}|\p{Z})/gu;
function strToParts(s) {
  if (!s) {
    return ["''"];
  }
  const parts = s.replace(/'/g, "''").split(regexEscape5).filter((x) => x).flatMap((x) => {
    if (x.match(regexEscape5)) {
      if (x.length === 1) {
        switch (x) {
          case "\x07":
            return "sprintf('\\a')";
          case "\b":
            return "sprintf('\\b')";
          case "\f":
            return "sprintf('\\f')";
          case "\n":
            return "newline";
          case "\r":
            return "sprintf('\\r')";
          case "	":
            return "sprintf('\\t')";
          case "\v":
            return "sprintf('\\v')";
          default:
            return `char(${x.charCodeAt(0)})`;
        }
      } else {
        return [`char(${x.charCodeAt(0)})`, `char(${x.charCodeAt(1)})`];
      }
    }
    return "'" + x + "'";
  });
  return parts;
}
function joinParts(parts) {
  if (parts.length > 1) {
    return "[" + parts.join(" ") + "]";
  }
  if (parts.length === 0) {
    return "''";
  }
  return parts[0];
}
function reprStr8(s) {
  return joinParts(strToParts(s));
}
function repr9(w) {
  if (w === null || w.length === 0) {
    return "''";
  }
  let parts = [];
  for (const t of w.tokens) {
    if (typeof t === "string") {
      parts = parts.concat(strToParts(t));
    } else if (t.type === "variable") {
      parts.push("getenv(" + reprStr8(t.value) + ")");
    } else {
      parts.push("system(" + reprStr8(t.value) + "){2}");
    }
  }
  return joinParts(parts);
}
function setVariableValue(outputVariable, value, termination) {
  let result = "";
  if (outputVariable) {
    result += outputVariable + " = ";
  }
  result += value;
  result += typeof termination === "undefined" || termination === null ? ";" : termination;
  return result;
}
function callFunction(outputVariable, functionName, params, termination) {
  let functionCall = functionName + "(";
  if (Array.isArray(params)) {
    const singleLine = params.map((x) => Array.isArray(x) ? x.join(", ") : x).join(", ");
    const indentLevel = 1;
    const indent3 = " ".repeat(4 * indentLevel);
    const skipToNextLine = "...\n" + indent3;
    let multiLine = skipToNextLine;
    multiLine += params.map((x) => Array.isArray(x) ? x.join(", ") : x).join("," + skipToNextLine);
    multiLine += "...\n";
    const combinedSingleLineLength = [outputVariable, functionName, singleLine].map((x) => x ? x.length : 0).reduce((x, y) => x + y) + (outputVariable ? 3 : 0) + 2 + (termination ? termination.length : 1);
    functionCall += combinedSingleLineLength < 120 ? singleLine : multiLine;
  } else {
    functionCall += params;
  }
  functionCall += ")";
  return setVariableValue(outputVariable, functionCall, termination);
}
function addCellArray(mapping, keysNotToQuote, indentLevel = 1, pairs) {
  if (mapping.length === 0)
    return "";
  const indentUnit = " ".repeat(4);
  const indent3 = indentUnit.repeat(indentLevel);
  const indentPrevLevel = indentUnit.repeat(indentLevel - 1);
  const separator = pairs ? ", " : " ";
  let response = "";
  if (!pairs) {
    response += "{";
  }
  if (pairs && mapping.length > 1) {
    response += "...";
  }
  for (const [counter, [key, value]] of mapping.entries()) {
    const k = typeof key === "string" ? reprStr8(key) : repr9(key);
    let val;
    if (keysNotToQuote && keysNotToQuote.includes(key.toLowerCase().toString())) {
      val = value.toString();
    } else {
      val = typeof value === "string" ? reprStr8(value) : repr9(value);
    }
    if (mapping.length > 1) {
      response += "\n" + indent3;
    }
    response += k + separator + val;
    if (pairs && mapping.length > 1) {
      if (counter !== mapping.length - 1) {
        response += ",";
      }
      response += "...";
    }
  }
  if (mapping.length > 1) {
    response += "\n" + indentPrevLevel;
  }
  if (!pairs) {
    response += "}";
  }
  return response;
}
function structify(obj, indentLevel) {
  let response = "";
  indentLevel = !indentLevel ? 1 : ++indentLevel;
  const indent3 = " ".repeat(4 * indentLevel);
  const prevIndent = " ".repeat(4 * (indentLevel - 1));
  if (obj instanceof Array) {
    const list = [];
    let listContainsNumbers = true;
    for (const k in obj) {
      if (listContainsNumbers && typeof obj[k] !== "number") {
        listContainsNumbers = false;
      }
      const value = structify(obj[k], indentLevel);
      list.push(`${value}`);
    }
    if (listContainsNumbers) {
      const listString = list.join(" ");
      response += `[${listString}]`;
    } else {
      list.unshift("{{");
      const listString = list.join(`
${indent3}`);
      response += `${listString}
${prevIndent}}}`;
    }
  } else if (obj instanceof Object) {
    response += "struct(...";
    let first = true;
    for (const k in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, k)) {
        if (!k[0].match(/[a-z]/i)) {
          throw new CCError("MATLAB structs do not support keys starting with non-alphabet symbols");
        }
        if (first) {
          first = false;
        } else {
          response += ",...";
        }
        response += `
${indent3}`;
        response += `'${k}', `;
        response += structify(obj[k], indentLevel);
      }
    }
    response += "...";
    response += `
${prevIndent})`;
  } else if (typeof obj === "number") {
    response += obj.toString();
  } else {
    response += obj === null ? "string(nan)" : reprStr8(obj);
  }
  return response;
}
function containsBody(request) {
  return Boolean(request.data || request.multipartUploads);
}
function prepareQueryString(request) {
  if (!request.urls[0].queryList) {
    return null;
  }
  return setVariableValue("params", addCellArray(request.urls[0].queryList));
}
function prepareCookies(request) {
  if (!request.cookies) {
    return null;
  }
  return setVariableValue("cookies", addCellArray(request.cookies));
}
var cookieString = "char(join(join(cookies, '='), '; '))";
var paramsString = "char(join(join(params, '='), '&'))";

// node_modules/curlconverter/dist/src/generators/matlab/webservices.js
function isSupportedByWebServices(request) {
  return ["get", "post", "put", "delete", "patch"].includes(request.urls[0].method.toLowerCase().toString()) && !request.multipartUploads && !request.insecure;
}
function setHeader(headers, header, value, lowercase) {
  headers.push([lowercase ? header.toLowerCase() : header, value]);
}
function parseWebOptions(request) {
  const options = {};
  const method = request.urls[0].method.toLowerCase().toString();
  if (method !== "get" && method !== "post") {
    options.RequestMethod = request.urls[0].method.toLowerCase();
  }
  const headers = [];
  const preformattedHeaders = [];
  if (request.urls[0].auth) {
    const [username, password] = request.urls[0].auth;
    if (username.length) {
      options.Username = username;
      options.Password = password;
    } else {
      const authHeader = `['Basic ' matlab.net.base64encode(${repr9(joinWords(request.urls[0].auth, ":"))})]`;
      setHeader(headers, new Word("Authorization"), new Word(authHeader), request.headers.lowercase);
      preformattedHeaders.push("authorization");
    }
  }
  if (request.headers.length) {
    for (const [header, value] of request.headers) {
      if (value === null) {
        continue;
      }
      switch (header.toLowerCase().toString()) {
        case "user-agent":
          options.UserAgent = value;
          break;
        case "content-type":
          options.MediaType = value;
          break;
        case "cookie":
          if (request.cookies) {
            setHeader(headers, new Word("Cookie"), new Word(cookieString), request.headers.lowercase);
            preformattedHeaders.push("cookie");
          } else {
            setHeader(headers, header, value, request.headers.lowercase);
          }
          break;
        case "accept":
          switch (value.toLowerCase().toString()) {
            case "application/json":
              options.ContentType = "json";
              break;
            case "text/csv":
              options.ContentType = "table";
              break;
            case "text/plain":
            case "text/html":
            case "application/javascript":
            case "application/x-javascript":
            case "application/x-www-form-urlencoded":
              options.ContentType = "text";
              break;
            case "text/xml":
            case "application/xml":
              options.ContentType = "xmldom";
              break;
            case "application/octet-stream":
              options.ContentType = "binary";
              break;
            default:
              if (value.startsWith("image/")) {
                options.ContentType = "image";
              } else if (value.startsWith("audio/")) {
                options.ContentType = "audio";
              } else {
                setHeader(headers, header, value, request.headers.lowercase);
              }
          }
          break;
        default:
          setHeader(headers, header, value, request.headers.lowercase);
      }
    }
  }
  if (headers.length > 0) {
    const indentLevel = 1 + (Object.keys(options).length === 0 ? 0 : 1);
    options.HeaderFields = addCellArray(headers, preformattedHeaders, indentLevel);
  }
  return options;
}
function prepareOptions(request, options) {
  const lines = [];
  if (Object.keys(options).length === 0) {
    return lines;
  }
  const pairValues = addCellArray(Object.entries(options), ["headerfields"], 1, true);
  lines.push(callFunction("options", "weboptions", pairValues));
  return lines;
}
function prepareBasicURI(request) {
  const response = [];
  if (request.urls[0].queryList) {
    response.push(setVariableValue("baseURI", repr9(request.urls[0].urlWithoutQueryList)));
    response.push(setVariableValue("uri", `[baseURI '?' ${paramsString}]`));
  } else {
    response.push(setVariableValue("uri", repr9(request.urls[0].url)));
  }
  return response;
}
function prepareBasicData(request) {
  var _a;
  if (request.data && request.data.length === 0) {
    return setVariableValue("body", repr9(new Word()));
  }
  if (!request.data) {
    return [];
  }
  let response = [];
  if (request.data.charAt(0) === "@") {
    response.push(callFunction("body", "fileread", repr9(request.data.slice(1))));
    if (!request.isDataBinary) {
      response.push(setVariableValue("body(body==13 | body==10)", "[]"));
    }
  } else if (request.data.isString()) {
    try {
      const jsonData = JSON.parse((_a = request.data) === null || _a === void 0 ? void 0 : _a.toString());
      if (typeof jsonData === "object") {
        let jsonText = structify(jsonData);
        if (!jsonText.startsWith("struct"))
          jsonText = reprStr8(jsonText);
        response = setVariableValue("body", jsonText);
      } else {
        response = setVariableValue("body", repr9(request.data));
      }
    } catch (e) {
      response = setVariableValue("body", repr9(request.data));
    }
  }
  return response;
}
function prepareWebCall(request, options) {
  const lines = [];
  const webFunction = containsBody(request) ? "webwrite" : "webread";
  const params = ["uri"];
  if (containsBody(request)) {
    params.push("body");
  }
  if (Object.keys(options).length > 0) {
    params.push("options");
  }
  lines.push(callFunction("response", webFunction, params));
  return lines;
}
function toWebServices(request, warnings) {
  let lines = [
    "%% Web Access using Data Import and Export API"
  ];
  if (!isSupportedByWebServices(request)) {
    lines.push("% This is not possible with the webread/webwrite API");
    return [lines, warnings];
  }
  const options = parseWebOptions(request);
  lines = lines.concat([
    prepareQueryString(request),
    prepareCookies(request),
    prepareBasicURI(request),
    prepareBasicData(request),
    prepareOptions(request, options),
    prepareWebCall(request, options)
  ]);
  return [lines, warnings];
}

// node_modules/curlconverter/dist/src/generators/matlab/httpinterface.js
function prepareHeaders(request) {
  if (!request.headers.length) {
    return null;
  }
  const headerStrs = [];
  for (const [key, value] of request.headers) {
    if (value === null) {
      continue;
    }
    const keyStr = key.toLowerCase().toString();
    if (keyStr === "cookie" && request.cookies) {
      const cookieFieldParams = callFunction(null, "cellfun", [
        "@(x) Cookie(x{:})",
        callFunction(null, "num2cell", ["cookies", "2"], "")
      ], "");
      headerStrs.push(callFunction(null, "field.CookieField", cookieFieldParams, ""));
    } else if (keyStr === "accept") {
      const accepts = value.split(",");
      if (accepts.length === 1) {
        headerStrs.push(`field.AcceptField(MediaType(${repr9(value)}))`);
      } else {
        let acceptheader = "field.AcceptField([";
        for (const accept of accepts) {
          acceptheader += `
        MediaType(${repr9(accept.trim())})`;
        }
        acceptheader += "\n    ])";
        headerStrs.push(acceptheader);
      }
    } else {
      headerStrs.push(`HeaderField(${repr9(key)}, ${repr9(value)})`);
    }
  }
  if (headerStrs.length === 1) {
    return setVariableValue("header", headerStrs[0]);
  }
  let header = "[\n";
  header += "    " + headerStrs.join("\n    ") + "\n";
  header += "]'";
  return setVariableValue("header", header);
}
function prepareURI(request) {
  const uriParams = [];
  if (request.urls[0].queryList) {
    uriParams.push(repr9(request.urls[0].urlWithoutQueryList));
    uriParams.push("QueryParameter(params')");
  } else {
    uriParams.push(repr9(request.urls[0].url));
  }
  return callFunction("uri", "URI", uriParams);
}
function prepareAuth(request) {
  const options = [];
  const optionsParams = [];
  if (request.urls[0].auth) {
    const [usr, pass] = request.urls[0].auth;
    const userfield = `'Username', ${repr9(usr)}`;
    const passfield = `'Password', ${repr9(pass)}`;
    const authparams = (usr.length ? `${userfield}, ` : "") + passfield;
    optionsParams.push(reprStr8("Credentials"), "cred");
    options.push(callFunction("cred", "Credentials", authparams));
  }
  if (request.insecure) {
    optionsParams.push(reprStr8("VerifyServerName"), "false");
  }
  if (optionsParams.length > 0) {
    options.push(callFunction("options", "HTTPOptions", optionsParams));
  }
  return options;
}
function prepareMultipartUploads(request) {
  if (!request.multipartUploads) {
    return null;
  }
  const params = [];
  for (const m of request.multipartUploads) {
    const readsFile = "contentFile" in m;
    const value = readsFile ? m.contentFile.prepend("@") : m.content;
    const fileProvider = prepareDataProvider(value, null, "", 1, true, !readsFile);
    params.push([repr9(m.name), fileProvider]);
  }
  return callFunction("body", "MultipartFormProvider", params);
}
function isJsonString(str) {
  try {
    JSON.parse(str);
  } catch (e) {
    return false;
  }
  return true;
}
function prepareDataProvider(value, output, termination, indentLevel, isDataBinary = true, isDataRaw = false) {
  if (!isDataRaw && value.charAt(0) === "@") {
    const filename = value.slice(1);
    if (!isDataBinary) {
      return [
        callFunction(output, "fileread", repr9(filename)),
        setVariableValue(`${output}(${output}==13 | ${output}==10)`, "[]")
      ];
    }
    const isImageProvider = (/* @__PURE__ */ new Set(["jpeg", "jpg", "png", "tif", "gif"])).has(filename.split(".")[1].toString());
    const provider = isImageProvider ? "ImageProvider" : "FileProvider";
    return callFunction(output, provider, repr9(filename), termination);
  }
  if (!value.length) {
    return callFunction(output, "FileProvider", "", termination);
  }
  if (value.isString() && isJsonString(value.toString())) {
    const obj = JSON.parse(value.toString());
    try {
      const structure = structify(obj, indentLevel);
      return callFunction(output, "JSONProvider", structure, termination);
    } catch (e) {
      return callFunction(output, "StringProvider", repr9(value), termination);
    }
  }
  const formValue = value.split("&").map((x) => x.split("=").map((x2) => repr9(x2)));
  return callFunction(output, "FormProvider", formValue, termination);
}
function prepareData(request) {
  if (!request.data) {
    return null;
  }
  if (request.data && request.data.split("&", 2).length > 1) {
    const data = request.data.split("&").map((x) => x.split("=").map((x2) => {
      let ans = repr9(x2);
      if (x2.isString()) {
        try {
          const jsonData = JSON.parse(x2.toString());
          if (typeof jsonData === "object") {
            ans = callFunction(null, "JSONProvider", structify(jsonData, 1), "");
          }
        } catch (e) {
        }
      }
      return ans;
    }));
    return callFunction("body", "FormProvider", data);
  }
  let response = prepareDataProvider(request.data, "body", ";", 0, !!request.isDataBinary, !!request.isDataRaw);
  if (!response) {
    response = setVariableValue("body", repr9(request.data));
  }
  return response;
}
function prepareRequestMessage(request) {
  const method = request.urls[0].method.toLowerCase();
  let reqMessage = [repr9(method)];
  if (request.headers.length) {
    reqMessage.push("header");
  }
  if (containsBody(request)) {
    if (reqMessage.length === 1) {
      reqMessage.push("[]");
    }
    reqMessage.push("body");
  }
  if (!request.headers.length && !containsBody(request) && method.toString() === "get") {
    reqMessage = "";
  }
  const params = ["uri.EncodedURI"];
  if (request.urls[0].auth || request.insecure) {
    params.push("options");
  }
  const response = [
    callFunction("response", "RequestMessage", reqMessage, callFunction(null, ".send", params))
  ];
  return response.join("\n");
}
function toHTTPInterface(request, warnings) {
  return [
    [
      "%% HTTP Interface",
      "import matlab.net.*",
      "import matlab.net.http.*",
      containsBody(request) ? "import matlab.net.http.io.*" : null,
      "",
      prepareQueryString(request),
      prepareCookies(request),
      prepareHeaders(request),
      prepareURI(request),
      prepareAuth(request),
      prepareMultipartUploads(request),
      prepareData(request),
      prepareRequestMessage(request),
      ""
    ],
    warnings
  ];
}

// node_modules/curlconverter/dist/src/generators/matlab/matlab.js
var supportedArgs12 = /* @__PURE__ */ new Set([
  ...COMMON_SUPPORTED_ARGS,
  "insecure",
  "no-insecure",
  "form",
  "form-string"
]);
function _toMATLAB(requests, warnings = []) {
  const request = getFirst(requests, warnings);
  const [webServicesLines] = toWebServices(request, warnings);
  const [httpInterfaceLines] = toHTTPInterface(request, warnings);
  const lines = webServicesLines.concat("", httpInterfaceLines);
  return lines.flat().filter((line) => line !== null).join("\n");
}
function toMATLABWarn(curlCommand, warnings = []) {
  const requests = parseCurlCommand(curlCommand, supportedArgs12, warnings);
  const matlab = _toMATLAB(requests, warnings);
  return [matlab, warnings];
}
function toMATLAB(curlCommand) {
  return toMATLABWarn(curlCommand)[0];
}

// node_modules/curlconverter/dist/src/generators/javascript/request.js
var supportedArgs13 = /* @__PURE__ */ new Set([
  ...COMMON_SUPPORTED_ARGS,
  "next"
]);
function requestToNodeRequest(request, requestIndex, definedVariables, imports, warnings = []) {
  warnIfPartsIgnored(request, warnings);
  let nodeRequestCode = "";
  if (request.headers.length) {
    nodeRequestCode += defVar(definedVariables, "headers", "{\n");
    let i = 0;
    for (const [headerName, headerValue] of request.headers) {
      nodeRequestCode += "    " + repr(headerName, imports) + ": " + repr(headerValue || new Word(), imports);
      nodeRequestCode += i < request.headers.length - 1 ? ",\n" : "\n";
      i++;
    }
    nodeRequestCode += "};\n\n";
  }
  if (request.data) {
    nodeRequestCode += defVar(definedVariables, "dataString", repr(request.data, imports) + ";\n\n");
  }
  nodeRequestCode += defVar(definedVariables, "options", "{\n");
  nodeRequestCode += "    url: " + repr(request.urls[0].url, imports);
  if (!eq(request.urls[0].method.toUpperCase(), "GET")) {
    nodeRequestCode += ",\n    method: " + repr(request.urls[0].method.toUpperCase(), imports);
  }
  if (request.headers.length) {
    nodeRequestCode += ",\n";
    nodeRequestCode += "    headers: headers";
    const h = request.headers.get("accept-encoding");
    if (h) {
      const acceptedEncodings = h.split(",").map((s) => s.trim().toLowerCase().toString());
      if (acceptedEncodings.includes("gzip") || acceptedEncodings.includes("deflate")) {
        nodeRequestCode += ",\n    gzip: true";
      }
    }
  }
  if (request.data) {
    nodeRequestCode += ",\n    body: dataString";
  }
  if (request.urls[0].auth) {
    nodeRequestCode += ",\n";
    const [user, password] = request.urls[0].auth;
    nodeRequestCode += "    auth: {\n";
    nodeRequestCode += "        'user': " + repr(user, imports) + ",\n";
    nodeRequestCode += "        'pass': " + repr(password, imports) + "\n";
    nodeRequestCode += "    }\n";
  } else {
    nodeRequestCode += "\n";
  }
  nodeRequestCode += "};\n\n";
  if (requestIndex === 0) {
    nodeRequestCode += "function callback(error, response, body) {\n";
    nodeRequestCode += "    if (!error && response.statusCode == 200) {\n";
    nodeRequestCode += "        console.log(body);\n";
    nodeRequestCode += "    }\n";
    nodeRequestCode += "}\n\n";
  }
  nodeRequestCode += "request(options, callback);";
  return nodeRequestCode + "\n";
}
function defVar(variables, name, value) {
  if (!variables.has(name)) {
    variables.add(name);
    name = "var " + name;
  }
  return `${name} = ${value}`;
}
function _toNodeRequest(requests, warnings = []) {
  const code = "var request = require('request');\n";
  const definedVariables = /* @__PURE__ */ new Set(["request"]);
  const imports = [];
  const requestCode = requests.map((r, i) => requestToNodeRequest(r, i, definedVariables, imports, warnings));
  return code + reprImportsRequire(imports) + "\n" + requestCode.join("\n\n");
}
function toNodeRequestWarn(curlCommand, warnings = []) {
  const requests = parseCurlCommand(curlCommand, supportedArgs13, warnings);
  warnings.unshift(["node-request", "the request package is deprecated"]);
  const nodeRequests = _toNodeRequest(requests, warnings);
  return [nodeRequests, warnings];
}
function toNodeRequest(curlCommand) {
  return toNodeRequestWarn(curlCommand)[0];
}

// node_modules/curlconverter/dist/src/generators/php/php.js
var supportedArgs14 = /* @__PURE__ */ new Set([
  ...COMMON_SUPPORTED_ARGS,
  "max-time",
  "insecure",
  "no-insecure",
  "compressed",
  "no-compressed",
  "digest",
  "no-digest",
  "location",
  "no-location",
  "form",
  "form-string",
  "proxy",
  "proxy-user"
]);
var regexSingleEscape2 = /'|\\/gu;
var regexDoubleEscape2 = /"|\$|\\|\p{C}|\p{Z}/gu;
function reprStr9(s) {
  let [quote, regex] = ["'", regexSingleEscape2];
  if (s.includes("'") && !s.includes('"') || /[^\x20-\x7E]/.test(s)) {
    [quote, regex] = ['"', regexDoubleEscape2];
  }
  return quote + s.replace(regex, (c) => {
    switch (c) {
      case " ":
        return " ";
      case "$":
        return quote === "'" ? "$" : "\\$";
      case "\\":
        return "\\\\";
      case "'":
      case '"':
        return c === quote ? "\\" + c : c;
      case "\n":
        return "\\n";
      case "\r":
        return "\\r";
      case "	":
        return "\\t";
      case "\v":
        return "\\v";
      case "\x1B":
        return "\\e";
      case "\f":
        return "\\f";
    }
    const hex = c.codePointAt(0).toString(16);
    if (hex.length > 2) {
      return "\\u{" + hex + "}";
    }
    return "\\x" + hex.padStart(2, "0");
  }) + quote;
}
function repr10(w) {
  const args = [];
  for (const t of w.tokens) {
    if (typeof t === "string") {
      args.push(reprStr9(t));
    } else if (t.type === "variable") {
      args.push("getenv(" + reprStr9(t.value) + ") ?? " + reprStr9(""));
    } else if (t.type === "command") {
      args.push("shell_exec(" + reprStr9(t.value) + ")");
    }
  }
  return args.join(" . ");
}
function _toPhp(requests, warnings = []) {
  const request = getFirst(requests, warnings);
  let cookieString2;
  if (request.headers.has("cookie")) {
    cookieString2 = request.headers.get("cookie");
    request.headers.delete("cookie");
  }
  let phpCode = "<?php\n";
  phpCode += "$ch = curl_init();\n";
  phpCode += "curl_setopt($ch, CURLOPT_URL, " + repr10(request.urls[0].url) + ");\n";
  phpCode += "curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n";
  phpCode += "curl_setopt($ch, CURLOPT_CUSTOMREQUEST, " + repr10(request.urls[0].method) + ");\n";
  if (request.compressed) {
    request.headers.setIfMissing("Accept-Encoding", "gzip");
  }
  if (request.headers.length) {
    let headersArrayCode = "[\n";
    for (const [headerName, headerValue] of request.headers) {
      if (headerValue === null) {
        continue;
      }
      headersArrayCode += "    " + repr10(joinWords([headerName, headerValue], ": ")) + ",\n";
    }
    headersArrayCode += "]";
    phpCode += "curl_setopt($ch, CURLOPT_HTTPHEADER, " + headersArrayCode + ");\n";
  }
  if (cookieString2) {
    phpCode += "curl_setopt($ch, CURLOPT_COOKIE, " + repr10(cookieString2) + ");\n";
  }
  if (request.urls[0].auth && ["basic", "digest"].includes(request.authType)) {
    const authType = request.authType === "digest" ? "CURLAUTH_DIGEST" : "CURLAUTH_BASIC";
    phpCode += "curl_setopt($ch, CURLOPT_HTTPAUTH, " + authType + ");\n";
    phpCode += "curl_setopt($ch, CURLOPT_USERPWD, " + repr10(joinWords(request.urls[0].auth, ":")) + ");\n";
  }
  if (request.data || request.multipartUploads) {
    let requestDataCode = "";
    if (request.multipartUploads) {
      requestDataCode = "[\n";
      for (const m of request.multipartUploads) {
        if ("contentFile" in m) {
          requestDataCode += "    " + repr10(m.name) + " => new CURLFile(" + repr10(m.contentFile) + "),\n";
        } else {
          requestDataCode += "    " + repr10(m.name) + " => " + repr10(m.content) + ",\n";
        }
      }
      requestDataCode += "]";
    } else if (request.isDataBinary && request.data.charAt(0) === "@") {
      requestDataCode = "file_get_contents(" + repr10(request.data.slice(1)) + ")";
    } else {
      requestDataCode = repr10(request.data);
    }
    phpCode += "curl_setopt($ch, CURLOPT_POSTFIELDS, " + requestDataCode + ");\n";
  }
  if (request.proxy) {
    phpCode += "curl_setopt($ch, CURLOPT_PROXY, " + repr10(request.proxy) + ");\n";
    if (request.proxyAuth) {
      phpCode += "curl_setopt($ch, CURLOPT_PROXYUSERPWD, " + repr10(request.proxyAuth) + ");\n";
    }
  }
  if (request.timeout) {
    phpCode += "curl_setopt($ch, CURLOPT_TIMEOUT, " + (parseInt(request.timeout.toString(), 10) || 0) + ");\n";
  }
  if (request.followRedirects) {
    phpCode += "curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n";
  }
  if (request.insecure) {
    phpCode += "curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n";
    phpCode += "curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n";
  }
  phpCode += "\n$response = curl_exec($ch);\n\n";
  phpCode += "curl_close($ch);\n";
  return phpCode;
}
function toPhpWarn(curlCommand, warnings = []) {
  const requests = parseCurlCommand(curlCommand, supportedArgs14, warnings);
  const php = _toPhp(requests, warnings);
  return [php, warnings];
}
function toPhp(curlCommand) {
  return toPhpWarn(curlCommand)[0];
}

// node_modules/curlconverter/dist/src/generators/php/requests.js
var supportedArgs15 = /* @__PURE__ */ new Set([
  ...COMMON_SUPPORTED_ARGS
]);
function _toPhpRequests(requests, warnings = []) {
  const request = getFirst(requests, warnings);
  let headerString;
  if (request.headers.length) {
    headerString = "$headers = array(\n";
    let i = 0;
    for (const [headerName, headerValue] of request.headers) {
      if (headerValue === null) {
        continue;
      }
      headerString += "    " + repr10(headerName) + " => " + repr10(headerValue);
      if (i < request.headers.length - 1) {
        headerString += ",\n";
      }
      i++;
    }
    headerString += "\n);";
  } else {
    headerString = "$headers = array();";
  }
  let optionsString;
  if (request.urls[0].auth) {
    const [user, password] = request.urls[0].auth;
    optionsString = "$options = array('auth' => array(" + repr10(user) + ", " + repr10(password) + "));";
  }
  let dataString;
  if (request.data) {
    const [parsedQueryString] = parseQueryString(request.data);
    dataString = "$data = array(\n";
    if (!parsedQueryString || !parsedQueryString.length) {
      dataString = "$data = " + repr10(request.data) + ";";
    } else {
      const terms = [];
      for (const q of parsedQueryString) {
        const [key, value] = q;
        terms.push("    " + repr10(key) + " => " + repr10(value));
      }
      dataString += terms.join(",\n") + "\n);";
    }
  }
  let requestLine = "$response = Requests::" + request.urls[0].method.toLowerCase().toString() + "(" + repr10(request.urls[0].url);
  requestLine += ", $headers";
  if (dataString) {
    requestLine += ", $data";
  }
  if (optionsString) {
    requestLine += ", $options";
  }
  requestLine += ");";
  let phpCode = "<?php\n";
  phpCode += "include('vendor/rmccue/requests/library/Requests.php');\n";
  phpCode += "Requests::register_autoloader();\n";
  phpCode += headerString + "\n";
  if (dataString) {
    phpCode += dataString + "\n";
  }
  if (optionsString) {
    phpCode += optionsString + "\n";
  }
  phpCode += requestLine;
  return phpCode + "\n";
}
function toPhpRequestsWarn(curlCommand, warnings = []) {
  const requests = parseCurlCommand(curlCommand, supportedArgs15, warnings);
  const php = _toPhpRequests(requests, warnings);
  return [php, warnings];
}
function toPhpRequests(curlCommand) {
  return toPhpRequestsWarn(curlCommand)[0];
}

// node_modules/curlconverter/dist/src/generators/r.js
var supportedArgs16 = /* @__PURE__ */ new Set([
  ...COMMON_SUPPORTED_ARGS,
  "form",
  "form-string",
  "insecure",
  "no-insecure"
]);
var regexBacktickEscape = /`|\\|\p{C}|\p{Z}/gu;
function reprBacktick2(s) {
  if (!s.isString()) {
  }
  return "`" + s.toString().replace(regexBacktickEscape, (c) => {
    switch (c) {
      case " ":
        return " ";
      case "\x07":
        return "\\a";
      case "\b":
        return "\\b";
      case "\f":
        return "\\f";
      case "\n":
        return "\\n";
      case "\r":
        return "\\r";
      case "	":
        return "\\t";
      case "\v":
        return "\\v";
      case "\\":
        return "\\\\";
      case "`":
        return "\\`";
    }
    const hex = c.codePointAt(0).toString(16);
    if (hex.length <= 2) {
      return "\\x" + hex.padStart(2, "0");
    }
    if (hex.length <= 4) {
      return "\\u" + hex.padStart(4, "0");
    }
    return "\\U" + hex.padStart(8, "0");
  }) + "`";
}
function reprStr10(s) {
  const quote = s.includes('"') && !s.includes("'") ? "'" : '"';
  return reprStr5(s, quote);
}
function repr11(w) {
  const args = [];
  for (const t of w.tokens) {
    if (typeof t === "string") {
      args.push(reprStr10(t));
    } else if (t.type === "variable") {
      args.push("Sys.getenv(" + reprStr10(t.value) + ")");
    } else {
      args.push("system(" + reprStr10(t.value) + ", intern = TRUE)");
    }
  }
  if (args.length === 1) {
    return args[0];
  }
  return "paste(" + args.join(", ") + ', sep = "")';
}
function getCookieDict(request) {
  if (!request.cookies) {
    return null;
  }
  let cookieDict = "cookies = c(\n";
  const lines = [];
  for (const [key, value] of request.cookies) {
    try {
      const decoded = wordDecodeURIComponent(value.replace(/\+/g, " "));
      lines.push("  " + reprBacktick2(key) + " = " + repr11(decoded));
    } catch (_a) {
      return null;
    }
  }
  cookieDict += lines.join(",\n");
  cookieDict += "\n)\n";
  request.headers.delete("Cookie");
  return cookieDict;
}
function getQueryList(request) {
  if (request.urls[0].queryList === void 0) {
    return void 0;
  }
  let queryList = "params = list(\n";
  queryList += request.urls[0].queryList.map((param) => {
    const [key, value] = param;
    return "  " + reprBacktick2(key) + " = " + repr11(value);
  }).join(",\n");
  queryList += "\n)\n";
  return queryList;
}
function getFilesString3(request) {
  if (!request.multipartUploads) {
    return void 0;
  }
  let filesString = "files = list(\n";
  filesString += request.multipartUploads.map((m) => {
    let fileParam;
    if ("contentFile" in m) {
      fileParam = "  " + reprBacktick2(m.name) + " = upload_file(" + repr11(m.contentFile) + ")";
    } else {
      fileParam = "  " + reprBacktick2(m.name) + " = " + repr11(m.content);
    }
    return fileParam;
  }).join(",\n");
  filesString += "\n)\n";
  return filesString;
}
function _toR(requests, warnings = []) {
  const request = getFirst(requests, warnings);
  const cookieDict = getCookieDict(request);
  let headerDict;
  if (request.headers.length) {
    const hels = [];
    headerDict = "headers = c(\n";
    for (const [headerName, headerValue] of request.headers) {
      if (headerValue !== null) {
        hels.push("  " + reprBacktick2(headerName) + " = " + repr11(headerValue));
      }
    }
    headerDict += hels.join(",\n");
    headerDict += "\n)\n";
  }
  const queryList = getQueryList(request);
  let dataString;
  let dataIsList;
  let filesString;
  if (request.data) {
    if (request.data.startsWith("@") && !request.isDataRaw) {
      const filePath = request.data.slice(1);
      dataString = "data = upload_file(" + repr11(filePath) + ")";
    } else {
      const [parsedQueryString] = parseQueryString(request.data);
      dataIsList = parsedQueryString && parsedQueryString.length;
      if (dataIsList) {
        dataString = "data = list(\n";
        dataString += parsedQueryString.map((q) => {
          const [key, value] = q;
          return "  " + reprBacktick2(key) + " = " + repr11(value);
        }).join(",\n");
        dataString += "\n)\n";
      } else {
        dataString = "data = " + repr11(request.data) + "\n";
      }
    }
  } else if (request.multipartUploads) {
    filesString = getFilesString3(request);
  }
  const url = request.urls[0].queryList ? request.urls[0].urlWithoutQueryList : request.urls[0].url;
  let requestLine = "res <- httr::";
  if (["GET", "HEAD", "PATCH", "PUT", "DELETE", "POST"].includes(request.urls[0].method.toString())) {
    requestLine += request.urls[0].method.toString() + "(";
  } else {
    requestLine += "VERB(" + repr11(request.urls[0].method) + ", ";
    if (!eq(request.urls[0].method, request.urls[0].method.toUpperCase())) {
      warnings.push([
        "non-uppercase-method",
        "httr will uppercase the method: " + JSON.stringify(request.urls[0].method.toString())
      ]);
    }
  }
  requestLine += "url = " + repr11(url);
  let requestLineBody = "";
  if (headerDict) {
    requestLineBody += ", httr::add_headers(.headers=headers)";
  }
  if (request.urls[0].queryList) {
    requestLineBody += ", query = params";
  }
  if (cookieDict) {
    requestLineBody += ", httr::set_cookies(.cookies = cookies)";
  }
  if (request.data) {
    requestLineBody += ", body = data";
    if (dataIsList) {
      requestLineBody += ', encode = "form"';
    }
  } else if (request.multipartUploads) {
    requestLineBody += ', body = files, encode = "multipart"';
  }
  if (request.insecure) {
    requestLineBody += ", config = httr::config(ssl_verifypeer = FALSE)";
  }
  if (request.urls[0].auth) {
    const [user, password] = request.urls[0].auth;
    requestLineBody += ", httr::authenticate(" + repr11(user) + ", " + repr11(password) + ")";
  }
  requestLineBody += ")";
  requestLine += requestLineBody;
  let rstatsCode = "";
  rstatsCode += "require(httr)\n\n";
  if (cookieDict) {
    rstatsCode += cookieDict + "\n";
  }
  if (headerDict) {
    rstatsCode += headerDict + "\n";
  }
  if (queryList !== void 0) {
    rstatsCode += queryList + "\n";
  }
  if (dataString) {
    rstatsCode += dataString + "\n";
  } else if (filesString) {
    rstatsCode += filesString + "\n";
  }
  rstatsCode += requestLine;
  return rstatsCode + "\n";
}
function toRWarn(curlCommand, warnings = []) {
  const requests = parseCurlCommand(curlCommand, supportedArgs16, warnings);
  const r = _toR(requests, warnings);
  return [r, warnings];
}
function toR(curlCommand) {
  return toRWarn(curlCommand)[0];
}

// node_modules/curlconverter/dist/src/generators/ruby.js
var supportedArgs17 = /* @__PURE__ */ new Set([
  ...COMMON_SUPPORTED_ARGS,
  "form",
  "form-string",
  "http0.9",
  "http1.0",
  "http1.1",
  "insecure",
  "no-digest",
  "no-http0.9",
  "no-insecure",
  "output",
  "proxy",
  "proxy-user",
  "upload-file",
  "next"
]);
var regexSingleEscape3 = /'|\\/gu;
var regexDoubleEscape3 = /"|\\|\p{C}|\p{Z}|#[{@$]/gu;
var regexCurlyEscape = /\}|\\|\p{C}|\p{Z}|#[{@$]/gu;
var regexDigit3 = /[0-9]/;
function reprStr11(s, quote) {
  if (quote === void 0) {
    quote = "'";
    if ([...s.matchAll(/\p{C}|\p{Z}/gu)].some((m) => m[0] !== " ") || s.includes("'") && !s.includes('"')) {
      quote = '"';
    }
  }
  const regexEscape7 = quote === "'" ? regexSingleEscape3 : quote === '"' ? regexDoubleEscape3 : regexCurlyEscape;
  const startQuote = quote[0];
  const endQuote = quote === "{}" ? quote[1] : quote[0];
  return startQuote + s.replace(regexEscape7, (c, index, string) => {
    switch (c[0]) {
      case " ":
        return " ";
      case "\x07":
        return "\\a";
      case "\b":
        return "\\b";
      case "\f":
        return "\\f";
      case "\n":
        return "\\n";
      case "\r":
        return "\\r";
      case "	":
        return "\\t";
      case "\v":
        return "\\v";
      case "\x1B":
        return "\\e";
      case "\\":
        return "\\\\";
      case "'":
        return "\\'";
      case '"':
        return '\\"';
      case "#":
        return "\\" + c;
      case "}":
        return "\\}";
      case "\0":
        if (!regexDigit3.test(string.charAt(index + 1))) {
          return "\\0";
        }
        break;
    }
    const codePoint = c.codePointAt(0);
    const hex = codePoint.toString(16);
    if (hex.length <= 2 && codePoint < 127) {
      return "\\x" + hex.padStart(2, "0");
    }
    if (hex.length <= 4) {
      return "\\u" + hex.padStart(4, "0");
    }
    return "\\u{" + hex + "}";
  }) + endQuote;
}
function repr12(w) {
  const args = [];
  for (const t of w.tokens) {
    if (typeof t === "string") {
      args.push(reprStr11(t));
    } else if (t.type === "variable") {
      args.push("ENV[" + reprStr11(t.value) + "]");
    } else {
      args.push("%x" + reprStr11(t.value, "{}"));
    }
  }
  return args.join(" + ");
}
function objToRuby(obj, indent3 = 0) {
  let s = "";
  if (obj instanceof Word) {
    s += repr12(obj);
  } else {
    switch (typeof obj) {
      case "string":
        s += reprStr11(obj);
        break;
      case "number":
        s += obj;
        break;
      case "boolean":
        s += obj ? "true" : "false";
        break;
      case "object":
        if (obj === null) {
          s += "nil";
        } else if (Array.isArray(obj)) {
          if (obj.length === 0) {
            s += "[]";
          } else {
            s += "[\n";
            for (const [i, item] of obj.entries()) {
              s += " ".repeat(indent3 + 2) + objToRuby(item, indent3 + 2);
              s += i === obj.length - 1 ? "\n" : ",\n";
            }
            s += " ".repeat(indent3) + "]";
          }
        } else {
          const len = Object.keys(obj).length;
          if (len === 0) {
            s += "{}";
          } else {
            s += "{\n";
            const objEntries = Object.entries(obj);
            for (const [i, [k, v]] of objEntries.entries()) {
              s += " ".repeat(indent3 + 2) + reprStr11(k) + " => " + objToRuby(v, indent3 + 2);
              s += i === objEntries.length - 1 ? "\n" : ",\n";
            }
            s += " ".repeat(indent3) + "}";
          }
        }
        break;
      default:
        throw new CCError("unexpected object type that shouldn't appear in JSON: " + typeof obj);
    }
  }
  return s;
}
function queryToRubyDict(q, indent3 = 0) {
  if (q.length === 0) {
    return "{}";
  }
  let s = "{\n";
  for (const [i, [k, v]] of q.entries()) {
    s += " ".repeat(indent3 + 2) + repr12(k) + " => " + objToRuby(v, indent3 + 2);
    s += i === q.length - 1 ? "\n" : ",\n";
  }
  s += " ".repeat(indent3) + "}";
  return s;
}
function getDataString7(request) {
  if (!request.data) {
    return ["", false];
  }
  if (!request.isDataRaw && request.data.startsWith("@")) {
    let filePath = request.data.slice(1);
    if (eq(filePath, "-")) {
      if (request.stdinFile) {
        filePath = request.stdinFile;
      } else if (request.stdin) {
        request.data = request.stdin;
      } else {
        if (request.isDataBinary) {
          return ['req.body = STDIN.read.delete("\\n")\n', false];
        } else {
          return ['req.body = STDIN.read.delete("\\n")\n', false];
        }
      }
    }
    if (!request.stdin) {
      if (request.isDataBinary) {
        return [
          "req.body = File.binread(" + repr12(filePath) + ').delete("\\n")\n',
          false
        ];
      } else {
        return [
          "req.body = File.read(" + repr12(filePath) + ').delete("\\n")\n',
          false
        ];
      }
    }
  }
  const contentTypeHeader = request.headers.get("content-type");
  const isJson = contentTypeHeader && eq(contentTypeHeader.split(";")[0].trim(), "application/json");
  if (isJson && request.data.isString()) {
    try {
      const dataAsStr = request.data.toString();
      const dataAsJson = JSON.parse(dataAsStr);
      if (typeof dataAsJson === "object" && dataAsJson !== null) {
        const roundtrips = JSON.stringify(dataAsJson) === dataAsStr;
        let code = "";
        if (!roundtrips) {
          code += "# The object won't be serialized exactly like this\n";
          code += "# req.body = " + repr12(request.data) + "\n";
        }
        code += "req.body = " + objToRuby(dataAsJson) + ".to_json\n";
        return [code, true];
      }
    } catch (_a) {
    }
  }
  const [_, queryAsDict] = parseQueryString(request.data);
  if (!request.isDataBinary && queryAsDict) {
    return ["req.set_form_data(" + queryToRubyDict(queryAsDict) + ")\n", false];
  }
  return ["req.body = " + repr12(request.data) + "\n", false];
}
function getFilesString4(request) {
  if (!request.multipartUploads) {
    return "";
  }
  const multipartUploads = request.multipartUploads.map((m) => {
    const name = repr12(m.name);
    const sentFilename = "filename" in m && m.filename && repr12(m.filename);
    if ("contentFile" in m) {
      if (eq(m.contentFile, "-")) {
        if (request.stdinFile) {
          return [
            name,
            "File.open(" + repr12(request.stdinFile) + ")",
            sentFilename
          ];
        } else if (request.stdin) {
          return [name, repr12(request.stdin), sentFilename];
        }
        return [name, "STDIN", sentFilename];
      } else if (m.contentFile === m.filename) {
        return [name, "File.open(" + repr12(m.contentFile) + ")"];
      }
      return [name, "File.open(" + repr12(m.contentFile) + ")", sentFilename];
    }
    return [name, repr12(m.content), sentFilename];
  });
  let filesString = "req.set_form(\n";
  if (multipartUploads.length === 0) {
    filesString += "  [],\n";
  } else {
    filesString += "  [\n";
    for (const [i, [name, content, filename]] of multipartUploads.entries()) {
      filesString += "    [\n";
      filesString += "      " + name + ",\n";
      filesString += "      " + content;
      if (typeof filename === "string") {
        filesString += ",\n";
        filesString += "      {filename: " + filename + "}\n";
      } else {
        filesString += "\n";
      }
      if (i === multipartUploads.length - 1) {
        filesString += "    ]\n";
      } else {
        filesString += "    ],\n";
      }
    }
    filesString += "  ],\n";
  }
  filesString += "  'multipart/form-data'\n";
  filesString += ")\n";
  return filesString;
}
function requestToRuby(request, warnings, imports) {
  warnIfPartsIgnored(request, warnings);
  let code = "";
  const methods = {
    GET: "Get",
    HEAD: "Head",
    POST: "Post",
    PATCH: "Patch",
    PUT: "Put",
    PROPPATCH: "Proppatch",
    LOCK: "Lock",
    UNLOCK: "Unlock",
    OPTIONS: "Options",
    PROPFIND: "Propfind",
    DELETE: "Delete",
    MOVE: "Move",
    COPY: "Copy",
    MKCOL: "Mkcol",
    TRACE: "Trace"
  };
  function validSymbol(s) {
    return s.isString() && /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(s.toString());
  }
  if (request.urls[0].queryDict && request.urls[0].queryDict.every((q) => validSymbol(q[0]))) {
    code += "uri = URI(" + repr12(request.urls[0].urlWithoutQueryList) + ")\n";
    code += "params = {\n";
    for (const [key, value] of request.urls[0].queryDict) {
      code += "  :" + key.toString() + " => " + objToRuby(value, 2) + ",\n";
    }
    code += "}\n";
    code += "uri.query = URI.encode_www_form(params)\n\n";
  } else {
    code += "uri = URI(" + repr12(request.urls[0].url) + ")\n";
  }
  const simple = !(request.headers.length || request.urls[0].auth || request.multipartUploads || request.data || request.urls[0].uploadFile || request.insecure || request.proxy || request.urls[0].output);
  const method = request.urls[0].method;
  if (method.isString() && has(methods, method.toString())) {
    if (method.toString() === "GET" && simple) {
      code += "res = Net::HTTP.get_response(uri)\n";
      return code;
    } else {
      code += "req = Net::HTTP::" + methods[method.toString()] + ".new(uri)\n";
    }
  } else {
    code += "req = Net::HTTPGenericRequest.new(" + repr12(request.urls[0].method) + ", true, true, uri)\n";
  }
  if (request.urls[0].auth && request.authType === "basic") {
    code += "req.basic_auth " + repr12(request.urls[0].auth[0]) + ", " + repr12(request.urls[0].auth[1]) + "\n";
  }
  let reqBody;
  if (request.urls[0].uploadFile) {
    if (eq(request.urls[0].uploadFile, "-") || eq(request.urls[0].uploadFile, ".")) {
      reqBody = "req.body = STDIN.read\n";
    } else {
      reqBody = "req.body = File.read(" + repr12(request.urls[0].uploadFile) + ")\n";
    }
  } else if (request.data) {
    let importJson = false;
    [reqBody, importJson] = getDataString7(request);
    if (importJson) {
      imports.add("json");
    }
  } else if (request.multipartUploads) {
    reqBody = getFilesString4(request);
    request.headers.delete("content-type");
  }
  const contentType = request.headers.get("content-type");
  if (contentType !== null && contentType !== void 0) {
    code += "req.content_type = " + repr12(contentType) + "\n";
    request.headers.delete("content-type");
  }
  if (request.headers.length) {
    for (const [headerName, headerValue] of request.headers) {
      if (["accept-encoding", "content-length"].includes(headerName.toLowerCase().toString())) {
        code += "# ";
      }
      code += "req[" + repr12(headerName) + "] = " + repr12(headerValue !== null && headerValue !== void 0 ? headerValue : new Word("nil")) + "\n";
    }
  }
  if (reqBody) {
    code += "\n" + reqBody;
  }
  code += "\n";
  if (request.proxy) {
    const proxy = request.proxy.includes("://") ? request.proxy : request.proxy.prepend("http://");
    code += "proxy = URI(" + repr12(proxy) + ")\n";
  }
  code += "req_options = {\n";
  code += "  use_ssl: uri.scheme == 'https'";
  if (request.insecure) {
    imports.add("openssl");
    code += ",\n";
    code += "  verify_mode: OpenSSL::SSL::VERIFY_NONE\n";
  } else {
    code += "\n";
  }
  code += "}\n";
  if (!request.proxy) {
    code += "res = Net::HTTP.start(uri.hostname, uri.port, req_options) do |http|\n";
  } else {
    if (request.proxyAuth) {
      const [proxyUser, proxyPassword] = request.proxyAuth.split(":", 2);
      code += "res = Net::HTTP.start(uri.hostname, uri.port, proxy.hostname, proxy.port, " + repr12(proxyUser) + ", " + repr12(proxyPassword || "") + ", req_options) do |http|\n";
    } else {
      code += "res = Net::HTTP.new(uri.hostname, uri.port, proxy.hostname, proxy.port, req_options).start do |http|\n";
    }
  }
  code += "  http.request(req)\n";
  code += "end";
  if (request.urls[0].output && !eq(request.urls[0].output, "/dev/null")) {
    if (eq(request.urls[0].output, "-")) {
      code += "\nputs res.body";
    } else {
      code += "\nFile.write(" + repr12(request.urls[0].output) + ", res.body)";
    }
  }
  return code + "\n";
}
function _toRuby(requests, warnings = []) {
  const imports = /* @__PURE__ */ new Set();
  const code = requests.map((r) => requestToRuby(r, warnings, imports)).join("\n\n");
  let prelude = "require 'net/http'\n";
  for (const imp of Array.from(imports).sort()) {
    prelude += "require '" + imp + "'\n";
  }
  return prelude + "\n" + code;
}
function toRubyWarn(curlCommand, warnings = []) {
  const requests = parseCurlCommand(curlCommand, supportedArgs17, warnings);
  const ruby = _toRuby(requests, warnings);
  return [ruby, warnings];
}
function toRuby(curlCommand) {
  return toRubyWarn(curlCommand)[0];
}

// node_modules/curlconverter/dist/src/generators/rust.js
var supportedArgs18 = /* @__PURE__ */ new Set([
  ...COMMON_SUPPORTED_ARGS,
  "form",
  "form-string",
  "max-redirs",
  "location",
  "no-location"
]);
var INDENTATION = " ".repeat(4);
function indent2(line, level = 1) {
  return INDENTATION.repeat(level) + line;
}
var regexEscape6 = /"|\\|\p{C}|\p{Z}/gu;
function reprStr12(s) {
  return '"' + s.replace(regexEscape6, (c) => {
    switch (c) {
      case " ":
        return " ";
      case "\n":
        return "\\n";
      case "\r":
        return "\\r";
      case "	":
        return "\\t";
      case "\0":
        return "\\0";
      case "\\":
        return "\\\\";
      case '"':
        return '\\"';
    }
    const hex = c.codePointAt(0).toString(16);
    if (hex.length <= 2) {
      return "\\x" + hex.padStart(2, "0");
    }
    return "\\u{" + hex + "}";
  }) + '"';
}
function repr13(w, imports) {
  const ret = [];
  for (const t of w.tokens) {
    if (typeof t === "string") {
      ret.push(reprStr12(t));
    } else if (t.type === "variable") {
      ret.push("env::var(" + reprStr12(t.value) + ').unwrap_or("")');
      imports.add("std::env");
    } else {
      ret.push("Command::new(" + reprStr12(t.value) + ").output().stdout");
      imports.add("std::process::Command");
    }
  }
  if (ret.length === 1) {
    return ret[0];
  }
  return "[" + ret.join(", ") + "].concat()";
}
function _toRust(requests, warnings = []) {
  const request = getFirst(requests, warnings);
  const imports = /* @__PURE__ */ new Set();
  const lines = [];
  lines.push("", "fn main() -> Result<(), Box<dyn std::error::Error>> {");
  if (request.headers.length) {
    lines.push(indent2("let mut headers = header::HeaderMap::new();"));
    const headerEnum = {
      cookie: "header::COOKIE"
    };
    for (const [headerName, headerValue] of request.headers) {
      const enumValue = headerEnum[headerName.toLowerCase().toString()];
      const name = enumValue || `"${headerName}"`;
      if (headerValue !== null) {
        lines.push(indent2(`headers.insert(${name}, ${repr13(headerValue, imports)}.parse().unwrap());`));
      }
    }
    lines.push("");
  }
  if (request.multipartUploads) {
    lines.push(indent2("let form = multipart::Form::new()"));
    const parts = request.multipartUploads.map((m) => {
      if ("contentFile" in m) {
        return indent2(`.file(${repr13(m.name, imports)}, ${repr13(m.contentFile, imports)})?`, 2);
      }
      return indent2(`.text(${repr13(m.name, imports)}, ${repr13(m.content, imports)})`, 2);
    });
    parts[parts.length - 1] += ";";
    lines.push(...parts, "");
  }
  if (!request.followRedirects) {
    lines.push(indent2("let client = reqwest::blocking::Client::builder()"));
    lines.push(indent2(".redirect(reqwest::redirect::Policy::none())", 2));
    lines.push(indent2(".build()", 2));
    lines.push(indent2(".unwrap();", 2));
  } else if (typeof request.maxRedirects === "undefined") {
    lines.push(indent2("let client = reqwest::blocking::Client::new();"));
  } else {
    lines.push(indent2("let client = reqwest::blocking::Client::builder()"));
    if (eq(request.maxRedirects, "-1")) {
      lines.push(indent2(".redirect(reqwest::redirect::Policy::custom(|attempt| { attempt.follow() }))", 2));
    } else {
      lines.push(indent2(".redirect(reqwest::redirect::Policy::limited(" + request.maxRedirects.trim().toString() + "))", 2));
    }
    lines.push(indent2(".build()", 2));
    lines.push(indent2(".unwrap();", 2));
  }
  const reqwestMethods = ["GET", "POST", "PUT", "PATCH", "DELETE", "HEAD"];
  if (reqwestMethods.includes(request.urls[0].method.toString())) {
    lines.push(indent2(`let res = client.${request.urls[0].method.toLowerCase()}(${repr13(request.urls[0].url, imports)})`));
  } else {
    lines.push(indent2(`let res = client.request(${repr13(request.urls[0].method, imports)}, ${repr13(request.urls[0].url, imports)})`));
  }
  if (request.urls[0].auth) {
    const [user, password] = request.urls[0].auth;
    lines.push(indent2(`.basic_auth(${repr13(user, imports)}, Some(${repr13(password, imports)}))`, 2));
  }
  if (request.headers.length) {
    lines.push(indent2(".headers(headers)", 2));
  }
  if (request.multipartUploads) {
    lines.push(indent2(".multipart(form)", 2));
  }
  if (request.data) {
    if (request.data && request.data.indexOf("\n") !== -1) {
      lines.push(indent2('.body(r#"', 2), request.data.toString(), '"#', indent2(")", 2));
    } else {
      lines.push(indent2(`.body(${repr13(request.data, imports)})`, 2));
    }
  }
  lines.push(indent2(".send()?", 2), indent2(".text()?;", 2), indent2('println!("{}", res);'), "", indent2("Ok(())"), "}");
  const preambleLines = ["extern crate reqwest;"];
  {
    const imports2 = [
      { want: "header", condition: !!request.headers.length },
      { want: "blocking::multipart", condition: !!request.multipartUploads }
    ].filter((i) => i.condition).map((i) => i.want);
    if (imports2.length > 1) {
      preambleLines.push(`use reqwest::{${imports2.join(", ")}};`);
    } else if (imports2.length) {
      preambleLines.push(`use reqwest::${imports2[0]};`);
    }
  }
  for (const imp of Array.from(imports).sort()) {
    preambleLines.push("use " + imp + ";");
  }
  return [...preambleLines, ...lines].join("\n") + "\n";
}
function toRustWarn(curlCommand, warnings = []) {
  const requests = parseCurlCommand(curlCommand, supportedArgs18, warnings);
  const rust = _toRust(requests, warnings);
  return [rust, warnings];
}
function toRust(curlCommand) {
  return toRustWarn(curlCommand)[0];
}
export {
  CCError,
  toAnsible,
  toAnsibleWarn,
  toJavaScript as toBrowser,
  toJavaScriptWarn as toBrowserWarn,
  toCFML,
  toCFMLWarn,
  toCSharp,
  toCSharpWarn,
  toDart,
  toDartWarn,
  toElixir,
  toElixirWarn,
  toGo,
  toGoWarn,
  toJava,
  toJavaScript,
  toJavaScriptWarn,
  toJavaWarn,
  toJsonString,
  toJsonStringWarn,
  toMATLAB,
  toMATLABWarn,
  toNode,
  toNodeAxios,
  toNodeAxiosWarn,
  toNode as toNodeFetch,
  toNodeWarn as toNodeFetchWarn,
  toNodeGot,
  toNodeGotWarn,
  toNodeRequest,
  toNodeRequestWarn,
  toNodeWarn,
  toPhp,
  toPhpRequests,
  toPhpRequestsWarn,
  toPhpWarn,
  toPython,
  toPythonWarn,
  toR,
  toRWarn,
  toRuby,
  toRubyWarn,
  toRust,
  toRustWarn
};
//# sourceMappingURL=curlconverter.js.map
